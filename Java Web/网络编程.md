# 网络编程

## 1.概述

​	我们知道计算机之间的通信要经过一系列复杂的过程,计算机之间通过传输介质、通信设施和网络通信协议互联、实现资源共享和数据传输。而我们的网络编程就是使用程序使互联网的两个（或多个）计算机之间进行数据传输。当然作为Java语言的开发者，为了实现两个计算机之间的数据传输提供了一系列的接口，可以让我们进行更方便地开发，比如socket编程；

![image-20210825172923763](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/imgs/image-20210825172923763.png)

既然是网络编程那应该了解下相关的知识点：

计算机网络：

​	计算机网络是指两台或更多的计算机组成的网络，在同一个网络中，任意两台计算机都可以**直接通信**，因为素有计算机都需要遵循同一种网络协议。

互联网：

​	互联网是网络的网络，听起来有点绕口，即把很多计算机网络连接起来，形成一个全球**统一**的互联网

TCP/IP:

​	指**互联网协议**;其中最重要的两个协议是TCP协议和IP协议,只有使用TCP/IP协议的计算机才能够联入互联网,使用其他网络协议(例如NetBIOS、AppleTalk协议等)是无法联入互联网的。

![image-20210823190610527](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/imgs/image-20210823190610527.png)

> 计算机网络是通过传输介质、通信设施和网络通信协议，把分散在不同地点的计算机设备互联起来的。实现资源共享和数据传输的系统。
>
> 网络编程就是编写程序使互联网的两个（或多个）设备（如计算机）之间进行数据传输。Java语言对网络编程提供了良好的支持，通过其提供的接口我们可以很方便进行网络编程

## 2.网络分层

**概念:**计算机网络总共分类为**网络协议**和**网络体系结构**

### 2.1 网络体系结构

​	通过网络发送数据是一项复杂的操作，必须仔细协调网络的物理特性以及发送数据的逻辑特征，通过网络数据从一台主机发送到另外的主机，而这个过程就是**计算机网络通信**来完成的。

网络通信：网络通信的不同方面被分解为多个层，层与层之间用接口连接。通信的双方具有相同的层次，层次实现的功能由协议数据单元（PDU）来描述。不同系统中的同一层构成对等层，对等层之间通过对等层协议来进行通信，理解批次定义好的规则和约定，每一层表示为物理硬件（即线缆和电流）与所传输信息之间的不同抽象层次，在理论上，每一层只与紧挨其上和其下的层对话，将网络分层，这样就可以修改甚至替换某一层的软件，只要层与层之间的接口保持不变，就不会影响到其他层。

我对以上网络通信的知识点进行总结：

1. 计算机之间的网络通信被分解为多个层，层与层之间用接口连接。
2. 通信的双方具有相同的层次，层次实现的功能由协议数据单元（PDU）来描述
3. 不同系统中的同一层构成对等层，对等层之间通过对等层协议进行通信
4. 在通信的时候数据必须由一层依次传递到下一层，不能跨级传输，

**概念：**计算机网络体系结构是计算机网络层次和协议的集合，网络体系结构对计算机网络实现的功能，以及网络协议、层次、接口和服务进行了描述，但并不涉及具体的实现，接口是同一节点内相邻层之间的交换信息的连接处，也叫服务访问点（SAP）。

![img](https://i.loli.net/2021/08/24/sQekl5hH6AwW2bd.png)

世界上第一个网络体系结构由IBM公司提出（1974年，SNA），以后其他公司也相继提出自己的网络体系结构。为了促进计算机网络的发展，国际标准化组织ISO在现有网络的基础上，提出了不基于具体机型、操作系统或公司的网络体系结构，称为开放系统互连参考模型，即OSI/RM（Open System Interconnection Reference Model）。

　　ISO制定的OSI参考模型过于庞大、复杂招致了许多批评。与此相对，美国国防部提出了TCP/IP协议栈参考模型，简化了OSI参考模型，由于TCP/IP协议栈的简单，获得了广泛的应用，并成为后续因特网使用的参考模型。

#### 2.1.1 OSI模型

**概念：**OSI参考模型是国际标准化组织ISO提出的的一个概念模型，试图使各种不同的计算机和网络在世界范围内实现互联的标准框架，它将计算机网络体系机构划分为七层，每层都可以提供抽象良好的接口，把网络通信的工作分为7层，分别是物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。

先来个OSI大纲：

![img](https://i.loli.net/2021/08/24/gwmuQHFKqIDJ9Le.png)

再来看一下每一层对应的接口和协议：

![在这里插入图片描述](https://i.loli.net/2021/08/24/bo3y85sM7vUhtrD.png)

再来个完整版的:

![image-20210825172711677](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/imgs/image-20210825172711677.png)

##### 2.1.1.1 各层介绍

我将对OSI每一层进行一个介绍：

先来个总纲：

![在这里插入图片描述](https://i.loli.net/2021/08/24/uBmNUFCwIXj1fA7.png)

1. 物理层：
   - 物理层处于OSI的最底层，是整个开放系统的基础。物理层设计通信管道上传输的原始比特流（bits），它的功能主要是为数据端设备提供传送数据的通路以及传输数据。负责最后将信息编码成电流脉冲或其它信号用于网上传输；
   - ![img](https://img-blog.csdnimg.cn/20190424101547460.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW9ob25nX2Jv,size_16,color_FFFFFF,t_70)
2. 数据链路层
   - 数据链路层的主要任务是实现计算机网络中相邻节点之间的可靠传输，把最原始的、有差错的物理传输线加上数据链路协议以后，构成逻辑上可靠的数据链路。需要完成的功能有链路管理、成帧、差错控制以及流量控制等。其中成帧是对物理层的原始比特流进行界定，数据链路层也能够对帧的丢失进行处理。
   - 可以简单的理解为：规定了0和1的分包形式，确定了网络数据包的形式；
   - ![在这里插入图片描述](https://i.loli.net/2021/08/24/LKD7wWvV4OTPzex.png)
3. 网络层
   - 网络层涉及源主机节点到目的主机节点之间可靠的网络传输，它需要完成的功能主要包括路由选择、网络寻址、流量控制、拥塞控制、网络互联等。
   - 可以理解为，此处需要确定计算机的位置，怎么确定？IPv4，IPv6！
   - ![在这里插入图片描述](https://i.loli.net/2021/08/24/NeKkYV5lDpG1taZ.png)
4. 传输层
   - 传输层起着承上启下的作用，涉及源端节点到目的端节点之间可靠的信息传输，传输层需要解决跨越网络连接的建立和释放。对底层不可靠的网络建立连接时需要三次握手，释放连接时需要四次挥手
   - 可以理解为：每一个应用程序都会在网卡注册一个端口号，该层就是端口与端口的通信！常用的（TCP／IP）协议；
   - ![在这里插入图片描述](https://i.loli.net/2021/08/24/qebot1vZBjkWiSO.png)
5. 会话层
   - 会话层的主要功能是负责应用程序之间建立、维持和中断会话，同时也提供对设备和终点之间的会话控制，协调系统和服务之间的交流，并通过提供单工、半双工和全双工3种不同的通信方式，使系统和服务之间有序地进行通信
   - 可以理解为：会话层建立、管理和终止表示层与实体之间的通信会话；建立一个连接（自动的手机信息、自动的网络寻址）;
   - ![在这里插入图片描述](https://i.loli.net/2021/08/24/7wBCpO9ehurRLNg.png)
6. 表示层
   - 表示层关心所传输数据信息的格式定义，其主要功能是把应用层提供的信息变换为能够共同理解的形式，提供字符代码、数据格式、控制信息格式、加密等的统一表示。
   - 可以理解为：解决不同系统之间的通信，eg：Linux下的QQ和Windows下的QQ可以通信；
   - ![在这里插入图片描述](https://i.loli.net/2021/08/24/ph6lkxnK7m1vbCa.png)
7. 应用层
   - 应用层为OSI的最高层，是直接为应用进程提供服务的。其作用是在实现多个系统应用进程相互通信的同时，完成一系列业务处理所需的服务。
   - OSI 的应用层协议包括文件的传输、访问及管理协议(FTAM) ,以及文件虚拟终端协议(VIP)和公用管理系统信息(CMIP)等;
     规定数据的传输协议；
   - ![在这里插入图片描述](https://i.loli.net/2021/08/24/ZcYkBt9giwAFDSX.png)
   - 其中常见的应用层协议：
   - ![在这里插入图片描述](https://i.loli.net/2021/08/24/rWGNcJeys5MdogQ.png)

> 互联网分层结构的好处：上层的变动完全不影响下层的结构

#### 2.1.2 TCP/IP模型

**由来:**它的由来是建立在OSI模型的基础上的,是因为OSI模型过于庞大且复杂,后面美国国防部才推出这款协议简单的TCP/IP;

**概念:**TCP/IP为传输控制协议/因特尔互联网协议,是Internet最基本的协议,Internet国际互联网的基础

​	TCP/IP协议是一个开放的网络协议簇,它的名字主要取自最重要的**网络层**IP协议和传输层TCP协议。TCP/IP协议定义了电子设备如何连入因特网，以及数据如何在它们之间传输的**标准**。TCP/IP参考模型采用4层的层级结构，每一层都呼叫它的下一层所提供的协议来完成自己的需求，这4个层次分别是：网络接口层、网络层（IP层）、传输层（TCP层）、应用层。

简述:

1. OSI模型所分的七层,在实际应用中,往往有一些层被整合,或者功能分散到其他层去,TCP/IP没有照搬OSI模型,也没有一个公认的TC/IP层级模型,所以一般划分3到5层模型来描述TCP/IP协议。
2. 这里用4层模型来描述，那么每一层都和OSI模型有较强的相关性但是又可能会有交叉
3. TCP/IP的设计是吸取了分层模型的精华思想--封装，每层对上一层提供服务的时候，上一层的数据结构是黑盒，直接作为本层的数据而不需要关心上一层协议的任何细节

![img](https://img2018.cnblogs.com/blog/1217276/201905/1217276-20190503162526581-1315509304.gif)

##### 2.1.2.1 各层介绍

先来看这张图：
![在这里插入图片描述](https://i.loli.net/2021/08/24/ZFenAYsM4UJpm71.png)

对应着我们日常常用的每一层所具体是干什么的，每一层分别负责不同的通信功能

1. 网络接口层：
   - 首先对应的是OSI参考模型的物理层和数据链路层，用于协作IP数据在已有网络介质上传输的数据，它用于定义物理传输管道。通常是对某些网络连接设备的驱动协议，例如针对光纤、网线提供的驱动
2. 网络层(IP)：
   - 首先对应的是OSI参考模型的网络层,本层是整个TCP/IP协议栈的核心,它的功能是把分组发往目标计算机或者网络,因此,分组到达的顺序和发送的顺序可能不同,这就需要上层对分组进行排序.网络层除了需要完成路由的功能外,也可以完成将不同类型的网络(异构网)互联的任务,除此之外,互联网还需要完成拥塞控制的功能,因此,综上所述可以简单的理解为该层时确定计算机的位置
3. 传输层(TCP)：
   - 首先对应的是OSI参考模型中的传输层;传输层负责在应用进程之间建立端到端的连接和可靠通信,TCP层涉及两个协议(TCP、UDP),其中TCP协议提供面向连接的服务,提供按字节流的有序、可靠传输，可以实现连接管理、差错控制、拥塞控制等，成可靠连接。UDP协议提供无连接的服务，用于不需要或无法实现面向连接的网络应用中，也叫不可靠传输，
   - 这个也就是TCP：三次握手、四次挥手；UDP：只发不管别人收不收得到--很任性！
4. 应用层：
   - 主要负责应用程序的协议，例如：HTTP协议、FTP协议等等，都主要是为各种网络应用提供服务！

### 2.2 网络协议

**概念：**如同人与人之间相互交流是需要遵循一定的规则（如语言）一样，计算机之间能够进行相互通信是因为它们都共同遵守一定的**规则**，即网络协议！

就拿我们刚刚介绍的OSI模型和TCP/IP模型在不同的层次中有许多不同的网络协议。如图所示：

![img](https://i.loli.net/2021/08/24/qHkMR4PxGCEfeSs.png)

而这各层之间的协议就是我们现在说的网络协议，下面是网络协议的关系图：

![img](https://i.loli.net/2021/08/24/bmuEf2LWROxPcBV.png)

下面我们抽出来一些重要的协议看一下。其他的协议用到的时候再说：

#### 2.2.1 IP协议

**概念：**IP协议的作用就在于把各种数据包准备无误的传递给对方。由于IP地址是稀有资源，不可能每个人都拥有一个IP地址，所以我们通常的IP地址是路由器给我们生成的IP地址，路由器里面会记录我们的MAC地址，而MAC地址是全球唯一的。举个例子：IP地址就是如同我们居住小区的地址，而MAC地址是我们住的那栋楼那个房间的那个人。IP地址采用的IPv4的格式，目前正在向IPv6过渡。

IP地址分为两大类：

1. IPv4：
   - 32位，分4段,(每段的范围0~255),而0~255之间的用十进制来表示。使用4个8位的二进制数据表示，每8位之间使用圆点隔开，每个8位整数可以转换成一个0~255的十进制整数，因此我们一般看到的IP地址类似：192.168.1.1（这4段组成的个数有限度（42.28亿,全世界人口76亿左右),所以就会可能不够用,所以就出现了IPv6;
2. IPv6：
   - 128位,分8段,0000~FFFF的十六进制数值,冒号分割,如:1080:0:0:0:8:800:200c:417A;

IP地址号段分类:

![image-20210824135102021](https://i.loli.net/2021/08/24/dFbn2HWtaOJ7r16.png)

其中A类地址留给政府机构,B类分配给中等规模的公司,C类分配给任意需要的人，D类用于组播，E类用于实验

**注意:**

1. 外网IP是全世界唯一的IP地址，仅分配给一个网络设备（计算机、交互机、路由器、打印机、光纤等）。而内网IP是由路由器分配给每一部内部使用的IP地址，而内网的所有用户都是通过同一个外网IP地址进行上网的；
2. 内网的IP地址每个人的都不一样，Internet上的用户也无法直接访问到内网用户。简单来说呢，外网IP就是标示了您在整个互联网上的地址，就相当于小区的地址，而内网IP呢，就是标识着您在局域网里面的地址，也就是小区内的几栋几楼几号房子；
3. 在局域网中，每台电脑都可以自己分配自己的IP，这个IP只在局域网中有效。而如果你将电脑连接到互联网，你的网络提供商（ISP）的服务器会为你分配一个IP地址，这个IP地址才是你在外网的IP。两个IP同时存在，一个对内，一个对外;
4. 区分内网和公网IP的区别，公网IP是全球唯一的，而内网IP只是再局域网内有效，不具有公网IP的作用。查询公网IP地址：www.ip138.com

##### 2.2.1.1 InetAddress类

在Java中使用IP地址进行网络编程使用的是`java.net Class InetAddress`来进行获得IP地址对象的方法,也可理解这个类用于表示互联网中的IP地址

给你们介绍几个常用的:

1. static InetAddress getLocalHost()		--	返回本地主机IP
2. static InetAddress getByName(String host)	--	根据主机名或域名获取IP
3. static InetAddress getByAddress(byte[] addr)--	根据一个ip地址获得一个IP地址对象
4. boolean isReachable(int timeout)	--	测试是否能在指定时间内连通该地址 （类似ping）

贴代码:

```java
package org.javaweb.scokettest;

import org.junit.Test;

import java.net.InetAddress;

/**
 * @program: YmsdLearn
 * @description: 获取ip
 * @author: MiaoWei
 * @create: 2021-08-22 14:42
 */
public class IPDemo {
  @Test
  public void test() throws Exception {
    InetAddress host = InetAddress.getLocalHost();
    System.out.println("得到本机地址: " + host);

    InetAddress address = InetAddress.getByName("DESKTOP-J0R2HIH");
    System.out.println("根据主机名取得IP:" + address);

    boolean reachable = host.isReachable(5000);
    System.out.println("端口能被ping通吗?" + reachable);
  }
}
```

结果:

![image-20210824140422309](https://i.loli.net/2021/08/24/j5Ati2Cy3R1gEx4.png)

这里因为隐私性就不把本地地址给贴出来了,其他方法都类似。

##### 2.2.1.2 Port端口

**概念:**端口port用来区分不同的应用程序，端口号范围为0~65535，其中0~1023被系统所保留，如果自定义端口号，建议为1023以后的;

**说明:**

1. 在计算机中，**不同的应用程序** 是通过 **端口号**区分的。
2. 端口号是用两个字节（16位的二进制数）表示的，它的取值范围是0~65535， 其中，0~1023之间的端口号用于一些知名的网络服务和应用，用户的普通应用程序需要使用1024以上的端口号，从而避免端口号被另外一个应用或服务所占用
3. 通过IP地址可以连接到指定计算机，但如果想访问目标计算机中的某个应用程序，还需要指定端口号。
4. 同一台机器上不能有两个程序使用同一个端口，会冲突

##### 2.2.1.3 URL统一资源定位符

**URL概念:**可以直接使用此类找到互联网上的资源如一个简单的网页。一般由：协议名，资源所在主机，端口，资源名等部分组成。

比如我们在浏览器地址栏输入的地址,我们可以解读:

![](https://i.loli.net/2021/08/25/Kb2EV5UdAYlgIk8.png)

统一资源定位是一类事务，

在Java中用`URL`类可以表示为统一资源定位符,一个资源的定位就是一个URL对象，可以理解为在Java中通过URL可以定位到一个资源的位置

URL中常用的方法:

1. URL(String protocol, String host, int port, String file)
2. URL(String url)
3. InputStream openStream() ：打开到此 URL 的连接并返回一个用于从该连接读入的 InputStream；

直接上代码:

```java
package org.javaweb.scokettest;

import org.junit.Test;

import java.io.FileOutputStream;
import java.io.InputStream;
import java.net.URL;

/**
 * @program: YmsdLearn
 * @description: 模拟URL统一资源定位符
 * @author: MiaoWei
 * @create: 2021-08-24 14:13
 */
public class URLDemo {
  @Test
  public void test() throws Exception {
    // 创建输入流
    URL url = new URL("https://www.cnblogs.com/qjk95/p/12714251.html/");
    InputStream inputStream = url.openStream();
    // 输出流
    FileOutputStream outputStream =
        new FileOutputStream("C:\\Users\\MiaoDaWei\\Desktop\\temp\\网络编程.html");
    // 实现下载
    byte[] bytes = new byte[1024*10];
    int len;
    while ((len = inputStream.read(bytes)) != -1) {
      outputStream.write(bytes, 0, len);

      // 释放资源
      outputStream.flush();
      outputStream.close();
      inputStream.close();
    }
  }
}
```

理解一下就行!

在介绍一个我们后面进行JSP开发的时候,如果在地址栏里要用中文进行参数传输那么我们就应该对其进行编码操作;

一般在网络程序开发的时候使用到了`URLEncode`

```java
package org.javaweb.scokettest;

import java.net.URLDecoder;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;

/**
 * @program: YmsdLearn
 * @description: 编码和解码
 * @author: MiaoWei
 * @create: 2021-08-24 14:27
 */
public class URLEncoderDemo {
  public static void main(String[] args) {
    String str = "大西瓜大西瓜";
    String encode = URLEncoder.encode(str, StandardCharsets.UTF_8);
    System.out.println("编码操作:" + encode);

    String decode = URLDecoder.decode(encode, StandardCharsets.UTF_8);
    System.out.println("解码操作:" + decode);
  }
}
```

结果:

![image-20210824143044905](https://i.loli.net/2021/08/24/lDICTidsHXZS2VG.png)

#### 2.2.2 UDP协议与TCP协议

1. UDP协议

   **概念:**UDP是**无连接**通信协议,即在数据传输时,数据的发送端和接收端**不建立逻辑连接**，无连接、不可靠和基于数据报的用户数据协议

   **理解:**简单来说,当一台计算机向另一台计算机发送数据时,发送端不会确认接收端是否存在,就会发出数据,同样接收端在收到数据时,也不会向发送端反馈是否收到数据，只是把数据发送出去，并不能保证达到目的地，并且没有超时重发机制，所以传输速度就很块，

   **特点:**由于使用UDP协议消耗资源小,通信效率高,所以通常都会用于音频、视频和普通数据的传输例如视频会议都是要UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响，所以它是不可靠传输协议，容易丢包但是效率高，快，占用资源少

2. TCP协议

   **概念:**TCP协议是**面向连接**的传输控制协议,即在传输数据前先在发送端和接收端建立逻辑连接,然后再传输数据,它提供了两台计算机之间可靠无差错的数据传输,TCP协议使用超时重传、数据确认等方式来确保数据包被正确地发送目的端，故而效率低，速度慢；可靠不丢包，用于传输文件等场景，缺点就是效率低，慢而且占用资源

   **特点:**在TCP连接中必须要明确客户端与服务器端,由于客户端向服务端发出连接请求,每次连接的创建都需要经过"三次握手"

   - 第一次握手:客户端向服务器端发出连接请求,等待服务器确认
   - 第二次握手:服务器端向客户端回送一个响应,通知客户端收到了连接请求
   - 第三次握手:客户端再次向服务器端发送确认信息,确认连接

##### 1. UDP协议

**概念:**用户数据报协议,它是TCP/IP协议簇中无连接的运输层协议

1. UDP是一个非连接的协议,传输数据之前源端和终端不建立连接,当它想传送时就简单地抓取来自应用程序的数据,并尽可能快地把它扔到网络上。在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、计算机的能力和传输带宽的限制；在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段
2. 由于传输数据不建立连接，因此也就不需要维护连接状态，包括收发状态等，因此一台服务器可同时向多个客户端传输相同的消息
3. UDP信息包的标题很短，只有8个字节，相对于TCP的20个字节信息的额外开销很小。
4. 吞吐量不受拥挤控制算法的调节，只受应用软件生成数据的速率、传输带宽、源端和终端主机性能的限制。
5. UDP使用尽量最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态表。
6. UDP是面向报文的，发送方的UDP对应用程序交下来的报文，在添加首部受就向下交付给IP层，既不拆分，也不合并，而且保留这些报文的边界，因此，应用程序需要选择合适的报文大小

UDP协议格式：

![img](https://i.loli.net/2021/08/24/yqv1bEcmld7RADn.png)



**说明：**UDP协议由两部分组成：首部和数据。其中，首部仅有8个字节，包括源端口和目的端口、长度（UDP用于数据报的长度）、校验和

###### 1.1 UDP编程

先介绍一下UDP通信:

1. 数据包和发送对象

   - **DatagramPacket数据包**的作用就是如同是"集装箱",可以将发送端或者接收端的数据封装起来,然而运输只有"集装箱"是不够的,还需要码头.
   - **DatagramSocket类**这就是JDK提供的一个"码头",使用这个类的实例对象就可以发送和接收`DatagramPacket数据包`

   解释:`DatagramPacket`:封装数据,`DatagramSocket`:发送DatagramPacket

2. UDP发送端

   - 实现UDP协议的发送端

     - 实现封装数据的类`java.net.DatagramPacket`将数据包装
     - 实现数据传输的类`java.net.DatagramSocket`将数据包发出去

   - 实现步骤

     1. 创建`DatagramPacket`对象,封装数据,接收的地址和端口
     2. 创建`DatagramSocket`对象
     3. 调用`DatagramSocket`类对象`send`,发送数据包
     4. 关闭资源

   - 介绍两者的构造方法:

     - DatagramPacket构造方法

       ```java
       DatagramPacket(byte[] buf,int length,InetAddress address,int port):字节数组,发送多少,IP地址,端口号
       ```

     - DatagramSocket构造方法:

       ```java
       DatagramSocket():空参数
       方法:send(DatagramPacket d)    
       ```

3. UDP接收端

   - 实现UDP接收端

     - 实现封装数据包`java.net.DatagramPacket`将数据接收
     - 实现数据传输`java.net.DatagramSocket`接收数据包

   - 实现步骤

     1. 创建`DatagramSocket`对象,绑定端口号,要和发送端口号一致
     2. 创建字节数组,接收发来的数据
     3. 创建数据包对象`DatagramPacket`
     4. 调用`DatagramSocket`对象方法,`receive(DategramPacket dp)`接收数据,数据放在数据包中
     5. 拆包
        - 发送的地址:数据包对象`DatagramPacket`方法`getAddress()`获取的是发送端的IP地址对象,返回值是InetAddress对象
        - 接收到的字节个数:数据包对象`DatagramPacket`方法`getLength()`
        - 发送方的端口号:数据包对象`DatagramPacket`方法`getPort()`发送端口
     6. 关闭资源

     

这是发送端:

```java
public static void main(String[] args) throws Exception {
    // 创建数据包对象,封装要发送的数据,接收端IP,端口
    byte[] date = "你好UDP".getBytes(StandardCharsets.UTF_8);
    // 创建InetAddress对象,封装自己的IP地址
    InetAddress inet = InetAddress.getByName("127.0.0.1");
    // 封装数据
    DatagramPacket packet = new DatagramPacket(date, date.length, inet, 6001);
    // 创建DatagramSocket对象,数据包的发送和接收对象
    DatagramSocket socket = new DatagramSocket();
    // 发送
    socket.send(packet);
    //关闭资源
    socket.close();
    new UDPDdemo().test();
  }
```

接收端:

```java
@Test
  public void test() throws Exception{
    // 创建数据包传输对象DatagramSocket 绑定端口号
    DatagramSocket socket = new DatagramSocket(6001);
    //创建一个空的字节数组
    byte[] bytes = new byte[1024];
    // 创建数据包对象,传递字节数组
    DatagramPacket packet = new DatagramPacket(bytes, bytes.length);
    // 调用方法receive传递数据包
    socket.receive(packet);

    // 获取发送端的IP地址对象
    String address = packet.getAddress().getHostAddress();

    // 获取发送的端口号
    int port = packet.getPort();

    // 获取接收到的字节个数
    int length = packet.getLength();

    // 打印
    System.out.println(address+" "+port+" : "+new String(bytes,0,length));

    //关闭
    socket.close();
  }
```

###### 1.2 UDP优缺点

优点:

1. UDP只使用一个socket进行通信,不像TCP需要为每一个客户端建立一个socket连接
2. 不属于连接型协议,因而具有资源消耗小,处理速度快的优点,

缺点:

1. 在网络质量令人不是十分满意的环境下,UDP协议数据包丢失会比较严重

> 应用场景:使用UDP通常音频、视频和普通数据在传送时使用UDP较多，因为它们即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响，比如聊天用的ICQ和QQ使用的就是UDP协议。

##### 2. TCP协议

引入：现在两台计算机已经连接上了，那怎么样才能让数据从一端传送到另外一端？

1. TCP协议是传输控制协议，TCP是一种面向**长连接**的、可靠的、基于**字节流**的传输层的通信协议。当客户和服务器彼此传递数据前，必须先在双方之间建立一个TCP连接，之后才能传输数据
2. 当客户端和服务器彼此交互数据前，必须先在双方之间建立一个TCP连接，之后才能传输数据，TCP协议使用超时重传、数据确认等方式来确保数据包被正确地发送至目的端，故而效率低，速度慢；
3. TCP可靠性传输协议，不丢包，经常用来传输文件（回值内部处理），缺点是效率低，慢，而且占用资源  ，相当于打电话；

**概念：**TCP（传输控制协议）是面向连接的传输层协议。TCP层是位于IP层之上，应用层之下的中间层，不同主机的应用层之间经常需要可靠的、像管道一样的连接，但是IP层不提供这样的流机制，而是提供不可靠的包交换，TCP协议采用字节流传输数据



**报文格式：**

TCP报文段包括协议首部和数据两部分，协议首部的固定部分是20个字节，首部的固定部分后面是选项部分。

![img](https://i.loli.net/2021/08/24/PWfijXFVk5nzvJI.jpg)

下面是报文段首部各个字段的含义：

1. **源端口号以及目的端口号**：各站2个字节，端口是传输层和应用层的服务接口，用于寻找发送端和接收端的进程，一般来讲，通过端口号和IP地址，可以唯一确定一个TCP连接，在网络编程中，通常被称为一个socket接口.
2. **序号**:Seq序号,占4个字节、32位。用来表示从TCP发送端向TCP接收端发送的数据字节流，发起方发送数据时对此进行标记
3. **确认序号**：Ack序号,占4个字节、32位。包含发送确认的一端所期望收到的下一个序号。只有ACK标记为1时，确认序号字段才高效，因此，确认序号应该是上次已经成功收到数据字节序号+1，即Ack=Seq+1
4. **数据偏移**:占4个字节,用于指出TCP首部长度,若不存在选项,则这个值为20字节,数据偏移的最大值为60字节
5. **保留字段:**占6位,暂时可以忽略,值全为0
6. **标志位:**
   - URG(紧急):为1时表明紧急指针字段有效
   - ACK(确认):为1时表明确认号字段有效
   - PSH(推送):为1时接收方应尽快将这个报文段交给应用层
   - RST(复位):为1时表明TCP连接出现故障必须重建连接
   - SYN(同步):在连接建立时用来同步序号
   - FIN(终止):为1时表明发送端数据发送完毕要求释放连接
7. **接收窗口**:占2个字节,用于流量控制和拥塞控制,表示当前接收缓冲区的大小,在计算机网络中,通常是用接收方法的接收能力的大小来控制发送放的数据发送量,TCP连接的一端根据缓冲区大小确定自己的接收窗口值,告诉对方,使对方可以确定发送数据的字节数
8. **检验和**:占2个字节,范围包括首部和数据两部分
9. 选项是可选的,默认情况是不选.

###### 2.1 TCP编程

**概述:**

1. TCP通信同UDP通信一样,都能实现两台计算机之间的通信,通信的两端都需要创建`socket`对象
2. 区别就在于UDP只有**发送端**和**接收端**,不分**客户端**和**服务器端**,计算机之间可以任意地发送数据
3. 而TCP通信严格区分客户端与服务器端的,在通信时,必须**先有客户端去连接服务器端才能实现通信**,服务器端**不可以主动连接**客户端,并且**服务器**端程序要**事先启动**,等待客户端的连接.
4. 在JDK中提供了两个类用于实现TCP程序,一个是`ServerSocket`类,用于表示服务器端,另一个是`Socket`类,用于表示客户端
5. 在通信时,首先创建代表服务器端的`ServerSocket`对象,该对象相当于开启了一个服务,并等待客户端的连接,然后创建代表客户端的`socket`对象向服务器端发出连接请求,服务器端响应请求,两者建立连接开始通信

> 一个socket连接如何唯一标识?
>
> 源端(ip+端口号)、目的（ip+端口号）唯一确定一个TCP连接

> TCP是个面向连接的、可靠的、基于字节流的传输层通信协议!

![image-20210826094230894](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/imgs/image-20210826094230894.png)

面向连接:就是建立连接、使用连接、释放连接。

- 建立连接是指我们熟悉的TCP三次握手
- 使用连接指一发送、一确认的形式，进行数据传输
- 释放连接是指常用的TCP四次挥手

来吧，开始我们接下来的TCP代码实现：

1. TCP的客户端程序：

   - 实现TCP客户端，连接到服务器和服务器实现数据交换

   - 实现TCP客户端程序的类： `java.net.Socket`

   - 构造方法

     ```java
     1. Socket(String host, int port) ：//传递服务器IP和端口号
     注意:构造方法只要运行那么就会和服务器进行连接,如果出现连接失败那么就会抛出异常    
     2. OutputStream getOutputStream()://返回套接字的输出流
     作用:将数据输出,输出到服务器
     3. InputStream getInputStream();//返回套接字的输入流
     作用:从服务器端读取数据
     ```

   - 客户端服务器数据交换，必须使用套接字对象 **Socket** 中的获取的IO流，自己 **new** 的流是不行的

2. TCP的服务器端程序

   - 表示服务器程序的类： `java.net.ServerSocket`

   - 构造方法

     ```java
     ServerSocket(int port)： 传递端口号
     ```

   - 必须要获得客户端的套接字对象 Socket：`Socket accept()`

上代码:

客户端:

```java
@Test
  public void test() throws Exception {
    // 创建socket对象,连接服务器
    Socket socket = new Socket("127.0.0.1", 8888);
    // 通过客户端的套接字对象socket方法,获取字节输出流将数据写向服务器
    OutputStream outputStream = socket.getOutputStream();
    outputStream.write("服务器ok!".getBytes(StandardCharsets.UTF_8));

    // 读取服务器发回的数据,使用socket套接字对象中的字节输入流
    InputStream inputStream = socket.getInputStream();
    byte[] bytes = new byte[1024];
    int read = inputStream.read(bytes);
    System.out.println(new String(bytes, 0, read));

    socket.close();
  }
```

服务器:

```java
@Test
public void test1()throws Exception{
  ServerSocket serverSocket = new ServerSocket(8888);
  // 调用服务器套接字对象中的方法accpet(),获取客户端套接字对象
  Socket accept = serverSocket.accept();
  // 通过客户端套接字对象Socket,获取字节输入流,读取客户端发送来的消息
  InputStream inputStream = accept.getInputStream();
  byte[] data = new byte[1024];
  int read = inputStream.read(data);
  System.out.println(new String(data, 0, read));

  OutputStream stream = accept.getOutputStream();
  stream.write("收到,谢谢!!".getBytes(StandardCharsets.UTF_8));

  accept.close();
  serverSocket.close();
}
```

结果：

服务端：

![image-20210826163207278](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/imgs/image-20210826163207278.png)

客户端：

​	![image-20210826163230738](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/imgs/image-20210826163230738.png)

**理解**:通过上面简单的demo可以看出建立Socket可以双向发消息,获取对应的字节流无需那么复杂直接用就OK,反正字节流万事万物都可处理,文本也可以只不过要转一下就行,稍微复杂一点就是下面的Socket编程的示例;连接后准备启动要注意,要先启动服务端在启动客户端,要注意关流哦!

###### 2.2三次握手与四次挥手

**概念:**TCP是面向连接的协议,因此每个TCP连接都有3个阶段:**连接建立**、**数据传送**和**连接释放**，而经历这3个阶段通常称为“三次握手”；

TCP三次握手过程如下：

![img](https://i.loli.net/2021/08/24/DrOHVS6E1g4XGeU.jpg)

解读：

1. 第一握手（客户端发送请求）

   - 客户机发送连接请求报文段到服务器，并进入**SYN_SEN**状态，等待服务器确认，

   - 发送连接请求报文段内容：SYN=1，seq=x；

     ```
     其中SYN=1意思是一个TCP的SYN标志位置为1的包，指明客户端打算连接的服务器的端口；seq=x表示客户端初始序号x，保存在包头的序列号（Sequence Number)字段里
     ```

2. 第二次握手(服务器回传确认)

   - 服务器收到客户端连接请求报文.如果同意建立连接,向客户机发回确认报文段(APK)应答,并为该TCP连接分配TCP缓存和变量.此时进入**SYN_RECV**状态，这个状态被称为半连接状态

     服务器发回确认报文段内容:SYN=1,ACK=1,seq=y,ack=x+1;

     ```
     SYN标志位和ACK标志位均为1,同时将确认序号(Acknowledgement Number)设置为客户的ISN加1,即x+1;seq=y为服务端初始序号y
     ```

3. 第三次握手(客户端回传请求)

   - 客户机收到服务器的确认报文段后,向服务器给出确认报文段(ACK),并且也要给该连接分配缓存和变量,此包发送完毕,客户端和服务器进入**ESTABLISHED**(TCP连接成功)状态,完成了三次握手

     客户端发回确认报文段内容:ACK=1,seq=x+1,ack=y+1

     ```
     ACK=1为确认报文段;seq=x+1为客户端序号加1;ack=y+1为服务器发来的ACK的初始序号字段+1
     ```

**注意:**握手过程中传送的包里不包含数据,三次握手完毕后客户端与服务器才正式开始传送数据

你可能有点不太理解,我来个更通俗一点的吧:

```java
1.第一次握手(客户端发送请求)
 	男孩:"咱俩处对象吧",并等待对方回复请求.
2.第二次握手(服务器回传确认)
    女孩:告诉男孩说"可以",
3.第三次握手(客户端回传确认)
    男孩说:"那就在一块吧",于是两人有了情侣链接关系了.	
```

来张更清楚的图:

![image-20210825173107842](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/imgs/image-20210825173107842.png)



TCP四次挥手过程如下:

![img](https://i.loli.net/2021/08/24/BVAdiWlTvkXGPpo.png)

​	由于TCP连接时全双工的,因此每个方向都必须单独进行关闭,这原则是当一方完成它的数据发送任务后就能发送一个**FIN**来终止这个方向的连接.而收到一个FIN只意味着这一方向上没有数据流动,一个TCP连接在收到一个FIN后仍能发送数据.首先进行关闭的一方将执行主动关闭,而另一方执行被动关闭。

解读：

客户端和服务器一开始都处于`ESTABLISHED`状态

1. TCP客户端发送一个FIN(表示"我不再发送数据了")，用来关闭客户端到服务端的数据传送，客户端进入**FIN_WAIT_1**状态。

   - 发送报文段内容：FIN=1，seq=u;

     ```java
     FIN=1表示请求切断连接;seq=u为客户端请求初始序号
     ```

2. 服务端收到这个FIN,它发回一个ACK给客户端(意思是:"我收到你的FIN了,也知道你不再发送数据了"),确认序号为收到的序号+1,和SYN一样,一个FIN将占用一个序号;服务端进入**CLOSE_WAIT**状态

   - 发送报文段内容:ACK=1,seq=v,ack=u+1;

     ```java
     ACK=1为确认报文;seq=v为服务器确认初始序号;ack=u+1为客户daunt初始序号加1
     ```
     
     **注意:**上面提到的是**主动方**不再发送数据了,但如果这时候,**被动方**还有数据要发,那就继续发,注意,虽然第二次和第第三次挥手之间,被动方是能发数据到主动方的,但主动方能不能正常收就不一定了

3. 服务器关闭客户端的连接后,发送一个FIN给客户端,服务端进入**LAST_ACK**状态(在被动方感知到第二次挥手之后,会做一系列的收尾工作)

   - 发送报文段内容:FIN=1,ACK=1,seq=w,ack=u+1

     ```html
     FIN=1为请求切断连接,ACK=1为确认报文,seq=w服务端请求切断初始序号
     ```

4. 客户端收到FIN后,客户端进入**TIME_WAIT**状态,接着发回一个ACK报文给服务端确认,并将确认序号设置为收到序号+1,服务端进入**CLOSED**状态。完成四次挥手

   - 发送报文段内容：ACK=1,seq=u+1,ack=w+1

     ```
     ACK=1为确认报文,seq=u+1为客户端初始序号+1,ack=w+1为服务器初始序号+1
     ```


> 正常情况下,只要数据传输完了,不管是客户端还是服务端都可以主动发起四次挥手,进而释放连接

**注意:**跟上图一样,假设这四次挥手是由客户端发起的,那它就是**主动方**,服务器是被动接收客户端的挥手请求的,叫**被动方**

说明:其中第一次挥手和第三次挥手,都是我们在应用程序中主动触发的(比如调用[close()](不一定由应用程序主动触发的，可以是由意外情况退出都会发出FIN，其中FIN表示是指"我不再发送数据"，因此关闭读不会给对方发FIN, 关闭写才会发FIN。)方法),也就是我们平时写代码需要关注的地方

​	第二和第四次挥手,都是内核协议栈自动帮我们完成的,我们写代码的时候碰不到这地方,因此也不需要太关心

总之:不管是主动还是被动,每方发出一个`FIN`和一个`ACK`,也收到一个`FIN`和一个`ACK`。





再来一个通俗的解释:

```java
1.女孩:要和男孩分手,等待男孩回应
2.男孩:回复女孩,先同意分手,不过还是又考虑了一段时间
3.男孩思考了一段时间,还是选择了分手
4.女孩收到消息,于是两人正式分手
```

理解:这个四次挥手也就说,第一次客户端先发出断开的请求,然后服务端接收并确认然后返回给客户端一个信号,此时并没有开始断开,然后服务器就开始要断开连接了,此时就会给客户端一个请求,然后客户端真正意义上收到这个请求,之前的信号不管用,然后客户端收到服务器请求后,双方就开始真正意义上断开连接

这里我记录一个技术网址：https://mp.weixin.qq.com/s/CC46__2KVUKpvo48OFjsIw。关于TCP四次挥手的详细过程

###### 2.3 思考

为什么连接的是三次握手,关闭的时候却是四次挥手?

```java
因为服务端收到客户端的SYN连接请求报文后,可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时候，当服务端收到FIN报文时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，也即你可能还需要发送一些数据给对方之后很可能并不会立即关闭socket，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文，我收到了”。只有等到服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送，故而需要四步挥手。
```

###### 2.3 优缺点

优点:

1. 简单直接的长连接
2. 可靠的信息传输
3. 数据包的大小没有限制

缺点:

1. 对**阻塞**的控制

   ```html
   一般来说,TCP假定丢包是由于网络带宽不够造成的,所以发生这种情况的时候,TCP就会减少发包速度
   	在网络不佳的情况下,一个数据包丢失了,我们可能认为应该重发一个数据包,然后TCP的阻塞机制完全就是采用相反的方式来进行处理!且没有任何办法能绕开这个机制,因为这是TCP协议构建的基础,这也就很好的解释了我们有的时候打游戏比如英雄联盟的Ping值直接上升到1000多毫秒的原因
   ```

###### 2.4 一个TCP连接可以发送多少个HTTP请求?

TCP与HTTP的渊源:

​	我们知道TCP协议对应于传输层，HTTP协议对应于应用层。WEB项目中，HTTP协议是建立在TCP的基础上的。最初浏览器从服务器加载一个网页，会发起一个HTTP请求，这时需要先建立一个TCP连接。当本次数据请求完毕之后，会立刻断开TCP连接。但随着时间的推理，HTML网页内容越来越复杂，不仅有内容，还有JS、CSS和图片资源，每个资源的请求都建立一次TCP连接，效率就会很低。这时，Keep-Alive就被提出用来了，专门用于解决效率低的问题。

问题一:浏览器建立TCP连接之后，完成一次HTTP请求，是否会断开？

```http

	HTTP协议Header中的Connection属性决定了连接是否持久，不同HTTP协议版本有所不同。HTTP/1.0中Connection默认为close，即每次请求都会重新建立和断开TCP连接。缺点：建立和断开TCP连接，代价过大。HTTP/1.1中Connection默认为keep-alive，即连接可以复用，不用每次都重新建立和断开TCP连接。超时之后没有连接则主动断开。可以通过声明Connection为close进行关闭。
优点：TCP连接可被重复利用，减少建立连接的损耗，SSL的开销也可以避免。刷新页面时也可以复用，从而不再建立SSL连接等。
结论：默认情况下（HTTP/1.1）建立TCP连接不会断开，只有在请求报头中声明Connection: close才会请求完成之后关闭连接。不断开的最终目的是减少建立连接所导致的性能损耗。
```

问题二:一个TCP连接可以对应几个HTTP请求?

```http
如果Connection为close，则一个TCP连接只对应一个HTTP请求
如果Connection为Keep-alive，则一个TCP连接可对应一个到多个HTTP请求。
```

问题三:1个TCP连接中，可以同时发送多个HTTP请求吗？

```http
HTTP/1.1中单个TCP连接在同一时刻只能处理一个请求。HTTP/1.1在RFC 2616中规定了Pipelining来解决这个问题，但浏览器默认是关闭的。
RFC 2616中规定：一个支持持久连接的客户端可以在一个连接中发送多个请求（不需要等待任意请求的响应）。收到请求的服务器必须按照请求收到的顺序发送响应。
Pipelining本身存在一些问题，比如代理服务器不能正确处理HTTP Pipelining、Head-of-line Blocking连接头阻塞（首个请求耗时过长，阻塞其他请求）。所以，浏览器默认关闭该功能。
HTTP/2.0提供了多路复用技术Multiplexing，一个TCP可以并发多个HTTP请求（理论无上限，但是一般浏览器会有TCP并发数的限制）。
HTTP/1.1中为了提升性能，通常会采用连接复用和同时建立多个TCP连接的方式提升性能。
```

结论：HTTP/1.1中存在Pipelining技术支持一个连接发送多个请求，但存在弊端，浏览器默认关闭。HTTP/2.0中通过多路复用技术支持一个TCP连接中并发请求HTTP。



问题四：浏览器对同一Host建立TCP连接的数量有没限制？

```
不同浏览器限制不同，比如Chrome最多允许同一个Host可建立6个TCP连接。
如果服务器只支持HTTP/1.1，浏览器会采用在同一个Host下建立多个TCP连接来进行效率提升。如果是基于HTTPS传输，在SSL握手之后，还会尝试协商是否可以采用HTTP/2.0的Multiplexing功能。
```

问题五：keep-alive使用场景及优缺点

```
开启keep-alive对内存要求高，关闭keep-alive对CPU要求高；如果内存和CPU都足够，开启和关闭keep-alive对性能影响不大；如果考虑服务器压力，如果是静态页面，大量的调用js或者图片的话，建议开启keep-alive；如果是动态网页，建议关闭keep-alive。
```

**注意:**如果需要使用keep-alive功能，服务器端如果使用nginx中keepalive_timeout值要大于0。

##### 3. 区别和选择

区别:

1. TCP基于连接,UDP是无连接的;
   - 这也比较好理解，因为 TCP 连接需要经历"三次握手"；
2. 对系统资源的要求,TCP较多,UDP较少
3. UDP程序结构比较简单
4. TCP是流模式,而UDP是数据报模式;
   - 基于流的数据没有边界（长度）限制，而基于数据报的服务，每个UDP数据报都有一个长度，接收端必须以该长度为最小单位将其所有内容一次性读出；
5. TCP保证数据正确性,而UDP可能会丢包
6. TCP保证数据顺序,而UDP不保证
7. TCP 协议可靠，UDP 协议不可靠。
   - 可靠即指数据由A发送到B，是否能确保数据真的有送达到B；TCP 协议使用超时重传、数据确认等方式来确保数据包被正确地发送至目的端。而 UDP 协议无法保证数据从发送端正确传送到目的端，如果数据在传输过程中丢失或者目的端通过数据检验发现数据错误，则UDP协议只是简单地通知应用程序发送失败。对于 TCP 协议拥有的超时重传、数据确认等需要应用程序自己来处理这些逻辑
8. 它们都是传输层的协议
9. 总之：TCP 协议为应用层提供可靠的、面向连接的、基于流的服务。而 UDP 协议则与 TCP 协议完全相反，它为应用层提供不可靠、无连接和基于数据报的服务；

那我们就在思考我们是选择UDP还是TCP呢?

- 如果是由客户端间歇性的发起无状态的查询,并且偶尔发生延迟是可以容忍,那么使用HTTP/HTTPS吧
- 如果客户端和服务器都可以独立发包,但是偶尔发生延迟可以容忍(比如:在线的纸牌游戏,许多的MOBA类的游戏),那么使用TCP长连接吧
- 如果客户端和服务器都可以独立发包,而且无法忍受延迟(比如:大多数的多人动作类游戏,一些MOBA类游戏).那么就使用UDP吧

> 这些也应该考虑在内：你的MMO客户端也许首先使用HTTP去获取上一次的更新内容，然后使用UDP跟游戏服务器进行连接。

#### 2.3 HTTP协议

**概念:**超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议，是万维网的数据通信的基础。HTTP是一种应用层协议，它是基于TCP协议之上的请求/响应式的协议。HTTP协议是Web浏览器和Web服务器之间通信的标准协议。HTTP指定客户端与服务器如何建立连接、客户端如何从服务器请求数据，服务器如何响应请求，以及最后如何关闭连接。HTTP连接使用TCP/IP来传输数据。

HTTP协议的基本格式:

```
协议://服务器IP:[端口]/路径/[？查询]
```

说明:

HTTP是一个客户端与服务器端请求应答的标准（TCP）。可通过浏览器或者其它的工具，发起一个HTTP请求到服务器上指定端口（默认：80）。HTTP协议广泛应用于TCP/IP协议之上，但并非必须使用TCP/IP协议。HTTP假定下层协议可靠传输，因此能够保证这一要求的协议都可被使用,HTTP协议数据是**明文传输**，**不安全**，可基于HTTPS进行加密处理，通常使用SSL/TLS协议进行加密。

##### 2.3.1 工作流程:

客户端向服务器发送请求报文：

- 请求报文包含请求的方法、URL、协议版本、请求头部和请求数据

服务器响应客户端请求结果：

- 响应内容就包含协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据

对于从客户端到服务器的每一个请求,都有4个步骤:

1. 默认情况下,客户端在端口80打开与服务器的一个TCP连接,URL中还可以指定其他端口
2. 客户端向服务器发送消息,请求指定路径上的资源。这个资源包括一个首部，可选地（取决于请求的性质）还可以有一个空行，后面是这个请求的数据。
3. 服务器向客户端发送响应。响应以响应码开头，后面是包含数据的首部、一个空行以及所请求的文档或错误消息。
4. 服务器关闭连接。

> 基本使用流程：客户端发起HTTP请求，创建指定服务器（端口）的TCP连接。服务器监听对应端口（默认80端口），接收并处理请求，返回状态码（比如：“HTTP/1.1 200 OK")、内容、错误消息或其他消息

HTTP 请求/响应的基本步骤：

- 客户端（比如浏览器）连接到Web服务器（默认80端口），并建立TCP连接。
- 基于TCP，发起HTTP请求；
- 服务接受请求并返回相应报文；
- 释放连接TCP连接；、
- 客户端（浏览器）解析HTML内容并呈现

> 如果在浏览器输入URL地址，地址为域名，则还需先向DNS服务器请求解析域名对应的IP，然后在基于IP和端口建立TCP连接。

##### 2.3.2 协议特性

1. HTTP是无状态的
   - HTTP协议是无状态(stateless)协议。每次请求都是相互独立的，不会对请求或响应做持久化处理。好处：可以更快地处理大量事务、确保协议的可伸缩性。针对业务需要，可引入了Cookie（HTTP 1.1）和Session技术，用于管理状态。
2. 多次HTTP请求
   - 针对一个网页，并不是一次请求完成。客户端首先响应的是HTML页面，然后再加载其他资源（CSS、JS、图片等）。HTTP 2.0 支持管道机制，可以同时请求和响应多个请求，大大提高了效率。
3. 无连接
   - HTTP 1.0每次连接只处理一个请求。服务器处理完客户的请求，收到客户的应答后，即断开连接。目的是节省传输时间、提高并发性能。HTTP 1.1 会等待一段时间，如无后续请求则断开，否则继续使用。目的是提高效率，减少短时间内建立连接的次数。
4. 基于TCP协议
   - HTTP协议的目标是规定客户端和服务端数据传输的格式和数据交互行为，并不负责数据传输的细节。大多数底层是基于TCP实现。现在使用的版本当中是默认持久连接的，也就是多次HTTP请求使用一个TCP连接。

##### 2.3.3 请求报文

HTTP请求包含四个部分，分别是请求行（请求方法）、请求头（消息报头）、空行和请求正文。

![图片](https://mmbiz.qpic.cn/mmbiz_png/CmnN7FKTMS6ibDEx38H5iazG9JUnxH32M0UX0CbHCibeB2lHtrECQpFovD0RbBtfETx5yDgjVSEic3uvRfvm2icBIjw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

HTTP请求报文示例：

```http
# 请求行
POST /index.html HTTP/1.1
# 请求头
Host: 127.0.0.1
User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:67.0) 
Accept: text/html,application/xhtml+xml,application/xml;
Accept-Language: zh-CN,zh;
Accept-Encoding: gzip, deflate
Referer: http://127.0.0.1/index.html
Content-Type: application/x-www-form-urlencoded
Content-Length: 29
Connection: close
Cookie: security=impossible; PHPSESSID=8vv0n11btuol45hqcm5recmfp7
Upgrade-Insecure-Requests: 1

# 请求正文
username=admin&password=admin
```

**注意:**需要注意的每一行末尾都有回车和换行，在内容实体和请求头之间有一个空行。

解读部分请求头:

- Accept：浏览器告诉服务器，它支持的数据类型;
- Accept-Charset: ISO-8859-1 【浏览器告诉服务器，它支持哪种**字符集**】
- Accept-Encoding: gzip,compress 【浏览器告诉服务器，它支持的**压缩格式**】
- Referer：【浏览器告诉服务器，客户机是从那个页面来的---**反盗链**】
- Accept-Language：浏览器告诉服务器，它的语言环境
- User-Agent：【浏览器告诉服务器，浏览器的内核是什么】
- Host：浏览器告诉服务器，它的想访问哪台主机
- Content-type：用于描述该请求来自于表单默认的提交数据的格式
- Connection：为keep-alive在很多情况下能够重用连接，减少资源消耗，缩短[响应时间](https://www.baidu.com/s?wd=响应时间&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)。所以在[HTTP1.1](https://www.baidu.com/s?wd=HTTP1.1&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)中缺省就是支持[keep-alive](现在使用的HTTP协议是HTTP/1.1版本，1997年之前采用的是HTTP1.0版本。HTTP连接在1.0版本中采用非持续连接工作方式，1.1版本采用的是持续连接工作方式，持续连接是指服务器在发送响应后仍然在一段时间内保持这条由TCP运输层协议建立起来的连接，使客户端和服务器可以继续在这条连接上传输HTTP报文,是否采用持续连接工作方式，1.0中默认是关闭的，需要在HTTP头加入"Connection:Keep-Alive"，才能启用Keep-Alive。HTTP1.1中默认启用Keep-Alive，如果加入"Connection:close"，才关闭。目前大部分浏览器都是用HTTP1.1协议，也就是说默认都会发起Keep-Alive的连接请求了，所以是否能完成一个完整的Keep-Alive连接就看服务器设置情况)的；
- Content-Length：用于描述HTTP消息实体的传输长度
- Cookie：客户端用它向服务器传送一个令牌。注意它并不是真正的安全首部，但确实隐含了安全功能；

##### 2.3.4 响应报文

HTTP响应由四部分组成，分别是响应行、响应头（消息报头）、空行和响应正文（消息主题）。

![图片](https://mmbiz.qpic.cn/mmbiz_png/CmnN7FKTMS6ibDEx38H5iazG9JUnxH32M0I93rEUR7gYw0libGv96VT4ez89taoL6hM73WSgEM1rrh0NFzia5qfmrw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

响应报文示例：

```http
# 响应行
HTTP/1.1 200 OK
# 响应头
Date: Tue, 10 Aug 2021 09:09:09 GMT
//...省略...
Content-Length: 5185
Connection: close
Content-Type: text/html;charset=gb2312

# 响应正文
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
```

解读响应头:

- Location: http://www.it315.org/index.jsp 【服务器告诉浏览器**要跳转到哪个页面**】
- Server:apache tomcat【服务器告诉浏览器，服务器的型号是什么】
- Content-Encoding: gzip 【服务器告诉浏览器**数据压缩的格式**】
- Content-Length: 80 【服务器告诉浏览器回送数据的长度】
- Content-Language: zh-cn 【服务器告诉浏览器，服务器的语言环境】
- Content-Type: text/html; charset=GB2312 【服务器告诉浏览器，**回送数据的类型**】
- Last-Modified: Tue, 11 Jul 2000 18:23:51 GMT【服务器告诉浏览器该资源上次更新时间】
- Refresh: 1;url=http://www.it315.org【服务器告诉浏览器要**定时刷新**】
- Content-Disposition: attachment; filename=aaa.zip【服务器告诉浏览器**以下载方式打开数据**】
- Transfer-Encoding: chunked 【服务器告诉浏览器数据以分块方式回送】
- Set-Cookie:SS=Q0=5Lb_nQ; path=/search【服务器告诉浏览器要**保存Cookie**】
- Expires: -1【服务器告诉浏览器**不要设置缓存**】
- Cache-Control: no-cache 【服务器告诉浏览器**不要设置缓存**】
- Pragma: no-cache 【服务器告诉浏览器**不要设置缓存**】
- Connection: close/Keep-Alive 【服务器告诉浏览器连接方式】
- Date: Tue, 11 Jul 2000 18:23:51 GMT【服务器告诉浏览器回送数据的时间】

一个完整的HTTP响应应该包含四个部分:

1. 一个状态行【用于描述**服务器对请求的处理结果。**】
2. 多个消息头【用于描述**服务器的基本信息**，以及**数据的描述**，**服务器通过这些数据的描述信息，可以通知客户端如何处理等一会儿它回送的数据**】
3. 一个空行
4. 实体内容【**服务器向客户端回送的数据**】

##### 2.3.5 请求方法和状态码

请求方法是客户端用来告知服务器其动作意图的方法，HTTP/1.1协议中共定义了8种方法来操作指定的资源。需要注意的是方法名区分大小写，都是大写字母。

1. GET:获取资源
   - 请求获取指定URI对应的资源，只读，不应该产生“副作用”
2. HEAD：获得报文首部
   - HEAD方法类似GET方法，但HEAD方法不要求返回数据。用于确认URI的有效性及资源更新时间等，可以理解为“元数据”。
3. POST:传输实体主体
   - POST方法用来传输实体的主体。
4. PUT:传输文件
   - PUT 方法用来传输文件，向指定资源位置上传其最新内容。
5. DELETE:删除资源
   - 请求服务器删除所标识的资源，与PUT方法相反。
6. TRACE:追踪路径
   - 回显服务器收到的请求，主要用于测试或诊断
7. OPTIONS:询问支持的方法
   - 获取指定资源所支持的所有HTTP请求方法。用'*'来代替资源名称，向Web服务器发送OPTIONS请求，可以测试服务器功能是否正常运作。
8. CONNECT:要求用隧道协议连接代理
   - HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接（经由非加密的HTTP代理服务器）,不支持对应方法时，返回状态码405（Method Not Allowed）；未实现方法时，返回状态码501（Not Implemented）。HTTP服务器至少应该实现GET和HEAD方法，其他方法可选。且所支持方法实现应匹配方法的语义定义。

介绍状态码:

状态码是用来告知客户端服务器端处理请求的结果。HTTP响应的第一行都是状态行（包括版本号、状态码、短语），具体内容见返回报文。

其中状态码包含以下类型：

- 1xx消息——接收的请求正在处理
- 2xx成功——请求正常处理完毕
- 3xx重定向——需要进行附加操作以完成请求
- 4xx请求错误——请求含有词法错误或者无法被执行
- 5xx服务器错误——服务器处理请求出错

常见状态码：

- 200:客户端请求成功，是最常见的状态。
- 302:重定向。
- 404:请求资源不存在，是最常见的状态。
- 400:客户端请求有语法错误，不能被服务器所理解。
- 401:请求未经授权。
- 403:服务器收到请求，但是拒绝提供服务。
- 500:服务器内部错误，是最常见的状态。
- 503:服务器当前不能处理客户端的请求，一段时间后可能恢复正常。

##### 2.3.6 URL构成

超文本传输协议（HTTP）的统一资源定位符地址构成：传送协议。层级URL标记符号(为[//],固定不变) 访问资源需要的凭证信息（可省略） 服务器。（通常为域名，或IP地址） 端口号。（以数字方式表示，若为HTTP的默认值“:80”可省略） 路径。（以“/”字符区别路径中的每一个目录名称） 查询。（GET模式的窗体参数，以“?”字符为起点，每个参数以“&”隔开，再以“=”分开参数名称与数据，通常以UTF8的URL编码，避开字符冲突的问题） 片段。以“#”字符为起点

以http://www.choupangxia.com:80/blog/index.html?id=10&page=1 为例。

其中：

- http，是协议；
- www.choupangxia.com，是服务器；
- 80，是服务器上的默认网络端口号，默认不显示；
- /blog/index.html，是路径（URI：直接定位到对应的资源）；
- ?id=10&page=1，是查询。

##### 2.3.7 HTTP与HTTPS的区别

​	HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单来说就是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。它是一个URL scheme（抽象标识符体系），句法类同http:体系，用于安全的HTTP数据传输。https:URL表明它使用了HTTP，但HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。

​	超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息。HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此HTTP协议不适合传输一些敏感信息，比如信用开号、密码等。

　　为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS。为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。



HTTPS和HTTP的区别主要为以下四点：

- https协议需要到ca申请证书，一般免费证书很少，需要缴费。
- http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
- http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
- http的连接很简单，是无状态的；https协议是有ssl+http协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。



HTTP和TCP/IP协议的关系

​	可以这样去理解:

​	“我们在传输数据时，可以只使用（传输层）TCP/IP协议，但是那样的话，如 果没有应用层，便无法识别数据内容，如果想要使传输的数据有意义，则必须使用到应用层协议，应用层协议有很多，比如HTTP、FTP、TELNET等，也 可以自己定义应用层协议。WEB使用HTTP协议作应用层协议，以封装HTTP文本信息，然后使用TCP/IP做传输层协议将它发到网络上。”

## 3.Socket编程

### 1.概述:

​	JAVA的网络编程主要设计的内容就是`Socket`编程,其中Socket也称套接字,就是两台主机之间逻辑连接的端点,网络编程实现了客户端与服务端之间的沟通(接收和发送数据),应用程序可以通过它发送或接收数据,像QQ,MSN这些网络应用都使用了Socket技术;

Socket与其他协议的区别:

```
TCP/IP协议是传输层协议,主要解决数据如何在网络中传输
HTTP是应用层协议,主要解决如何包装数据。
Socket是通信的基石,是支持TCP/IP协议的网络通信的基本操作单元,它是网络通信过程中端点的抽象表示,包含进行网络通信必须的五种信息:连接使用的协议、本地主机的IP地址、本地进程的协议端口、远程主机的IP地址、远程进程的协议端口
```

> Socket通常称作"套接字",用于描述IP地址和端口,应用程序通常通过"套接字"向网络发出请求或者应答网络请求

应用层通过传输层进行数据通信时,TCP会遇到同时为多个应用程序进程提供并发服务的问题,多个TCP连接或多个应用程序进程可能需要通过同一个TCP协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP/IP协议交互提供了套接字(Socket)接口,应用层可以和传输层通过socket接口,区分来自不同应用程序进程或网络连接的通信,实现数据传输的并发服务

**注意**:

1. Socket是JAVA实现数据通信的API,为什么呢?

```
这是因为Socket实际上是对TCP/IP协议的封装,Socket本身并不是协议,而是一个调用接口(API)
```

2. 我们用Socket可以实现TCP(或者UDP)通信,但是TCP或者UDP通信也可以不同Socket来实现,这又是为什么?

```
通过Socket我们才能使用TCP/IP协议,实际上Socket跟TCP/IP协议没有必然的关系,Socket编程接口在设计的时候,就是希望也能适应其他的网络协议,所以说:Socket的出现,只是使得程序员更方便地使用TCP/IP协议栈而已,是对TCP/IP的抽象,从而形成我们知道的一些最基本的函数接口,比如create、listen、accept、send、read和write等等
```

网络上有一段是关于Socket和TCP/IP协议关系的说法也比较好理解:

​	"TCP/IP只是一个协议栈,就像操作系统的运行机制一样,必须要具体实现,同时还要提供对外的操作接口.这个就像操作系统会提供标准的编程接口,比如win32编程接口一样,TCP/IP也要提供可供程序员做网络开发所用的接口,这就是Socket编程接口"

**理解**:实际上，传输层的TCP是基于网络层的IP协议的，而应用层的HTTP协议又是基于传输层的TCP协议的，而Socket本身不算是协议，就像上面所说，它只是提供了一个针对TCP或者UDP编程的接口。socket是对端口通信开发的工具,它要更底层一些。

在Java中使用:

​	Java平台为我们提供了一组强大的类，方便我们使用Socket进行网络程序的开发；Socket和ServerSocket类库位于java.net包中。ServerSocket是服务端套接字，Socket是客户端套接字。在连接成功时，应用程序两端都会产生一个Socket实例，操作这个实例，完成所需的会话；

### 2. 整体流程

​	Socket编程主要涉及到客户端和服务端两个方面,首先在服务端创建一个服务器套接字(ServerSocket),并把它附加到一个端口上,服务器从这个接口监听连接,端口号的范围是0~65536,但是0到1024是为特权服务保留的端口号,我们可以选择任意一个当前没有被其他进程使用的端口

​	客户端请求与服务器进行连接的时候,根据服务器的域名或者IP地址,加上端口号,打开一个套接字.当服务器接受连接后,服务器和客户端之间的通信就像输入输出流一样的进行操作

![img](https://i.loli.net/2021/08/24/4XW2M5timVRzJes.png)

### 3. 简单示例:

服务端:

```java
package com.pjmike.Socket;

import java.io.BufferedInputStream;
import java.io.DataInputStream;
import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;
import java.sql.SQLOutput;

/**
 * 服务端
 *
 * @author pjmike
 * @create 2018-08-12 17:43
 */
public class Server {
    private ServerSocket serverSocket = null;
    private Socket socket = null;
    private DataInputStream input = null;

    public Server(int port) {
        try {
            //绑定端口
            System.out.println("bind port ...");
            serverSocket = new ServerSocket(port);
            System.out.println("Server started and waiting a client ..");
            //调用accept()方法，提取连接请求
            socket = serverSocket.accept();
            //一般都是以字节传输
            input = new DataInputStream(new BufferedInputStream(socket.getInputStream()));
            String line = "";
            while (!line.equals("exit")) {
                try {
                    //readUTF()方法需要读取writeUTF()写过来的数据
                    line = input.readUTF();
                    System.out.println("recd: " + line);
                } catch (IOException o) {
                    o.printStackTrace();
                }
            }
            //关闭连接
            System.out.println("connection closed ...");
            input.close();
            socket.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    public static void main(String[] args) {
        Server server = new Server(5000);
    }
}


```

客户端:

```java
package com.pjmike.Socket;

import java.io.*;
import java.net.Socket;
import java.nio.Buffer;

/**
 * 客户端
 *
 * @author pjmike
 * @create 2018-08-12 17:52
 */
public class Client {
    private Socket socket = null;
    private DataOutputStream output = null;
    private BufferedReader input = null;

    public Client(String address, int port) {
        try {
            //建立连接
            socket = new Socket(address, port);
            System.out.println("Connected ...");
            //从控制台输入信息
            input = new BufferedReader(new InputStreamReader(System.in));
            output = new DataOutputStream(socket.getOutputStream());

        } catch (IOException e) {
            e.printStackTrace();
        }
        String line = "";
        while (!line.equals("exit")) {
            try {
                line = input.readLine();
                System.out.println("客户端输入的是: "+line);
                output.writeUTF(line);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        try {
            input.close();
            socket.close();
            output.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) {
        Client client = new Client("localhost", 5000);
    }
}


```

测试:

客户端:

```java
Connected ...
hello world
客户端输入的是: hello world
nihao
客户端输入的是: nihao
exit
客户端输入的是: exit
```

服务端:

```java
bind port ...
Server started and waiting a client ..
recd: hello world
recd: nihao
recd: exit
connection closed ...
```



再来一组:

服务器:

```java
package org.javaweb.scokettest.two;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;

public class SocketService {
  // 搭建服务器端
  public static void main(String[] args) throws IOException {
    SocketService socketService = new SocketService();
    // 1、a)创建一个服务器端Socket，即SocketService
    socketService.oneServer();
  }

  public void oneServer() {
    try {
      ServerSocket server = null;
      try {
        server = new ServerSocket(5209);
        // b)指定绑定的端口，并监听此端口。
        System.out.println("服务器启动成功");
        // 创建一个ServerSocket在端口5209监听客户请求
      } catch (Exception e) {
        System.out.println("没有启动监听：" + e);
        // 出错，打印出错信息
      }
      Socket socket = null;
      try {
        socket = server.accept();
        // 2、调用accept()方法开始监听，等待客户端的连接
        // 使用accept()阻塞等待客户请求，有客户
        // 请求到来则产生一个Socket对象，并继续执行
      } catch (Exception e) {
        System.out.println("Error." + e);
        // 出错，打印出错信息
      }
      // 3、获取输入流，并读取客户端信息
      String line;
      BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
      // 由Socket对象得到输入流，并构造相应的BufferedReader对象
      PrintWriter writer = new PrintWriter(socket.getOutputStream());
      // 由Socket对象得到输出流，并构造PrintWriter对象
      BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
      // 由系统标准输入设备构造BufferedReader对象
      System.out.println("Client:" + in.readLine());
      // 在标准输出上打印从客户端读入的字符串
      line = br.readLine();
      // 从标准输入读入一字符串
      // 4、获取输出流，响应客户端的请求
      while (!"exit".equals(line)) {
        // 如果该字符串为 "exit"，则停止循环
        writer.println(line);
        // 向客户端输出该字符串
        writer.flush();
        // 刷新输出流，使Client马上收到该字符串
        System.out.println("Server:" + line);
        // 在系统标准输出上打印读入的字符串
        System.out.println("Client:" + in.readLine());
        // 从Client读入一字符串，并打印到标准输出上
        line = br.readLine();
        // 从系统标准输入读入一字符串
      } // 继续循环

      // 5、关闭资源
      writer.close(); // 关闭Socket输出流
      in.close(); // 关闭Socket输入流
      socket.close(); // 关闭Socket
      server.close(); // 关闭ServerSocket
    } catch (Exception e) { // 出错，打印出错信息
      System.out.println("Error." + e);
    }
  }
}
```

客户端:

```java
package org.javaweb.scokettest.two;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.Socket;

public class SocketClient {
  // 搭建客户端
  public static void main(String[] args) throws IOException {
    try {
      // 1、创建客户端Socket，指定服务器地址和端口
      Socket socket = new Socket("localhost", 5209);
      System.out.println("客户端启动成功");
      // 2、获取输出流，向服务器端发送信息
      // 向本机的5209端口发出客户请求
      BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
      // 由系统标准输入设备构造BufferedReader对象
      PrintWriter write = new PrintWriter(socket.getOutputStream());
      // 由Socket对象得到输出流，并构造PrintWriter对象
      // 3、获取输入流，并读取服务器端的响应信息
      BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
      // 由Socket对象得到输入流，并构造相应的BufferedReader对象
      String readline;
      readline = br.readLine(); // 从系统标准输入读入一字符串
      while (!"exit".equals(readline)) {
        // 若从标准输入读入的字符串为 "exit"则停止循环
        write.println(readline);
        // 将从系统标准输入读入的字符串输出到Server
        write.flush();
        // 刷新输出流，使Server马上收到该字符串
        System.out.println("Client:" + readline);
        // 在系统标准输出上打印读入的字符串
        System.out.println("Server:" + in.readLine());
        // 从Server读入一字符串，并打印到标准输出上
        readline = br.readLine(); // 从系统标准输入读入一字符串
      } // 继续循环
      // 4、关闭资源
      write.close(); // 关闭Socket输出流
      in.close(); // 关闭Socket输入流
      socket.close(); // 关闭Socket
    } catch (Exception e) {
      System.out.println("can not listen to:" + e); // 出错，打印出错信息
    }
  }
}

```

结果:

![image-20210826183044306](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/imgs/image-20210826183044306.png)

![image-20210826183050989](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/imgs/image-20210826183050989.png)

**解读:**这个案例是客户端和服务端相互发消息,说要注意的地方到没有,不过下次需要demo可以来搬,注释写的很全

## 4.Cookie和Session

**Cookie的概念：**

​	我们都知道HTTP协议是无状态的，每次连接请求响应完就会自动断开，也就是说一次请求完成，不会持久化请求与相应的信息,就比如我们平时在淘宝京东中购物车、用户登录状态、还有一些个性化的设置等等场景下,如果不持久化保存信息,你么跳转新的页面那么新的页面不会保留任何关于你的信息,也就是说无法识别特定用户的信息,那么这个时候Cookie就应运而生了!

含义:Cookie是**客户端**保存用户信息的一种机制,将服务器发送到浏览器的数据保存在本地,下次向同一服务器再发起请求时被携带发送.对于Cookie可以设置过期时间

> 通常Cookie用于告知服务端两个请求是否来自同一浏览器,如保持用户的登录状态,这样就解决了HTTP无状态的问题

Cookie主要用于以下方面:

- 会话状态管理(如用户登录状态、购物车、游戏分数或其他需要记录的信息)
- 个性化设置（如用户自定义设置、主题等）
- 浏览器行为跟踪（如跟踪分析用户行为等）

缺点：Cookie是存储在客户端,这就意味着可以通过一些方式进行修改,欺骗服务器!

**Session概念:**

​	Session代表服务器和客户端一次会话的过程

​	这里我摘抄了维基百科的解释:"在计算机科学领域来说，尤其是在网络领域，会话（session）是一种持久网络协议，在用户（或用户代理）端和服务器端之间创建关联，从而起到交换数据包的作用机制，session在网络协议（例如telnet或FTP）中是非常重要的部分";

> 对照Cookie,Seesion是一种在**服务器端**保存数据的机制,用来跟踪用户状态的数据结构,可以保存在文件、数据库或者集群中。当在应用程序的Web页之间跳转时,存储在Session对象中的变量将不会丢失,而会在整个用户会话中一直存在下去,当客户端关闭会话或者Session超时失效时会话结束



自我理解:所谓的Cookie就是保存在客户端的,用于存储服务器返回给浏览器的信息,一般存储用户的个人信息和用于区分是否是同一浏览器,因为不同的浏览器对服务器保存的Cookie会略显不同,然后是Session,保存在服务器端的,也就是说服务器一旦关闭或者浏览器关闭那么session就没有了,也就代表了一次会话的过程;session一般保存用户的账号信息和其他信息,比如说当前账户会员等级之类的信息,而session和Cookie之间关联则是通过SessionID进行关联的,Cookie用于区分是否是同一浏览器而Session则保存关于当前登录账户的其他相关的信息之类的.

**Cookie是检查用户身上的”通行证“来确认用户的身份，Session就是通过检查服务器上的”客户明细表“来确认用户的身份的。Session相当于在服务器中建立了一份“客户明细表**

### 4.1 区别

​	目前大多数的应用都是用Cookie实现Session跟踪的。第一次创建Session时，服务端会通过在HTTP协议中返回给客户端，在Cookie中记录SessionID，后续请求时传递SessionID给服务。以便后续每次请求时都可以分辨你是谁；

这里我列出几个重要的区别：

1. 作用范围不同：
   - Cookie保存在客户端(浏览器),Session保存在服务器端
2. 存取方式不同：
   - Cookie只能保存ASCII,Session可以存任意数据类型,比如UserId等等
3. 有效期不同：
   - Cookie可设置为长时间保持,比如默认登录功能,Session一般有效时间比较短,客户端关闭或者Session超时都会失效
4. 存储大小不同：
   - 单个Cookie保存的数据不能超过4k,Session可存储数据远高于Cookie

### 4.2 思考

1. 禁用Cookie会怎么样?

   ```hteml
   如果客户在浏览器中禁用了Cookie,该怎么办?
   方案一:
   	拼接SessionID参数,反正Cookie一般用于存储服务器的SessionID来确保一次会话过程,那么在GET或POST请求中拼接SessionID,GET请求通常通过URL后面拼接参数来实现,POST请求可以放在body中,反正无论哪种形式都需要和服务器的session保持一致!
   
   方案二:
   	基于Token(令牌)。在APP应用中经常会用到Token来与服务器进行交互。Token本质上就是一个唯一的字符串，登录成功后由服务器返回，用于标识客户的临时授权，客户端对其进行存储，在后续请求时，通常会将其放在HTTP的Header中传递给服务器,用于服务器验证请求用户的身份;这个方式在许多spring-boot框架中都进行应用!
   ```

2. 分布式系统中Session如何处理?

   ```
   在分布式系统中,往往有多台服务器来处理同一业务。就比如用户在A服务器登录，Session位于A服务器，那么当下次请求被分配到B服务器，将会出现登录失效的问题
   方案一：
   	请求精确定位。也就是通过负载均衡器来自同一IP的用户请求始终分配到同一服务上，比如：Nginx的ip_hash策略,就可以做到
   方案二:
   	Session复制共享。目标就是确保所有的服务器的Session是一致的。像Tomcat等多数主流web服务器都采用了Session复制实现的Session共享
   方案三：
   	基于共享缓存。也就是说将Session放在一个公共地方，各个服务器使用时去取即可。比如放在Redis、Memcached等缓存中间件中。在我们使用的Spring Boot项目中，如果集成了Redis，那么Session共享可以非常方便的实现。
   ```

3. 同源策略与跨域请求

   ```
   所谓的“同源”指的是“三个相同”：协议相同、域名相同、端口相同。只有这三个完全相同，才算是同源。
   同源策略的目的：是为了保证用户信息的安全，防止恶意的网站窃取数据。
   	比如，用户访问了银行网站A，再去浏览其他网站，如果其他网站可以读取A的Cookie，隐私信息便会泄露。更可怕的是，通常Cookie还用来保存用户登录状态，会出现冒充用户行为。因此，"同源策略"是必需的，如果Cookie可以共享，互联网就毫无安全可言了。
   	
   同源策略保证了一定的安全性，但在某些场景下也带来了不便，比如常见的跨域请求问题。
   	在HTML中，<a>,<form>, <img>, <script>, <iframe>, <link> 等标签以及Ajax都可以指向一个资源地址，而所谓的跨域请求就是指：当前发起请求的域与该请求指向的资源所在的域不一样。同源即同域，三项有一项不同便会出现跨域请求。
   	浏览器会对跨域请求做出限制，因为跨域请求可能会被利用发动CSRF攻击。
   CSRF（Cross-site request forgery），即“跨站请求伪造”，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。CSRF攻击者在用户已经登录目标网站之后，诱使用户访问一个攻击页面，利用目标网站对用户的信任，以用户身份在攻击页面对目标网站发起伪造用户操作的请求，达到攻击目的。
   ```

   针对跨域请求通常有如下方法：

   1. 通过代理避开跨域请求；
   2. 通过Jsonp跨域；
   3. 通过跨域资源共享（CORS）；

