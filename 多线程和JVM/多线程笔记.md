多线程

## 1.概念

程序：程序是`指令和数据的有序集合`，其本身没有任何运行的含义，是一个静态的概念。

进程：`是执行程序的一次执行过程`，是系统资源分配的单位，是一个动态的概念。

线程：通常在一个进程中可以包含若干个线程，当然一个进程中至少有一个线程，不然没有存在的意义。`线程是CPU调度和执行的单位`。

**注意：**很多多线程是模拟出来的，真正的多线程是指多个CPU，即多核，如服务器。如果是模拟出来的多线程，即在一个CPU的情况下，在同一个时间点，CPU只能执行一个代码，因为切换的很快，所以就有同时执行的错觉；

**理解：**进程相当于是一个保护伞，咱把所有的线程都放在里面，哪怕这个进程什么都不干那么这里面也有一个主线程main在运行；

程序（静态）-》跑起来变成进程-》进程里包含若干个（线程）

> 真正执行的是线程！进程只不过是系统资源分配的单位！

### 1.1 核心

1. 线程就是独立运行的执行路径
2. 在程序运行时，即使没有自己创建线程，后台也会有多个线程，如主线程，gc线程；
3. main()称之为主线程，为系统的入口，用于执行整个程序；
4. 在一个进程中，如果开辟了很多个线程，`线程的运行由调度器（CPU）安排调度`，调度器是与操作系统紧密相关的，先后顺序是不能人为的干预的。
5. 对同一份资源操作时，会存在`资源抢夺`的问题，需要加入并发控制；
6. 线程会带来`额外的开销`，如CPU调度时间，并发控制开销；
7. 每个线程在自己的`工作内存交互`，内存控制不当会造成数据不一致

## 2. 线程创建

 ### 2.1 Thread

步骤：

1. 创建一个类继承`Thread类`
2. 重写`run()`方法，编写线程执行体
3. 创建线程对象，调用`start（）`方法启动线程

代码：

![image-20220503150128798](https://gitee.com/miawei/pic-go-img/raw/master/imgs/202205031501845.png)

这里在main主线程内创建一个线程对象，然后开启线程，此时要记住`线程不一定会立即执行，CPU会安排调度`；

执行结果：

```
我在学习多线程...0
我在学习多线程...1
我在学习多线程...2
我在学习多线程...3
我在学习多线程...4
我在学习多线程...5
我在学习多线程...6
我在吃饭...0
我在吃饭...1
我在吃饭...2
我在吃饭...3
我在学习多线程...7
我在吃饭...4
我在学习多线程...8
我在吃饭...5
我在学习多线程...9
我在吃饭...6
我在吃饭...7
我在吃饭...8
我在吃饭...9
```

---

但是这里必须是调用`start`方法进行开启线程，如果是调用普通方法`run`方法还有是这样并发执行吗？

过程省略...

结果：

```
我在吃饭...0
我在吃饭...1
我在吃饭...2
我在吃饭...3
我在吃饭...4
我在吃饭...5
我在吃饭...6
我在吃饭...7
我在吃饭...8
我在吃饭...9
我在学习多线程...0
我在学习多线程...1
我在学习多线程...2
我在学习多线程...3
我在学习多线程...4
我在学习多线程...5
我在学习多线程...6
我在学习多线程...7
我在学习多线程...8
我在学习多线程...9
```

区别：

![image-20220503150319259](https://gitee.com/miawei/pic-go-img/raw/master/imgs/202205031506255.png)

总结：

- 普通方法：它调用普通方法那么也是在主线程的范围内执行，也就是说从根本上只有一条路让你走；
- 开启线程：它调用start方法就创建新的线程，相当于说新的开辟了一条道路，现在两条路都可以走；

因为是CPU调度安排，所以调用普通方法只在主线程内，一条线程内无论怎么执行都是按照调用顺序执行。但由于又新开线程那么也就意味着现在有两条线程，那么`这两条线程都在进行CPU资源抢夺，CPU同一时间只允许一个线程执行，所以就在相互交替执行`；

### 2.2 Runnable

步骤:

1. 实现`Runnable接口`
2. 重写`run()`方法
3. 创建线程对象`Thread`然后将实现类作为构造参数传入
4. 调用线程对象的`start()`方法开启线程

代码：

![image-20220503155817511](https://gitee.com/miawei/pic-go-img/raw/master/imgs/202205031558564.png)

结果：

```java
我在学习多线程...0
我在学习多线程...1
我在吃饭...0
我在学习多线程...2
我在学习多线程...3
我在学习多线程...4
我在吃饭...1
我在学习多线程...5
我在学习多线程...6
我在学习多线程...7
我在学习多线程...8
我在吃饭...2
我在吃饭...3
我在学习多线程...9
我在吃饭...4
我在吃饭...5
我在吃饭...6
我在吃饭...7
我在吃饭...8
我在吃饭...9
```

**推荐使用Runnable对象，因为Java单继承的局限性**

区别：

1. 继承Thread类
   - 子类继承Thread类具备多线程的能力
   - 启动线程：`子类对象.start()`
   - 不建议使用：避免OOP单继承局限性
2. 实现Runnable接口
   - 实现接口Runnable具有多线程能力
   - 启动线程：`传入目标对象+Thread对象.start()`
   - 推荐使用：避免单继承局限性，灵活方便，方便同一个对象被多个线程使用

```java
//一份资源 
CreateRunnable runnable = new CreateRunnable();

//多个代理
new Thread(runnable).start();
new Thread(runnable).start();
new Thread(runnable).start();

一个对象被三个Thread对象进行开启线程，也就是说这里创建多个线程并开启，三个线程同时跑的同一个对象
```

### 2.3 Callable

步骤：

1. 实现`Callable接口`，需要返回值类型
2. 重写`call`方法，需要抛出异常
3. 创建目标对象
4. 创建执行服务：ExecutorService ser=Executors.newFixedThreadPool(1); 
5. 提交执行：Future<Boolean> result1=ser.submit(t1)
6. 获取结果：boolean r1=result1.get()
7. 关闭服务：ser.shutdownNow()

代码：

```java
@Slf4j
public class CreateCallable implements Callable<Boolean> {
    private   String url;
    private  String name;

    public CreateCallable(String url, String name) {
        this.url = url;
        this.name = name;
    }

    @Override
    public Boolean call() throws Exception {
        WebDownloader downloader = new WebDownloader();
        downloader.downloader(url, name);
        System.out.println("下载成功，文件名为：" + name);
        return true;
    }

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        CreateCallable callable1 = new CreateCallable("https://img14.360buyimg.com/n1/jfs/t1/201421/29/17516/252062/6198dd37E2c455f28/2ce2dd9fd95f6f38.jpg", "1.jpg");
        CreateCallable callable2 = new CreateCallable("https://img14.360buyimg.com/n1/jfs/t1/201421/29/17516/252062/6198dd37E2c455f28/2ce2dd9fd95f6f38.jpg", "2.jpg");
        CreateCallable callable3 = new CreateCallable("https://img14.360buyimg.com/n1/jfs/t1/201421/29/17516/252062/6198dd37E2c455f28/2ce2dd9fd95f6f38.jpg", "3.jpg");

        //创建执行任务-创建一个固定的线程池-3个
        ExecutorService ser = Executors.newFixedThreadPool(3);
        //提交执行-3个线程
        Future<Boolean> result1 = ser.submit(callable1);
        Future<Boolean> result2 = ser.submit(callable2);
        Future<Boolean> result3 = ser.submit(callable3);
        //获取到结果
        Boolean r1 = result1.get();
        Boolean r2 = result2.get();
        Boolean r3 = result3.get();
        //关闭结果
        ser.shutdownNow();

        System.out.println(r1);
        System.out.println(r2);
        System.out.println(r3);

    }

}

@Slf4j
class WebDownloader{
    //开始下载
    public void downloader(String url,String name) {
        try {
            FileUtils.copyURLToFile(new URL(url),new File(name));
        } catch (IOException e) {
            e.printStackTrace();
            log.error("IO异常，下载失败:{}", e.getMessage());
        }
    }
}
```

结果：

```java
下载成功，文件名为：3.jpg
下载成功，文件名为：2.jpg
下载成功，文件名为：1.jpg
true
true
true
```

核心思想：实现接口`Callable`接口，然后覆写`call`方法，然后创建一个线程池，将创建好的线程对象扔进去执行，然后得到对应的返回结果，最后关闭线程池；

## 3. 静态代理模式

代理：可以理解为生活中的中间商，可以帮助代理你做一些事情；

就好比是结婚：新人和婚庆公司，婚庆公司就是代理，它可以帮你完成一些比如婚礼现场的布置；

代码：

```java
public class StaticProxy {
    public static void main(String[] args) {
        WeddingCompany company = new WeddingCompany(new MiaoWei());
        company.happyMarry();
    }

}

interface Marry{
    /**
     * 幸福结婚
     */
    void happyMarry();
}

//真实角色，你去结婚
class MiaoWei implements Marry{
    public MiaoWei() {}

    @Override
    public void happyMarry() {
        System.out.println("缪威要结婚啦，快去撒糖！！！");
    }
}

//代理角色，帮助你结婚
class WeddingCompany implements Marry {
    //具体代理的-->真实目标角色
    private  Marry target;

    public WeddingCompany(Marry target) {
        this.target = target;
    }

    @Override
    public void happyMarry() {
        before();
        //目标对象去结婚
        this.target.happyMarry();
        after();
    }

    private void after() {
        System.out.println("结婚之后，开始收钱。。。");
    }

    private void before() {
        System.out.println("结婚之前，开始布置。。。");
    }
}
```

输出：

```
结婚之前，开始布置。。。
缪威要结婚啦，快去撒糖！！！
结婚之后，开始收钱。。。
```

总结：

1. 真实对象和代理对象都要`实现同一接口`
2. 代理对象`要代理真实对象`（解释：将目标对象作为参数传递进去，方法中的target参数）

好处：

1. 代理对象可以做很多真实对象做不了的事情
2. 真实对象就可以专注做自己的事情

其他：

```java
//最开始是这样去调，那么自己就要做很多的事情
MiaoWei miaoWei = new MiaoWei();
miaoWei.happyMarry();

//将目标对象作为参数传递进去进行代理，那么这里代理对象可以做更多的事情
WeddingCompany company = new WeddingCompany(miaoWei);
company.happyMarry();
```

静态代理模式在多线程中的应用：

```java
//new Thread(() -> System.out.println("我是目标对象")).start();  下面那个等同于这个，可以用lambda表达式进行替换
new Thread(new Runnable() {
    @Override
    public void run() {
        System.out.println("我是目标对象");
    }
}).start();
new WeddingCompany(new MiaoWei()).happyMarry();
```

从中我们发现：

两者的代理思想都是一致的，`new Thread()`和`new WeddingCompany()`都是代理对象，而我们点击源码可以发现Thread类是实现了接口Runnable的，也就是说跟我们现在的例子都是实现了同一接口，也就是说我们传递一个目标对象（Runnable）的接口实现类作为目标对象，那么这个Thread作为代理就可以做更多的事情，而Runnable真实对象就可以只负责于某件事情！

> 这就是线程的底层实现原理！

## 4. 线程状态

五大状态：

![image-20220504142338725](https://gitee.com/miawei/pic-go-img/raw/master/imgs/202205041423814.png)

**创建状态**：在new的时候创建

**就绪状态**：在调用start方法的时候此时就是一个启动状态了；

等待CPU调度器进行获取....

**运行状态**：当获取到CPU资源并处于运行的状态--运行状态

**阻塞状态**：使用sleep等让线程进行等待的状态那么此时就会进行阻塞并重新回到就绪状态

**死亡状态**：在没有任何外部干预的情况下线程执行完毕那么此时线程就会进入死亡

图示：

![image-20220504154807609](https://gitee.com/miawei/pic-go-img/raw/master/imgs/202205041548684.png)

### 4.1 线程状态观测

**Thread.State**

```java
- new
    - 尚未启动的线程处于此状态
- Runnable
    - 在Java虚拟机中执行的线程处于此状态
- blocked
    - 被阻塞等待监视器锁定的线程处于此状态
- waiting
    - 正在等待另一个
```





## 5.线程方法（Thread）

这是Thread类的方法参数说明：

|              方法              |                    说明                    |
| :----------------------------: | :----------------------------------------: |
|  setPriority(int newPriority)  |              更改线程的优先级              |
| static void sleep(long millis) |  在指定的毫秒数内让当前正在执行的线程休眠  |
|          void join()           |               等待该线程终止               |
|      static void yield()       | 暂停当前正在执行的线程对象，并执行其他线程 |
|        void interrupt()        |          中断线程（别用这种方式）          |
|       boolean isAlive()        |          测试线程是否处于活动状态          |

### 5.1 线程停止

- 不推荐使用JDK提供的stop()、destory()方法。【已废弃】
- 推荐线程自己停止下来
- 建议使用一个标志位进行终止变量，当flag=false，则终止线程运行。

代码:

```java
public class StopThread implements Runnable {
    private  boolean flag = true;

    public static void main(String[] args) {
        StopThread thread = new StopThread();
        //执行线程
        new Thread(thread).start();

        for (int i = 0; i <200; i++) {
            System.out.println("main主线程在跑");
            if (i == 100) {
                thread.stop();
                System.out.println("线程停止了");
            }
        }
    }
	//利用标志位来结束无限循环并跳出死循环并结束
    public void stop(){
        flag = false;
    }

    @Override
    public void run() {
        //根据这个标识来进行决定是否继续往下执行
        while (flag) {
            System.out.println("正在执行线程...");
        }
    }
}
```

总结：

1. 建议线程正常停止-->利用次数，不建议死循环（CPU卡死）
2. 建议使用标志位-->设置一个标志位自己结束
3. 不要使用stop/destory等过时或者JDK官方不推荐使用的方法（因为BUG多）

### 5.2 线程休眠

- sleep（时间）指定当前线程阻塞的毫秒数（一千毫秒=1秒）
- sleep存在异常InterruptedException（需要抛出）
- sleep时间达到后线程就会开始进行就绪状态
- sleep可以模拟网络延时，倒计时等等
- `每一个对象都有一个锁，sleep不会释放锁`

### 5.3 线程礼让

- 礼让线程，让当前正在执行的线程暂停，但不阻塞；
- 将线程从运行状态转为就绪状态
- 让cpu重新调度，礼让不一定会成功！看CPU心情

理解：意思就是说让当前线程暂停重新回到就绪状态想让另外一个线程走，但在就绪状态上想让谁走这个得看CPU的心情，也就是说有可能A线程在运行状态然后礼让回到就绪状态上，此时A线程和B线程都处于就绪状态，此时CPU又让A线程跑，那么这个礼让就是失败的！

代码:

```java
public class TestYield {

    public static void main(String[] args) {
        MyYield yield = new MyYield();
        new Thread(yield,"a").start();
        new Thread(yield,"b").start();
    }
}
class MyYield implements Runnable{
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName() + "线程开始执行");
        //让当前线程进入就绪状态-礼让
        Thread.yield();
        System.out.println(Thread.currentThread().getName() + "线程结束执行");
    }
}
```

结果：

```
a线程开始执行
b线程开始执行
//两者都进入了就绪状态，CPU看心情调谁
a线程结束执行
b线程结束执行
```

理解：这个礼让的过程：首先A和B都在排队等待CPU调度，然后A被第一个抽中，然后走到`Thread.yield`此时就回到了就绪状态，此时B也遇到礼让此时他也回到了就绪状态，此时CPU随机选择了A继续往下走，B在后面跟着走；

### 5.4 线程插队

- 待此线程执行完成后再执行其他线程，而其他线程处于阻塞的状态！
- 可以理解为插队！

代码：

```java
public class TestJoin implements Runnable{
    @Override
    public void run() {
        for (int i = 0; i < 1000; i++) {
            System.out.println(Thread.currentThread().getName() + "-VIP客户插队"+i);
        }
    }

    public static void main(String[] args) throws InterruptedException {
        TestJoin join = new TestJoin();
        Thread thread = new Thread(join, "用户A");
        thread.start();

        for (int i = 0; i < 500; i++) {
            if (i == 100) {
                thread.join();
            }
            System.out.println("主线程在排队"+i);
        }

    }
}
```

结果：主线程和A线程刚开始交替执行，然后执行到`thread.join()`这时就会强行让A线程执行完毕，而main线程就会陷入阻塞状态，带到A线程完毕后才开始执行main线程；