# 1. 一对多

> 在日常业务中我们常常会遇到以下的返回JSON结构

```java
{
  "code": 200,
  "data": [
    {
      "holiday": "建军节,xx节",
      "lunar": "初三",
      "schedule": [
        {
          "endTime": "18:00",
          "hour": 8,
          "id": 2,
          "name": "白班",
          "startTime": "09:00",
        }
      ],
      "weekIndex": 1,
      "workday": "2021-08-01"
    }
  ],
  "msg": "操作成功"
}
```

这时按照以前的用法来拼接以上的结构,因为没办法一次性从SQL中返回。所以这时就可以使用mybatis的一对多的模式

demo：



```java
User类:
@Data
public class User {
    private int id;
    private String username;
    private String mobile;
    private List<Post> posts;
}
Post类:
@Data
public class Post {
    private int id;
    private String title;
    private String content;
}
//其中User类的posts就代表多个Post对象
```

我们希望返回这种结构:

```java
{ 
"msg": "操作成功",

  "code": 200,

  "data": [

   {

     "id": 1,

      "username": "yiibai",

      "mobile": "100",

      "posts": [

        {

          "id": 1,

          "title": "MyBatis关联数据查询",

          "content": "在实际项目中，经常使用关联表的查询，比如：多对一，一对多等。这些查询是如何处理的呢，这一讲就讲这个问题。我们首先创建一个 post 表，并初始化数据."

       },

        {

          "id": 2,

          "title": "MyBatis开发环境搭建",

          "content": "为了方便学习，这里直接建立java 工程，但一般都是开发 Web 项目。"

        }

      ]
    }

  ]

}
```



 mybatis.xml:

```mysql
<select id="selectDemo" resultMap="resultMapUser">
    select u.id,u.mobile,u.username as 'user1Name',p.* from `user` u join post p on u.id=p.userid
</select>

<resultMap id="resultMapUser" type="com.abitware.project.module.domain.User">
    <result property="id" column="id"/>
    <result property="mobile" column="mobile"/>
    <result property="username" column="user1Name"/>
    <collection property="posts" ofType="com.abitware.project.module.domain.Post">
        <id property="id" column="post_id" javaType="int" jdbcType="VARCHAR"/>
        <result property="title" column="title" javaType="String" jdbcType="VARCHAR"/>
        <result property="content" column="content" javaType="String" jdbcType="VARCHAR"/>
    </collection>
</resultMap>
```

1.仔细看这段:

理解:首先会正常写一段SQL，但是要注意这段SQL语句要包含你要返给前端的字段，必须要包含不能漏否则就会为null，并且你还可以对这个字段进行函数处理意思可以写函数但是很关键的地方就是要写别名。如：

```java
<select id="getScheduleMonthList" resultMap="getScheduleMonthList">
      date_format(s.date,'%Y-%m') as `month` ,
	  max(s.id) as 'maxid'
</select>
    
<resultMap id="getScheduleMonthList" type="com.abitware.project.module.domain.vo.HrScheduleMonthVo">
       <result property="month" column="month"/>
       <result property="id" column="maxid"/>
</resultMap>
 //对字段进行函数处理后起个别名然后返给前端,但是resultMap的column要拿得到 不然拿不到也是返回null
```

总之select语句里要包含你要返回给前端的字段,但是真正并不是在这里就会返回,而是要传给resultMap,要提供给resultMao进行set字段。

然后开始讲resltMap里面的参数：

1. id：用于连接resultMap跟select之间的桥梁。

2. type:表明要返回的主类,只有一个并不会有多个

3. 外层的result: 主要用于对主类的字段进行set,property对应实体的字段名、映射值,column从数据库查询出的字段名或者别名
4. coolection 用于返回多个对象 ,我们用List来接收,就体现了一对多的样子,也可以理解为这是一个list
5. property获取要List来接收的字段名(这个字段名是type类里的List字段) ofType映射到哪个实体类型上
6. collection里面的result也是用于set字段,批量返回。

总结：

其实也没得啥，还是要写一个总的SQL，然后就用resultMap来区分哪个是“1"哪个是"多"，并且如果还不止一个List那么也不并慌再加一个coolection 标签就是了

# 2. 一对一

顾名思义就是单对单的意思,就是这种结构:

```java
User类:
@Data
public class User {
    private int id;
    private String username;
    private String mobile;
    private Post post;
}

Post类:
@Data
public class Post {
    private int id;
    private String title;
    private String content;
}
//user类中的post字段就代表了一个Post对象
```



总的用法跟上面类似,不过不再是Coolection标签而是association标签,就好比一个代表多一个代表单个

上代码:

```java
//还是正常的SQL语句 
<select id="select" resultMap="resultMapUser">
        select u.id,u.mobile,u.username as 'user1Name',p.* from `user` u join post p on u.id=p.userid
    </select>
    
    <resultMap id="resultMapUser" type="com.abitware.project.module.domain.User">
        <result property="id" column="id"/>
        <result property="mobile" column="mobile"/>
        <result property="username" column="user1Name"/>
        <association property="post" javaType="com.abitware.project.module.domain.Post">
            <id property="id" column="post_id" jdbcType="VARCHAR" javaType="int"/>
            <result property="content" column="content" javaType="String" jdbcType="VARCHAR"/>
        </association>
    </resultMap>
```

最终返回的结构是:

```java
{
    "msg": "操作成功",
    "code": 200,
    "data": [
        {
            "id": 1,
            "username": "yiibai",
            "mobile": "100",
            "post": {
                "id": 2,
                "user": null,
                "title": null,
                "content": "为了方便学习，这里直接建立java 工程，但一般都是开发 Web 项目。"
            },
        }
    ]
}
//因为我省略了user跟title的set,所以为null,只是为了测试
```



# 3. 栗子

## 舆情项目

首先是Bean结构:

```java
@Data
@ApiModel("舆情添加返回vo")
@Accessors(chain = true)
public class HrStatVo {
    @ApiModelProperty("用户id")
    private Long userId;
    @ApiModelProperty("用户名称")
    private String userName;
    @ApiModelProperty("部门id")
    private Long deptId;
    @ApiModelProperty("部门名称")
    private String deptName;
    @ApiModelProperty("请假时长")
    private Double leaveHour;
    @ApiModelProperty("剩余公休")
    private Double remainHolidayHour;
    @ApiModelProperty("出勤次数")
    private Integer attendanceTimes;
    @ApiModelProperty("工作时长(小时")
    private Double workHour;

    @ApiModelProperty("排班明细")
    private List<HrStatDetailVo> detail;
}

@Data
@ApiModel("舆情统计详情返回vo")
@Accessors(chain = true)
public class HrStatDetailVo {
    private String date;
    private List<HrStatScheduleDetailVo> schedule;
}

@Data
@ApiModel("舆情统计详情返回vo")
@Accessors(chain = true)
public class HrStatScheduleDetailVo {
    private Long id;
    private String startTime;
    private String endTime;
    private Integer hour;
    private String name;
    private Integer status;
}
```

> 这是一个一层嵌一层的,这也是放在mybatis里可以实现一对多可是如果纯SQL的话也是不行的，按照我以前的逻辑来处理那么就会先查询一个然后for循环再去查询，虽然这样也可以但代码看起来不仅冗余且繁琐，并且一旦数据量大的话就会造成时间运行效率低下

然后是mybatis.xml

```xml
<resultMap id="detail" type="com.abitware.project.module.domain.vo.out.HrStatDetailVo">
    //
        <result property="date" column="date"/>
        <collection property="schedule" ofType="com.abitware.project.module.domain.vo.out.HrStatScheduleDetailVo">
            <id property="id" column="id"/>
            <result property="name" column="name"/>
            <result property="startTime" column="start_time"/>
            <result property="endTime" column="end_time"/>
            <result property="hour" column="hour"/>
            <result property="status" column="status"/>
        </collection>
    </resultMap>
    <resultMap id="selectUserAttendence" type="com.abitware.project.module.domain.vo.out.HrStatVo">
        <result property="userId" column="user_id"/>
        <result property="userName" column="user_name"/>
        <result property="deptId" column="dept_id"/>
        <result property="deptName" column="dept_name"/>
        <result property="attendanceTimes" column="attendenceTimes"/>
        <result property="workHour" column="workHour"/>
        <collection property="detail" resultMap="detail"/>
    </resultMap>
    <select id="selectUserAttendence" resultMap="selectUserAttendence">
        select
            t.*,
            a.workday as `date`,
            a.schedule_id as id,
            a.begin_time as start_time,
            a.end_time,
            a.work_hour as `hour`,
            if(a.status = 1, 1, 0) as status ,
            ss.name
        from
        (   SELECT user_id, user_name, dept_id, dept_name, ifnull( max( `index` ), 0 ) attendenceTimes, sum( actual_work_hour ) workHour
            FROM `hr_attendence` WHERE ym = #{month} and (status = 1 or status = 2 or status = 5) group by user_id, user_name, dept_id, dept_name ) t
            join hr_attendence a on a.user_id = t.user_id and (status = 1 or status = 2 or status = 5)
            left join hr_schedule s on s.id = a.schedule_id
            left join hr_setting_schedule ss on s.setting_schedule_id = ss.id
        where
            ym = #{month}
            <if test="userId != null">
                and t.user_id = #{userId}
            </if>
            <if test="userId == null">
                and t.user_id in
                <foreach collection="managedPerson" open="(" close=")" separator="," item="item">
                    #{item}
                </foreach>
            </if>
        order by t.user_id , a.workday , id
    </select>
```

解析:

```xml
<resultMap id="detail" type="com.abitware.project.module.domain.vo.out.HrStatDetailVo">
        <result property="date" column="date"/>
        <collection property="schedule" ofType="com.abitware.project.module.domain.vo.out.HrStatScheduleDetailVo">
            <id property="id" column="id"/>
          	//这里如法炮制,也是一样的
            <result property="status" column="status"/>
        </collection>
    </resultMap>
    <resultMap id="selectUserAttendence" type="com.abitware.project.module.domain.vo.out.HrStatVo">
        //这里result进行字段的set,column数据库的字段名 property是指JavaBean的字段名
        <result property="userId" column="user_id"/>
       //collection  表示有多条数据统一管理, resultMap映射多个
        <collection property="detail" resultMap="detail"/>
    </resultMap>
    <select id="selectUserAttendence" resultMap="selectUserAttendence">
        //这里的select查询出的语句必须要把返回数据结构所有字段都必须
       //展示出来,这里不会查询并不会直接返回,而是映射到另一个resultMap数据结构中去,
      理解:全部取出来,虽然可能会存在多个的情况那么也要查询出来,
    </select>
```

