# Spring Boot笔记

## 1. 简介:

**引入**:Spring诞生时Java企业版的**轻量级代替品**。无需开发重量级的EJB，Spring为企业级Java开发提供了一种相对简单的方法：通过依赖注入和面向切面编程，用简单的对象实现了EJB的功能！\

注意:Spring是为了解决企业级应用开发的复杂性而创建的,简化开发!

Spring是如何简化开发的:

```
为了降低Java开发的复杂性,Spring采用了以下4种关键策略:
1.基于POJO的轻量级和最小侵入性编程,所有东西都是bean
2.通过IOC,依赖注入(DI)和面向接口实现松耦合
3.基于切面(Aop)和惯例进行声明式编程;
4.通过切面和模板减少样式代码,比如:RedisTemplate,xxxTemplate
```

**注意**：虽然Spring的组件代码是轻量级，但它的配置却是重量级的！

> 理解：这句话的意思就是说Spring的诞生就是解决了对象之间的依赖关系，让对象之间进行解耦合，这些都是Spring容器进行负责处理,虽然最终我们可以让对象之间解耦合,但是我们却要针对每一个对象去进行配置,项目越来越大这配置文件中的对象就越来越繁杂冗余!

来看Spring的发展史:

第一阶段:xml配置:

```
在Spring 1.x时代,使用Spring开发满眼都是xml配置的Bean,随着项目的扩大,我们需要把xml配置文件放到不同的配置文件里,在那个时候就需要在频繁的在开发的类和配置文件之间进行切换
```

第二阶段:注解配置:

```
在Spring 2.x时代,随着JDK1.5带来的注解支持,Spring提供了声明Bean的注解(比如:@Controller、@Service),大大减少了配置量,主要使用的方式是应用的基本配置(如配合数据库配置,扫描包路径)用xml配置文件,业务配置用注解!
```

第三阶段:java配置:

```
Spring 3.x引入了基于Java的配置能力,这是一种类似安全的可重构配置方式,可以代替XML,我们目前刚好处于这个时代,Spring 4.x和Spring Boot都推荐使用Java配置。
```

**结论**：

1. 所有这些配置都代表了开发时的损耗。因为在思考**Spring特性配置**和**解决业务问题**之间需要进行思维切换，所以写配置挤占了写应用程序逻辑的时间！
2. 除此之外，项目的**依赖管理**也是件吃力不讨好的事情。决定项目里用哪些库就已经够让人头疼的了，你还要知道这些库的哪个**版本**和其他库不会有**冲突**，这难题实在太棘手，并且依赖管理也是一种损耗，添加依赖不是写应用程序代码，一旦选错了依赖的版本，随之而来的不兼容问题会是生产力杀手

> Spring Boot的产生就是简化Spring而诞生的!Spring Boot(微框架)=SpringMvc(控制器)+Spring(项目管理)

**概述**:Spring Boot简化了基于Spring的应用开发,只需要"run"就能创建一个独立的、生产级别的Spring应用。Spring Boot为Spring平台及第三方库提供了开箱即用的设置（提供默认设置),这样我们就可以简单的开始使用,多数的Spring Boot应用只需要很少的Spring配置。

**Spring Boot 主要优点:**

1. 为所有Spring开发者提供更快的入门
2. **开箱即用**,提供各种默认配置来简化项目配置
3. 内嵌式容器简化Web项目
4. 没有冗余代码生成和XML配置的要求

```
理解:
1.spring Boot就是一个javaweb的开发框架,和springMVC类似,好处就在于简化开发:约定大于配置
2.springBoot基于Spring开发,但是要区别于该Spring Boot不是用来替代Spring的解决方案,而是跟Spring框架紧密集合用于提升Spring开发者体验的工具!
3.SpringBoot其实并不是什么新的框架,只是整合了所有的框架,只是默认配置了很多框架的使用方式;
```



## 2.简单运行

**使用IDEA创建项目:**

1. 创建一个新项目
2. 选择spring initalizr ， 可以看到默认就是去官网的快速构建工具那里实现
3. 填写项目信息
4. 选择初始化的组件（初学勾选 Web 即可）
5. 填写项目路径
6. 等待项目构建成功

**创建完毕后会自动生成以下文件:**

1. 程序的主启动类
2. 一个application.properties 配置文件
3. 一个 测试类
4. 一个 pom.xml

**编写接口:**

1. 在主程序的同级目录下,新建一个Controller包,**注意一定要在同级目录下,否则识别不到**
2. 在包中新建一个HelloController类

```java
@RestController
public class HelloController {
 
    @RequestMapping("/")
    public String sayHello(){
        return "Hello Spring Boot!";
    }
}
```

3. 编写完毕然后运行主程序,然后在控制台就可以看见tomcat访问的端口号:

```
2021-09-17 20:37:10.218  INFO 16840 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8888 (http) with context path ''
```

4. 页面访问:

![image-20210917203813895](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210917203813895.png)

**踩坑记录:**
1.我把新建的Controller的包放在其他路径下就是不放在主程序的同级目录下,那么就会发生404,如:


![四、创建第一个springboot项目_第一个_06](https://gitee.com/miawei/pic-go-img/raw/master/imgs/2019021916031092.png)

解决办法是:

```java
@ComponentScan(basePackages = {"com.example.*"})//放在主程序的类上,表示覆写自定义包下的类,具体什么原理在自动装配原理那节详细讲
```

------

这种就是通过在IDEA工具进行启动访问,还有一种就是通过打包的方式运行

![image-20210917204039104](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210917204039104.png)

打成jar包后,我们在所在的文件夹下运行该jar包,就可以在任何地方进行访问了:

![image-20210917204143883](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210917204143883.png)

cmd运行:

![image-20210917204320615](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210917204320615.png)

> 这里之所以可以直接运行,是因为springBoot是内嵌式容器也就是tomcat!

总结:

1. spring Boot以约定大于配置的核心思想
2. 程序=数据结构+算法
3. spring Boot就是一个spring mvc框架
4. spring Boot的核心东西:自动装配!

还有在resource目录下的文件如果被spring boot识别成功就会有一个小图标,如:

<img src="https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210917205036312.png" alt="image-20210917205036312" style="zoom:200%;" />

还有做下笔记我们启动spring boot有启动图案,可以改的:

> 在resource下新建banner.txt文件,然后https://www.bootschool.net/ascii 这个网站生成,然后拷贝到文件中即可!

这里写一下微服务的概念:

**微服务就是把业务拆分成模块**

单体应用架构:把一个应用中的所有应用服务封装到一个应用;

微服务:把每个服务独立出来,把独立出来的功能元素的动态组合,

## 3.自动装配原理

我们在创建编写spring boot的时候,就在思考是怎么运行起来的呢?新建一个spring boot项目又不像SSM那样进行整合和创建过多的依赖配置,我们新建后可以编写http接口访问?我们先来看pom.xml依赖开始:

### 3.1 pom.xml

```xml-dtd
 	<parent>
        <!--父依赖-->
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.5.4</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
```

可以发现这里是一个父依赖,主要管理项目的资源过滤及插件;

点进去,发现还有一个父依赖:

```xml-dtd
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-dependencies</artifactId>
    <version>2.5.4</version>
</parent>
```

这里才是真正管理spring Boot应用里面所有依赖版本的地方,springBoot的版本控制中心!

> 总结:以后我们在导入依赖的时候不需要写对应的版本,因为当前pom依赖继承了父依赖,而在父依赖里已经定义了这些版本在父工程中!当然父工程中没有改依赖那么就需要手动配置版本了!

而再来看看启动器:spring-boot-starter:

```xml-dtd
<dependency>
   <groupId>org.springframework.boot</groupId>
   <artifactId>spring-boot-starter-web</artifactId> <!--启动器,说白了就是spring boot的启动场景,它就会帮我们导入web环境所有的依赖-->
            <!--这可以不要版本,因为是继承父依赖的-->
</dependency>
```

其中:

1. **spring-boot-starter-xxx**:就是spring-boot的场景启动器
2. **spring-boot-starter-web**:帮我们导入了web模块正常运行所依赖的组件;

**说明**:SpringBoot将所有的功能场景抽取出来,做成一个个的starter(启动器),只需要在项目中引入这些starter即可,所有相关的依赖都会导入进来,我们要用什么功能就导入什么样的场景启动器即可!

**理解**:在构建项目的时候,我们会勾选上web这个模块,然后在项目初始化的时候spring-boot就会将比如dispatcherServlet,servlet,都会导入到项目依赖中

> spring Boot会将所有的功能场景,都变成一个个的启动器,我们要使用什么功能就只需要找到对应的启动器就可以了`starter`

### 3.2 主启动类

```java
@SpringBootApplication  //来标注一个主程序类->说明这是一个Spring Boot应用
public class SpringbootProjectApplication {
    public static void main(String[] args) {
        //将springboot应用启动,这里以为是启动了一个方法没想到是启动了一个服务!
        SpringApplication.run(SpringbootProjectApplication.class, args);
    }
}
```

我们接下来就来分析一下这个主程序都干了些东西!

1. #### @SpringBootApplication

   作用:标注在某个类上说明这个类是springBoot的主配置类,Spring Boot就应该运行这个类的main方法来启动SpringBoot应用;

   进入这个注解可以发现上面还有很多注解:

   ```java
   @SpringBootConfiguration
   @EnableAutoConfiguration
   @ComponentScan(
       excludeFilters = {@Filter(
       type = FilterType.CUSTOM,
       classes = {TypeExcludeFilter.class}
   ), @Filter(
       type = FilterType.CUSTOM,
       classes = {AutoConfigurationExcludeFilter.class}
   )}
   )
   public @interface SpringBootApplication {
       // ......
   }
   ```

2. #### @ComponentScan

   这个注解在spring很重要,它对应XML配置中的元素,也就是扫描我们默认的包下的注解比如@Controller然后加载到我们IOC容器中!

   作用:自动扫描并加载符合条件的组件或者bean,将这个bean定义加载到IOC容器中,默认扫描当前类下的package

3. #### @SpringBootConfiguration

   作用:SpringBoot的配置类,标注在某个类上,表示这是一个SpringBoot的配置类,它表示就是支持JavaConfig形式的IOC容器的配置类

   ```java
   这个javaConfig形式的配置类就是跟我们平常使用的xml配置文件也是一样的,只不过两者配置方式不一样!给你们来个经典案例:
   javaconfig:
   @Configuration
   public class MockConfiguration{
       @Bean
       public MockService mockService(){
           return new MockServiceImpl(dependencyService());
       }
   }
   xml:
   <bean id="mockService" class="..MockServiceImpl">
      <propery name ="dependencyService" ref="dependencyService" />
   </bean>
   ```

   我们在点进去再看看:

   ```java
   //点击这个注解进入下面那个@Component
   @Configuration  //说百了就是支持JavaConfig的方式进行配置
   public @interface SpringBootConfiguration {...}
   
   @Component
   public @interface Configuration {...}
   ```

   这里的@Configuration说明这是一个配置类,配置类就是对应的Spring的xml配置文件;而再点进去得到的@Component这就说明该启动类本身也就是Spring中的一个组件而已,负责启动应用!

   ------

   我们再回到@SpringBootApplication注解中再看:

4. #### @EnableAutoConfiguration

   **开启自动配置功能**

   以前我们需要自己配置的东西,而现在SpringBoot可以自动帮我们配置;

   而@EbableAutoConfiguration告诉springBoot开启自动配置功能,这样自动配置才能生效;

   点击注解继续查看:

5. #### @AutoConfigurationPackage

   **自动配置包**

   ```java
   @Import(AutoConfigurationPackages.Registrar.class)
   public @interface AutoConfigurationPackage {...}
   ```

6. #### @Import

   这是Spring底层注解,给容器中导入一个组件;

   Registrar.class作用:将主启动类的所在包下面所有子包里面的所有组件扫描到Spring容器中;(所以为什么说要跟主程序同一个包才可以)

   我们在点击进去查看:

   ```java
   @Override
   public void registerBeanDefinitions(AnnotationMetadata metadata,
           BeanDefinitionRegistry registry) {
       register(registry, new PackageImport(metadata).getPackageName());
   }
   ```

   表示在默认的情况下就是将:主配置类(@SpringBootApplication)的所在包及其子包里面的部件扫描到Spring容器中!

   思考:这里也是扫描包加载到spring容器那么我们之前使用@ComponentScan的功能不就是重复了吗?

   > 比如说,我们使用Spring Data JPA,可能会在实体类上写@Entity注解,而这个注解是由@AutoConfigurationPackage扫描并加载,而我们平时开发用的@Controller/@Service...这些注解是由CompoentScan来扫描并加载的; 简单理解就是:两者扫描的对象都是不一致的!

   ------

   回到上一步:

7. #### @Import(AutoConfigurationImportSelector.class)

   **给容器导入组件**

   AutoConfigurationImportSelector:自动配置导入选择器,那么它会导入哪些组件的选择器呢?我们再点击这个源码查看:

   - 首先看下这里:

     ```java
     @Override
     //所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中
     	public String[] selectImports(AnnotationMetadata annotationMetadata) {
     		if (!isEnabled(annotationMetadata)) {
     			return NO_IMPORTS;
     		}
     		AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(annotationMetadata);
     		return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());
     	}
     ```
   
     表示加载元数据,表示把pom.xml文件中的数据加载进来,加载完后就进入下一步:
   
   - 获得自动配置实体:
   
     ```java
     protected AutoConfigurationEntry getAutoConfigurationEntry(AnnotationMetadata annotationMetadata) {
     		if (!isEnabled(annotationMetadata)) {
     			return EMPTY_ENTRY;
     		}
     		AnnotationAttributes attributes = getAttributes(annotationMetadata);
     		List<String> configurations = getCandidateConfigurations(annotationMetadata, attributes);
     		configurations = removeDuplicates(configurations);
     		Set<String> exclusions = getExclusions(annotationMetadata, attributes);
     		checkExcludedClasses(configurations, exclusions);
     		configurations.removeAll(exclusions);
     		configurations = getConfigurationClassFilter().filter(configurations);
     		fireAutoConfigurationImportEvents(configurations, exclusions);
     		return new AutoConfigurationEntry(configurations, exclusions);
     	}
     ```
   
   - 然后点击其中的getCandidateConfigurations来获取候选的配置:
   
     ```java
     //获得所有的配置
     protected List<String> getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) {
         	//这里getSpringFactoriesLoaderFactoryClass()返回的是我们最开始看的启动自动导入配置文件的注解类,是:@EnableAutoConfiguration
     		List<String> configurations = SpringFactoriesLoader.SpringFactoriesLoader(getSpringFactoriesLoaderFactoryClass(),
     		//getBeanClassLoader这是一个加载器,相当于当前类的                                                                                  
     				getBeanClassLoader());
         	//这里提个彩蛋:这里断言可以如果发现不再就会给出提示说 META-INF/spring.factories这个文件找不到.那么这个有什么用呢?
     		Assert.notEmpty(configurations, "No auto configuration classes found in META-INF/spring.factories. If you "
     				+ "are using a custom packaging, make sure that file is correct.");
     		return configurations;
     }
     //然后获取了哪些配置呢?就是这里
     //这里是getSpringFactoriesLoaderFactoryClass返回的是注解类:  意思是加载类,加载启动类2下的所有资源被导入
     protected Class<?> getSpringFactoriesLoaderFactoryClass() {
     		return EnableAutoConfiguration.class;
     }
     ```
   
   - 我们在点击`SpringFactoriesLoader`的静态方法`SpringFactoriesLoader`的源码查看:
   
     ```java
     //这是加载spring.factories这个自动配置文件的,而这里factorType表示加载了一个类这个类就是我们标注了@SpringBootApplication的这个类
     public static List<String> loadFactoryNames(Class<?> factoryType, @Nullable ClassLoader classLoader) {
     		ClassLoader classLoaderToUse = classLoader;
     		if (classLoaderToUse == null) {
     			classLoaderToUse = SpringFactoriesLoader.class.getClassLoader();
     		}
         //获取类的名字
     		String factoryTypeName = factoryType.getName();
         //这里它又调用loadSpringFactories方法,获取默认的包名,为空则返回空的集合
     		return loadSpringFactories(classLoaderToUse).getOrDefault(factoryTypeName, Collections.emptyList());
     	}
     ```
   
   - 我们继续查看loadSpringFactories源码里看:
   
     ```java
     private static Map<String, List<String>> loadSpringFactories(ClassLoader classLoader) {
         //这里先去缓存里去加载
     		Map<String, List<String>> result = cache.get(classLoader);
     		if (result != null) {
     			return result;
     		}
     
     		result = new HashMap<>();
     		try {
                 //去获取一个资源 "META-INF/spring.factories",这里通过class类加载器去获取资源,将里面所有自动配置类加载进来
     			Enumeration<URL> urls = classLoader.getResources(FACTORIES_RESOURCE_LOCATION);
                 //将获取的资源进行遍历,封装成为一个Properties
                 //判断有没有更多的元素,也即是从资源配置下找存在是否可以自动配置的东西,遍历完成之后封装为Properties供我们使用!
     			while (urls.hasMoreElements()) {
                     //如果有的话就放在url里面
     				URL url = urls.nextElement();
     				UrlResource resource = new UrlResource(url);
                     //把url这些资源加载到properties配置类里面,供我们使用
     				Properties properties = PropertiesLoaderUtils.loadProperties(resource);
     				for (Map.Entry<?, ?> entry : properties.entrySet()) {
     					String factoryTypeName = ((String) entry.getKey()).trim();
     					String[] factoryImplementationNames =
     							StringUtils.commaDelimitedListToStringArray((String) entry.getValue());
     					for (String factoryImplementationName : factoryImplementationNames) {
     						result.computeIfAbsent(factoryTypeName, key -> new ArrayList<>())
     								.add(factoryImplementationName.trim());
     					}
     				}
     			}
     
     			// Replace all lists with unmodifiable lists containing unique elements
     			result.replaceAll((factoryType, implementations) -> implementations.stream().distinct()
     					.collect(Collectors.collectingAndThen(Collectors.toList(), Collections::unmodifiableList)));
                 //放入到缓存里面
     			cache.put(classLoader, result);
     		}
     		catch (IOException ex) {
     			throw new IllegalArgumentException("Unable to load factories from location [" +
     					FACTORIES_RESOURCE_LOCATION + "]", ex);
     		}
     		return result;
     	}
     ```
   
   - 这里可以发现有个关键词:`FACTORIES_RESOURCE_LOCATION`这是常量对应的是:"META-INF/spring.factories",全局搜索:	


8. ## spring.factories(自动配置的核心文件)

   ![image-20210918114949624](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210918114949624.png)
   
   根据源头我们找到了spring.factories然后将其打开,可以发现有很多的配置的文件,**这就是自动配置的根源之所在**!
   
   我们往下翻找到`Auto Configure(自动配置)`下的`WebMvcAutoConfiguration`这个类,打开看看:
   
9. #### WebMvcAutoConfiguration

   <img src="https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210918150043307.png" alt="image-20210918150043307" style="zoom: 80%;" />

   ​		

   @Configuration:表示这是Java的一个配置类

   @ConditionalOnClass:这是spring注解表示通过一些条件来判断是否注入
   
   我们继续在当前类里往下翻:
   
   ![image-20210918210321016](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210918210321016.png)
   
   这个不难发现就是springMVC中的视图解析器,这个都已经自动配置了,还有一些过滤器啊什么的都是已经自动配置好了 	
   
   其中可以发现:这些一个个的都是Java Config配置类,而且都注入了一些Bean!
   
   **结论**:自动配置真正实现是从classPath中搜寻所有的`META-INF/spring.factories`配置文件,并将其中对应的`org.springframework.boot.autoconfigure.`包下的配置项,通过反射实例化为对应标注了`@Configuration`的JavaConfig形式的IOC容器配置类,然后将这些都汇总成为一个实例并加载到IOC容器中。
   
   
   
   -> 但是思考一个问题:既然是加载spring.factories里的所有的自动配置文件,那么为什么只生效了部分呢?
   
   比如我们随便点击一个没导入包的类进入:
   
   ![image-20210918230144508](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210918230144508.png)

可以发现`@ConditionalOnClass`这个就是一个判断条件,判断条件成立才会加载这个类!比如说这里必须这个jar包存在那么这个类才会生效!

### 3.3 画图解析

![自动装配原理分析](https://gitee.com/miawei/pic-go-img/raw/master/imgs/%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90.png)



 ### 3.3 总结

结论:springBoot所有的自动配置都是在启动的时候扫描并加载:`spring.factories`所有的自动配置类都在这里面,但是不一定生效,要判断条件是否成立,只要导入了对应的start,就有对应的启动器了,有了启动器,我们自动装配就会生效,然后配置成功!

步骤:

1. SpringBoot在启动的时候会从类路径下的`META-INF/spring.factories`中获取指定的值(就是一个个的URL然后遍历封装到Properties);
2. 将这些值作为自动配置类的导入容器(这个容器就是在具体的配置类中的`@Configuration`和方法上的`@Bean`),自动配置类就生效,帮我们进行自动配置工作
3. 整个J2EE的整体解决方案和自动配置都在(xxxAutoConfiguration),就是给容器中导入这个场景需要的所有组件,并配置好这些组件
4. 解决方案和自动配置都在`spring-boot-autoconfigure-2.5.4.jar`这个包下
5. 它会把所有需要导入的组件,以类名(配置文件中都是全限定类名)的形式返回,这些组件就会被添加到容器
6. 容器中也会存在非常多的xxxAutoConfiguration的文件,就是这些类给容器中导入了这个场景需要的所有组件(`@Bean`),并自动配置@Configuration
7. 有了自动配置类,免去了我们手动编写配置注入功能组件等的工作!

## 4.启动类

我们来看一下启动类是如何运行的:

```java
public static void main(String[] args) {
        TimeInterval timer = DateUtil.timer();
        //将springboot应用启动
        SpringApplication.run(SpringbootProjectApplication.class, args);
        //启动日志
        Console.log("〓〓〓系统启动成功,耗时{}〓〓〓，当前时间是{}", timer.intervalPretty(), DateUtil.now());
    }
```

最初的时候以为就是运行个main方法,没想到这里就是直接运行了一个服务!

SpringApplication调用一个静态方法run,该方法里有个参数,一个是当前类,一个是当前命令行参数

SpringApplication这个类主要做了以下四件事情:

1. 推断应用的类型是普通的java项目还是web项目
2. 查找并加载所有可用初始化器 ， 设置到initializers属性中
3. 找出所有的应用程序监听器，设置到listeners属性中
4. 推断并设置main方法的定义类，找到运行的主类

查看构造器:

```java

public SpringApplication(ResourceLoader resourceLoader, Class... primarySources) {
    // ......
    this.webApplicationType = WebApplicationType.deduceFromClasspath();
    this.setInitializers(this.getSpringFactoriesInstances();
    this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class));
    this.mainApplicationClass = this.deduceMainApplicationClass();
}
```

run方法流程分析:

![img](https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7L1vFQMnaRIJSmeZ58T2eZicjafiawQLp9u8wc4ic1Mjy6OyfibzfjVofeL5pnS1NSFKVjlIg6neI9ySg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

   跟着源码一起看效果会更好哦!

## 5.配置文件

在springBoot使用一个全局的配置文件,我们在创建springBoot的时候就会初始化一个文件`application.properties`这个文件,不过这个文件官方并不推荐,推荐的是另一种文件`yaml`格式的!

- application.properties
  - 语法结构:`key=value`
- application.yaml
  - 语法结构: `key:空格value`

**注意**:配置文件的名称是固定的!

因为springBoot底层就已经以这个名称写好了,说白了就是大家一起约定一下写一样的名字;

**解释**:

在pom.xml中的`spring-boot-starter-parent`中已经标注了:

```xml-dtd
<resource>
        <directory>${basedir}/src/main/resources</directory>
        <filtering>true</filtering>
        <includes>
          <include>**/application*.yml</include>
          <include>**/application*.yaml</include>
          <include>**/application*.properties</include>
        </includes>
</resource>
```

表示获取resource下的配置文件,并且这里还存在优先级问题,也就是如果同时存在的话!

**配置文件的作用**:修改SpringBoot自动配置的默认值,因为SpringBoot在底层都给我们自动配置好了

### 5.1 yaml概述

**概述**:YAML是 "YAML Ain't a Markup Language" （YAML不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是："Yet Another Markup Language"（仍是一种标记语言）

> 这种语言以数据为中心,而不是以标记语言为重点!

以前的配置文件,大多数都是使用xml来配置;比如一个简单的端口配置,我们来对比下yaml和xml:

传统的xml配置:

```xml
<servr>
	<port>8081</port>
</servr>
```

yaml配置:

```yaml
server:
	port: 8081
```

### 5.2 语法

1. ### 字面量:普通的值[数字,布尔值,字符串]

   ```yaml
   k: v
   ```

    字面量直接写在后面就可以,字符串默认不用加上双引号或者单引号

   **注意**:

   1. ""双引号,不会转义字符串里面的特殊字符,特殊字符会作为本身想表示的意思
      - 比如:name: "你好 \n 吗",然后输出:你好 换行 吗
   2. ''单引号,会转义特殊字符,特殊字符最终会变成和普通字符一样输出
      - 比如:name: '你好 \n 吗',然后输出:你好 \n 吗

2. ### 对象、Map(键值对)

   ```yaml
   # 对象、Map格式
   k：
   	v1: xx
   	v2: xx
   ```

   我们一般使用换行的形式来表达键值对的属性和值的关系,但是要注意缩进关系!比如:

   ```yaml
   student:
   	name: Miao
   	age: 3
   ```

   行内写法:

   ```yaml
   student: {name: Miao,age: 3}
   ```

3. ### 数组(List、set)

   用 - 值表示数组中的一个元素,比如:

   ```yaml
   zoo:
   	- cat
   	- dog
   	- pig
   ```

   行内写法:

   ```yaml
   zoo: [cat,dog,pig]
   ```

**注意事项**:

在yaml语法中对于空格是有着比较严格的要求!

1. 空格不能省略;
2. 以缩进来控制层级关系,只要左边对齐的一列数据都是同一个层级的
3. 属性和值的大小写都是十分敏感的;

### 5.3 注入

以前我们使用注入的时候使用的是Spring的@Value注解,它可以指定参数在Spring容器加载通过反射进行实例设值!但是这样耦合度很高,毕竟直接写在字段上,比如:

```java
public class Dog {
    @Value("缪威")
    private String name;
    @Value("21")
    private Integer age;
}
```

而yaml文件更强大的地方在于，他可以给我们的实体类直接注入匹配值！

1. 新建一个Dog:

   ```java
   @Component
   @Data
   public class Dog {
        private String name;
       private Integer age;
   }
   ```

2. 新建一个Pseron:

   ```java
   @Component
   @Data
   @ConfigurationProperties(prefix = "person")
   public class Person {
       private String name;
       private Integer age;
       private Boolean happy;
       private Date birth;
       private Map<String, Object> maps;
       private List<String> lists;
       private Dog dog;
   }
   ```

3. 在yaml配置文件进行配置

   ```yaml
   # 使用yaml配置注入的方式进行注入
   person:
     name: MiaoWei
     age: 21
     happy: false
     birth: 2000/08/14
     # map 键值对形式
     maps: {k1: v1,k2: v2}
     #list集合数组的形式
     lists:
       - code
       - 父母
       - music
     # 对象的形式
     dog:
       name: 缪威
       age: 21
   ```

4. 测试

   ```java
   @SpringBootTest
   class SpringbootProjectApplicationTests {
       @Autowired
       private Person person;
       @Test
       void contextLoads() {
           System.out.println(person);
       }
   }
   ```

5. 结果:

   ![image-20210920150833380](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210920150833380.png)

   可以发现是自动注入进去了!

**注意**:

1. *@ConfigurationProperties*作用:

   - 将配置文件中配置的每一个属性的值,映射到这个组件中;告诉springBoot将本类中的所有属性和配置文件进行绑定,参数`prefix="person"`:则是将配置文件中的person下面的属性一一对应

2. 导入以上注解就会报出一个红色的提示:

   ![image-20210920151225909](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210920151225909.png)

   解决办法:

   ```xml-dtd
   <!-- 导入配置文件处理器，配置文件进行绑定就会有提示，需要重启 -->
   <dependency>
     <groupId>org.springframework.boot</groupId>
     <artifactId>spring-boot-configuration-processor</artifactId>
     <optional>true</optional>
   </dependency>
   ```

配置文件还可以使用站位符生成随机数:

```yaml
name: miaowei${random.uuid} # 随机uuid
```



------

以上加载yaml的配置文件,如果要加载properties文件,也是可以的:

1. 在`application.properties`里写注入值:

   ```properties
   name=缪威
   ```

2. 然后在我们的代码中指定加载`application.properties`文件

   ```java
   @Component
   @Data
   @PropertySource(value = "classpath:application.properties")
   public class Dog {
       @Value("${name}")  //这里使用SQEL表达式
       private String name;
       private Integer age;
   }
   ```

3. 测试:

   ```java
   @SpringBootTest
   class SpringbootProjectApplicationTests {
       @Autowired
       private Dog dog;
       @Test
       void contextLoads() {
           System.out.println(dog);
       }
   }
   ```

4. 运行:

   ![image-20210920153010506](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210920153010506.png)

发现是可以注入成功的



**小结**:

@Value这个使用起来并不友好！我们需要为每个属性单独注解赋值，比较麻烦；我们来看个功能对比图:

![image-20210920153428362](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210920153428362.png)

1. @ConfigurationProperties只需要写一次即可,@Value则需要每个字段都添加
2. 松散绑定:比如我yml中写的`last-name`,这个和`lastName`是一样的,`-` 后面跟着的字母默认是大写的,这就是松散绑定!测试是可以正常注入的!
3. JSR303数据校验:这个就是我们可以在字段是增加一层过滤器验证,可以保证数据的合法性
4. 复杂类型封装:yml中可以封装对象,使用value就不支持

**结论**:

- 我们使用yml和配置properties都可以获取到值,强烈推荐yml

- 我们在业务中需要获取到配置文件中的某个值,就可以使用一下@Value
- 如果说我们专门编写一个JavaBean来和配置文件一一对应那么就直接选择@configurationProperties!

代码:

1. 使用@Value来获取指定配置文件中的某个值(这个配置文件可以是yaml也可以是properties)

   ```java
   @Component
   @Data
   @PropertySource(value = "classpath:application.yaml")
   public class Person {
       @Value("${student.name}")
       private String name;
   }
   //针对单个字段进行获取配置文件中的值
   ```

2. 使用@configurationProperties则是将指定节点中的节点一一对应映射

   ```java
   @Component
   @Data
   @ConfigurationProperties(prefix = "student")
   public class Person {
       private String lastName;
       private Integer age;
       private Boolean happy;
       private Date birth;
       private Map<String, Object> maps;
       private List<String> lists;
       private Dog dog;
   }
   //只要字段跟配置文件中的字段保持一致那么就会映射获取
   ```

   

### 5.4 加载位置

外部加载配置文件的方式十分多,我们选择最常用的即可:

![图片](https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IPEXZtUAUBhnSZvUmrPzbDUoiazZ6ehegLG4doZK0uSJHribIqwVKiaNibSaYZSgjZf4kGzhLdGrkzzw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

这是springBoot的官方文档里描述配置文件的加载位置,扫描这些位置的application.properties或者application.yml文件作为springBoot的默认配置文件

**注意**:如果同时存在`application.properties`和`application.yml`那么前者的优先级高!

解释一下图中位置的描述:

```
优先级1:项目路径下的config文件夹配置文件
优先级2:项目路径下的配置文件
优先级3:资源路径下的config文件夹配置文件
优先级4:资源路径下配置文件
```

> 优先级从高到低,高优先级的配置会覆盖低优先级的配置;

SpringBoot会从这四个位置全部加载主配置文件;**进行互补配置**

测试:我在低配置的yml里添加参数,然后运行测试看是否能注入到:

这是这四个文件:

![image-20210920172738414](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210920172738414.png)

然后我在优先级4哪里添加以下配置:

```yaml
student:
  name: 缪威
```

然后在pojo进行获取注入:

```java
@Data
@Component
@ConfigurationProperties(prefix = "student")
public class Person {
    private String name;
}
```

测试运行:

```java
@SpringBootTest
class SpringbootProjectApplicationTests {
    @Autowired
    private Person person;
    @Test
    void contextLoads() {
        System.out.println(person);
    }

}
```

结果:

![image-20210920173007446](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210920173007446.png)

------

当然我们还可以指定外部配置文件,也就是说不需要以上的默认位置去加载:

> 我们还可以通过spring.config.location来改变默认的配置文件位置

项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；这种情况，一般是后期运维做的多，相同配置，外部指定的配置文件优先级最高

```java
java -jar spring-boot-config.jar --spring.config.location=F:/application.properties
```

### 5.5 配置文件自动配置原理

我们在写yml配置文件的过程中在思考配置文件到底能写什么?怎么写?

在SpringBoot官方的文档中记录了大量的配置,但是我们无法全部记住

![img](https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IPEXZtUAUBhnSZvUmrPzbD7ibqw837BhN1F7lHdAMhMmYNCYF2tSdvUGv0y3X48tzetuuYc8tUMLg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

接下来开始分析自动配置的原理

1. 我们还是从主启动类的注解进入找到`spring-factories`这个文件,因为自动装配的文件springBoot都存放在这里

   思考?配置文件到底能写什么跟spring-factories这之间的联系!

2. 我们在spring-factories里找到`HttpEncodingAutoConfiguration(Http编码自动配置)`来进行解释自动配置原理:

```java
//表示这是一个配置类,会被Spring接管、配置->javaConfig形式,跟@Bean搭配使用,跟直接在容器中写<bean>标签是一样的道理
@Configuration(proxyBeanMethods = false)
//将配置文件中的对应的值和ServerProperties绑定在一起修改默认值,并把ServerProperties加入到IOC容器中;
@EnableConfigurationProperties(ServerProperties.class)
//spring的底层注解:根据不同的条件,来判断当前配置或者类是否生效
@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET)  //如果这个类型不是web应用就直接无效
@ConditionalOnClass(CharacterEncodingFilter.class) //判断当前项目是否存在这个类,SpringMVC中进行乱码解决的过滤器
@ConditionalOnProperty(prefix = "server.servlet.encoding", value = "enabled", matchIfMissing = true) //判断配置文件中是否存在某个配置,不存在就走默认的
public class HttpEncodingAutoConfiguration {
	//他已经和SpringBoot的配置文件映射了
	private final Encoding properties;
	//只有一个有参构造器的情况下，参数的值就会从容器中拿
	public HttpEncodingAutoConfiguration(ServerProperties properties) {
		this.properties = properties.getServlet().getEncoding();
	}

	@Bean
	@ConditionalOnMissingBean
    //给容器中添加一个组件，这个组件的某些值需要从properties中获取
	//字符编码的过滤,然后添加到我们组件中
	public CharacterEncodingFilter characterEncodingFilter() {
		CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter();
		filter.setEncoding(this.properties.getCharset().name());
		filter.setForceRequestEncoding(this.properties.shouldForce(Encoding.Type.REQUEST));
		filter.setForceResponseEncoding(this.properties.shouldForce(Encoding.Type.RESPONSE));
		return filter;
	}

	@Bean
	//下面这些都是些国际化
	public LocaleCharsetMappingsCustomizer localeCharsetMappingsCustomizer() {
		return new LocaleCharsetMappingsCustomizer(this.properties);
	}
	...

}
```

3. 我们点击`ServerProperties.class`这个类里面:

   ![image-20210920194007641](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210920194007641.png)

   可以发现这个`ServlerProperties`绑定了配置文件下的server的所有东西,所以我们说这个配置文件能写什么东西是要去看这个对应的类中有哪些东西!

> 在我们配置文件中能够配置的东西,都存在一个固有的规律:就是以xxxProperties形式的配置类,而这个文件一般由xxxAutoConfiguration装载的,而大量的配置类里面默认装配了一些默认的属性,然后这个自动装配里面一般会去绑定配置了一个文件,就是通过properties的方式加载一些自定义的文件,而这个Properties文件又跟我们配置文件绑定	

**结论**:由xxxAutoConfiguration自动配置类自动帮我们装配东西,而自动装配就会去加载xxxProperties文件里的默认值,而xxxProperties又跟我们配置文件进行绑定,所以我们就可以使用自定义的配置了! 

一句话:根据当前不同的条件判断,决定了这个配置类是否生效!

- 一旦这个配置类生效那么就会给容器中添加各种组件
- 这些组件的属性是从对应的properties类中获取的,而properties这个类中的每一个属性又是和配置文件进行绑定的;
- 所有在配置文件中能配置的属性都是在xxxProperties类中封装的;
- 配置文件能配置什么就可以参照某个功能对应的这个属性类

> 这就是自动装配的原理!

再来记录一波:

1. SpringBoot启动就会加载大量的自动配置类
2. 我们看我们需要的功能有没有在SpringBoot默认写好的自动配置类当中;
3. 我们再来看这个自动配置类中到底配置了哪些组件;(只要我们要用的组件存在其中我们就不需要再手动配置了)
4. 给容器中自动配置类添加组件的时候,会从properties类中获取某些属性,我们只需要在配置文件中指定这些属性的值即可;

```java
xxxAutoConfiguration:自动配置类,给容器中添加组件
xxxProperties:封装配置文件中相关属性,通过springBoot配置文件进行动态修改属性值
```

配置原理理解:

SpringBoot通过主启动类在启动的时候首先会扫描当前主程序下同级类中的注解并添加到容器中,然后开启自动配置容器去找到`META/INF/spring.factories`并加载大量的配置类,这些配置类提供我们大量场景需要的组件,而配置类中判断条件看是否满足生效,而生效就会去往容器中添加组件,而组件的默认值就会去对应加载的properties文件中去获取,而properties又跟springBoot配置文件进行绑定,而我们就可以手动的动态修改默认值,然后将其配置类添加到IOC容器!

### 5.6 @Conditional

在研究自动配置类的时候可以看出基本上每个自动配置类上都会有一个注解就是@Conditional,它表示在一定条件下才能生效

作用:必须是@Conditional指定的条件成立,才给容器中添加组件,配置配里面的所有内容才生效

![image-20210920204453032](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210920204453032.png)

> 那么多的自动配置类,必须在一定的条件下才能生效,也就是说我们加载了这么多的配置类,但不是所有的都生效了

但是这里又有一个思考问题:我们如何知道自己哪些配置类生效了呢?

我们可以通过启用`debug=true`属性;来让控制台打印自动配置报告,这样我们就知道哪些自动配置类生效;

```yaml
# 开启springBoot的调试类
debug: true
```

打印台参数解释:

1. Positive matches:自动配置类启用的:正匹配
2. Negative matches:,没有启动,没有匹配成功的自动配置类:负匹配
3. Unconditional classes:没有条件的类



## 6.JSR303数据校验

这个就是使用`@Validated`来校验数据!如果数据异常则会统一抛出异常,方便异常中心统一处理;

比如:

```java
@Component //注册bean
@ConfigurationProperties(prefix = "person")
@Validated  //数据校验
public class Person {

    @Email(message="邮箱格式错误") //name必须是邮箱格式
    private String age;
}
```

运行结果:

![image-20210920162655104](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210920162655104.png)

常见的一些参数:

Bean Validation 中内置的 constraint:

![img](https://gitee.com/miawei/pic-go-img/raw/master/imgs/3145530-8ae74d19e6c65b4c)

 Hibernate Validator 附加的 constraint:

![img](https://gitee.com/miawei/pic-go-img/raw/master/imgs/3145530-10035c6af8e90a7c)



​	踩坑记录:

​	如果在字段添加校验注解比如@Email爆红不存在,那么就去检查一下是否存在对应的包:

![image-20210920162927402](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210920162927402.png)

​	如果没有则引入一下依赖就可以了:

```xml
<dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
</dependency>
```



## 7.多环境切换

我们在开发过程中会遇到有多个环境,比如由开发环境,测试环境,每个环境的数据库等配置都是不一样的,那么我们如何进行不同的切换呢?

> 我们在在主配置文件编写的时候,文件名可以是application-{profile}.properties/yml,用来指定多个环境版本

**注**:profile是Spring对不同环境提供不同配置功能的支持,可以通过激活不同的环境版本,实现快速切换环境;

例如:

```yaml
application-test.properties # 代表测试环境配置
application-dev.properties # 代表开发环境配置
```

虽然有多个环境版本,但是springBoot不会直接启动这些配置文件,它默认使用`application.properties`主配置文件;而我们能做的就是通过配置进行选择激活:

```properties
# 比如在配置文件中指定使用dev环境,我们可以通过设置不同的端口号进行测试;
# 我们启动springBoot就可以看到已经切换到dev下的配置了
spring.profiles.active=dev
```

------

以上的都是用properties文件,每次切换版本啊环境都需要切换不同的配置文件,而yaml可以不需要创建多个配置文件:

```yaml
server:
  port: 8081
#选择要激活那个环境块
spring:
  profiles:
    active: prod
# 通过---三个中华线进行分割多个环境
---
server:
  port: 8083
spring:
  profiles: dev #配置环境的名称


---

server:
  port: 8084
spring:
  profiles: prod  #配置环境的名称
```

**注意**:如果yml和properties同时都配置了端口,并且没有激活其他环境,那么默认是会使用properties配置文件的!
