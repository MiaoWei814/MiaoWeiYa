# Spring Boot笔记

## 1. 简介:

**引入**:Spring诞生时Java企业版的**轻量级代替品**。无需开发重量级的EJB，Spring为企业级Java开发提供了一种相对简单的方法：通过依赖注入和面向切面编程，用简单的对象实现了EJB的功能！

**注意**：虽然Spring的组件代码是轻量级，但它的配置却是重量级的！

> 理解：这句话的意思就是说Spring的诞生就是解决了对象之间的依赖关系，让对象之间进行解耦合，这些都是Spring容器进行负责处理,虽然最终我们可以让对象之间解耦合,但是我们却要针对每一个对象去进行配置,项目越来越大这配置文件中的对象就越来越繁杂冗余!

来看Spring的发展史:

第一阶段:xml配置:

```
在Spring 1.x时代,使用Spring开发满眼都是xml配置的Bean,随着项目的扩大,我们需要把xml配置文件放到不同的配置文件里,在那个时候就需要在频繁的在开发的类和配置文件之间进行切换
```

第二阶段:注解配置:

```
在Spring 2.x时代,随着JDK1.5带来的注解支持,Spring提供了声明Bean的注解(比如:@Controller、@Service),大大减少了配置量,主要使用的方式是应用的基本配置(如配合数据库配置,扫描包路径)用xml配置文件,业务配置用注解!
```

第三阶段:java配置:

```
Spring 3.x引入了基于Java的配置能力,这是一种类似安全的可重构配置方式,可以代替XML,我们目前刚好处于这个时代,Spring 4.x和Spring Boot都推荐使用Java配置。
```

**结论**：

1. 所有这些配置都代表了开发时的损耗。因为在思考**Spring特性配置**和**解决业务问题**之间需要进行思维切换，所以写配置挤占了写应用程序逻辑的时间！
2. 除此之外，项目的**依赖管理**也是件吃力不讨好的事情。决定项目里用哪些库就已经够让人头疼的了，你还要知道这些库的哪个**版本**和其他库不会有**冲突**，这难题实在太棘手，并且依赖管理也是一种损耗，添加依赖不是写应用程序代码，一旦选错了依赖的版本，随之而来的不兼容问题会是生产力杀手

> Spring Boot的产生就是简化Spring而诞生的!Spring Boot(微框架)=SpringMvc(控制器)+Spring(项目管理)

**概述**:Spring Boot简化了基于Spring的应用开发,只需要"run"就能创建一个独立的、生产级别的Spring应用。Spring Boot为Spring平台及第三方库提供了开箱即用的设置（提供默认设置),这样我们就可以简单的开始使用,多数的Spring Boot应用只需要很少的Spring配置。

**Spring Boot 主要特点:**

1. 创建独立的Spring应用程序
2. 嵌入的Tomcat,无需部署War文件
   - Spring Boot项目默认的打包方式是Jar,而且自身嵌入Tomcat可以直接部署运行,而不需要额外的服务器
3. 简化Maven配置
   - 之前的Spring(SpringMVC)项目需要的Maven依赖很多,需要自己手动的自己引入而且可能会导致依赖的冲突
4. 自动配置的Spring,不需要管理大量的XML配置

## 2.入门准备

项目目录结构:

![image-20200730134147627](https://gitee.com/miawei/pic-go-img/raw/master/imgs/aHR0cHM6Ly9naXRlZS5jb20vbGVpeXVqaWEvY3Nkbi9yYXcvbWFzdGVyL2ltYWdlLTIwMjAwNzMwMTM0MTQ3NjI3LnBuZw)

**解读**:

1. 要求有**一个全局的入口类**,注意存放的位置,会影响类似于扫描包
2. 要求有**一个名为application.yml或者application.properties的核心配置文件**



快速搭建Spring Boot我使用的是IDEA+Maven;

![image-20210916161613803](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210916161613803.png)

点击next然后选择:

![image-20210916162131144](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210916162131144.png)



就可以了,然后在新的项目中可以查看Pom.xml中依赖:

```xml-dtd
 <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.5.4</version>
        <relativePath/> <!-- lookup parent from repository -->
</parent>
...
<dependency>
	<groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
```

就只有这两个依赖,但是你会栽依赖包里:

![image-20210916162543131](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210916162543131.png)

我们会惊奇地发现，我们的工程自动添加了好多好多jar 包，而这些jar 包正式我们做开发时需要导入的jar 包。因为这些jar 包被我们刚才加入的spring-boot-starter-web 所引用了，所以添加spring-boot-starter-web后会自动把依赖传递过来。

### 2.1 入口类

