# SpringBoot笔记

## 1.Thymeleaf

### 1.1 概述

**引入**:前端交给我们的页面是HTML页面;按照我们之前学习web开发的时候,我们需要把他们转成jsp页面,jsp好处就是当我们查出一些数据转发到JSP页面以后,我们可以用jsp轻松实现数据的显示,以及交互等等,

jsp支持非常强大的功能,不仅能写Java代码还能写HTML页面,按照之前的开发可以用JSP,但是现在学习SpringBoot这种情况,这个项目是以jar的方式,不是war,然后我们用的还是嵌入式的Tomcat,所以:**他现在默认是不支持jsp的**,

那么直接用纯静态页面那么会给开发造成非常大的麻烦,而SpringBoot自然有解决办法:推荐使用Thymeleaf模板引擎;

> 模板引擎很多但常用的是:jsp、freemarker、Thymeleaf

模板引擎核心思想图:

![image-20210921194501055](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210921194501055.png)

模板引擎的作用就在于就是我们写一个HTML页面模板,然后呢,页面中有些值是动态的,比如商品价格等等,然后我们写一个表达式,而这些动态值是从我们后台数据库获取然后组织然后将数据交给模板引擎,而模板引擎就会去页面模板对表达式进行解析然后填充数据,最终这个页面由我们想要的内容进行展示出来,这就是我们这个模板引擎,不管是哪一个模板引擎都是这个核心思想;

### 1.2 快速使用

引入maven:

```xml-dtd
<!--thymeleaf-->
<dependency>
    <groupId>org.springframework.boot</groupId>
<artifactId>spring-boot-starter-thymeleaf</artifactId> <!--在springBoot做任何事都是starter启动对应场景即可-->
</dependency>
```

如何使用:

springBoot核心东西就是自动装配,所以我们使用之前看springBoot为我们做了些什么?

1. 在spring-factories找到`ThymeleafAutoConfiguration`;

2. 然后点进去找到ThymeleafProperties这个配置类

   ```java
   @EnableConfigurationProperties(ThymeleafProperties.class)
   ```

3. 然后我们点击`ThymeleafProperties.class`进去看看:

   ![image-20210921200009853](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210921200009853.png)

   从图中可以看出有一个路径:`classpath:/templates/`,然后还有一个后缀;

   **结论**:我们只需要把我们的HTML页面放在类路径下的templates下,那么thymeleaf就可以自动帮我们渲染了;

测试:

1. 编写Controller:

   ```java
   @Controller
   public class HelloController {
   
       @RequestMapping("/demo")
       public String sayHello() {
           return "test";
       }
   }
   ```

2. 编写html:

   ```html
   <!DOCTYPE html>
   <html lang="en">
   <head>
       <meta charset="UTF-8">
       <title>thymeleaf</title>
   </head>
   <body>
   这是跳转到thymeleaf页面
   </body>
   </html>
   ```

3. 地址栏访问:

   ![image-20210921200837364](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210921200837364.png)

> 是成功通过thymeleaf解析跳转过来了!

**结论**:我们在Controller层返回view的时候,会被thymeleaf解析然后去resource根目录下的templates文件夹下对其view加上后缀:.html,拼接而成去寻找,找到就返回这个页面

> 我们之前做首页的时候,我们可以通过Controller去跳转页面,那么就可以通过thymeleaf去实现!

### 1.3 语法

语法的话以最新官方文档为准,这里是Thymeleaf 官网：https://www.thymeleaf.org/ ,

简单测试一下:

1. 修改Controller:

   ```java
   @Controller
   public class HelloController {
   
       @RequestMapping("/demo")
       public String sayHello(Model model) {
           model.addAttribute("msg", "shy哥牛逼");
           return "test";
       }
   }
   ```

2. 添加命名约束空间

   ```xml-dtd
   xmlns:th="http://www.thymeleaf.org"
   ```

3. 修改html:

   ```html
   <!DOCTYPE html>
   <html lang="en" xmlns:th="http://www.thymeleaf.org">
   <head>
       <meta charset="UTF-8">
       <title>thymeleaf</title>
   </head>
   <body>
   <div th:text="${msg}"></div>
   </body>
   </html>
   ```

4. 启动测试:

   ![image-20210921204215593](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210921204215593.png)

   这是常用的一些Thymeleaf语法:

   1. 我们可以使用任意的th:attr来替换Html中原生属性的值!

      ![img](https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Idia351qHgmH2vbzurk1Pp6fGYIwv043icVDYuybRJDCGTSNTMEibFzzMdlKS4t07TQoicQJKQAe0slQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

   2. 我们能写哪些表达式呢?

      ```java
      Simple expressions:（表达式语法）
      Variable Expressions: ${...}：获取变量值；OGNL；
          1）、获取对象的属性、调用方法
          2）、使用内置的基本对象：#18
               #ctx : the context object.
               #vars: the context variables.
               #locale : the context locale.
               #request : (only in Web Contexts) the HttpServletRequest object.
               #response : (only in Web Contexts) the HttpServletResponse object.
               #session : (only in Web Contexts) the HttpSession object.
               #servletContext : (only in Web Contexts) the ServletContext object.
      
          3）、内置的一些工具对象：
      　　　　　　#execInfo : information about the template being processed.
      　　　　　　#uris : methods for escaping parts of URLs/URIs
      　　　　　　#conversions : methods for executing the configured conversion service (if any).
      　　　　　　#dates : methods for java.util.Date objects: formatting, component extraction, etc.
      　　　　　　#calendars : analogous to #dates , but for java.util.Calendar objects.
      　　　　　　#numbers : methods for formatting numeric objects.
      　　　　　　#strings : methods for String objects: contains, startsWith, prepending/appending, etc.
      　　　　　　#objects : methods for objects in general.
      　　　　　　#bools : methods for boolean evaluation.
      　　　　　　#arrays : methods for arrays.
      　　　　　　#lists : methods for lists.
      　　　　　　#sets : methods for sets.
      　　　　　　#maps : methods for maps.
      　　　　　　#aggregates : methods for creating aggregates on arrays or collections.
      ==================================================================================
      
        Selection Variable Expressions: *{...}：选择表达式：和${}在功能上是一样；
        Message Expressions: #{...}：获取国际化内容
        Link URL Expressions: @{...}：定义URL；
        Fragment Expressions: ~{...}：片段引用表达式
      
      Literals（字面量）
            Text literals: 'one text' , 'Another one!' ,…
            Number literals: 0 , 34 , 3.0 , 12.3 ,…
            Boolean literals: true , false
            Null literal: null
            Literal tokens: one , sometext , main ,…
            
      Text operations:（文本操作）
          String concatenation: +
          Literal substitutions: |The name is ${name}|
          
      Arithmetic operations:（数学运算）
          Binary operators: + , - , * , / , %
          Minus sign (unary operator): -
          
      Boolean operations:（布尔运算）
          Binary operators: and , or
          Boolean negation (unary operator): ! , not
          
      Comparisons and equality:（比较运算）
          Comparators: > , < , >= , <= ( gt , lt , ge , le )
          Equality operators: == , != ( eq , ne )
          
      Conditional operators:条件运算（三元运算符）
          If-then: (if) ? (then)
          If-then-else: (if) ? (then) : (else)
          Default: (value) ?: (defaultvalue)
          
      Special tokens:
          No-Operation: _
      ```

      案例:

      1. controller:

         ```java
         @Controller
         public class HelloController {
         
             @RequestMapping("/demo")
             public String sayHello(Model model) {
                 model.addAttribute("msg", "<h1>shy哥牛逼</h1>");
                 model.addAttribute("lists", Arrays.asList("MiaoWei", "哇塞", "真棒"));
                 return "test";
             }
         }
         ```

      2. html:

         ```html
         <!DOCTYPE html>
         <html lang="en" xmlns:th="http://www.thymeleaf.org">
         <head>
             <meta charset="UTF-8">
             <title>thymeleaf</title>
         </head>
         <body>
         <!--原样输出-->
         <div th:text="${msg}"></div>
         <!--转义-->
         <div th:utext="${msg}"></div>
         
         <!--循环-->
         <h4 th:each="user:${lists}" th:text="${user}"></h4>
         <hr>
         <!--行内写法-->
         <h4 th:each="user:${lists}">[[${user}]]</h4>
         </body>
         </html>
         ```

      3. 测试:

         ![image-20210921205338899](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210921205338899.png)

## 2.MVC自动配置原理

虽然SprinBoot为我们的web做了大量的自动化配置,但是我们得清楚SpringBoot对我们的SpringMVC做了**哪些配置**、**如何扩展**、**如何定制**！

那么我们从两个途径去了解去搞清楚:

### 2.1 官方文档

地址:https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-auto-configuration

```java
Spring MVC Auto-configuration
// Spring Boot为Spring MVC提供了自动配置，它可以很好地与大多数应用程序一起工作。
Spring Boot provides auto-configuration for Spring MVC that works well with most applications.
// 自动配置在Spring默认设置的基础上添加了以下功能：
The auto-configuration adds the following features on top of Spring’s defaults:
// 包含视图解析器
1.Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans.
// 支持静态资源文件夹的路径，以及webjars
2.Support for serving static resources, including support for WebJars 
// 自动注册了Converter：
// 转换器，这就是我们网页提交数据到后台自动封装成为对象的东西，比如把"1"字符串自动转换为int类型,又或者前台传一个user中的字段,后台接收的时候会自动封装到user中去
// Formatter：【格式化器，比如页面给我们了一个2019-8-10，它会给我们自动格式化为Date对象】
3.Automatic registration of Converter, GenericConverter, and Formatter beans.
// HttpMessageConverters:消息转换
// SpringMVC用来转换Http请求和响应的的，比如我们要把一个User对象转换为JSON字符串，可以去看官网文档解释；
4.Support for HttpMessageConverters (covered later in this document).
// 定义错误代码生成规则的
5.Automatic registration of MessageCodesResolver (covered later in this document).
// 首页定制
6.Static index.html support.
// 图标定制
7.Custom Favicon support (covered later in this document).
// 初始化数据绑定器：帮我们把请求数据绑定到JavaBean中！
8.Automatic use of a ConfigurableWebBindingInitializer bean (covered later in this document).

/*
如果您希望保留Spring Boot MVC功能，并且希望添加其他MVC配置（拦截器、格式化程序、视图控制器和其他功能），则可以添加自己
的@configuration类，类型为webmvcconfiguer，但不添加@EnableWebMvc。如果希望提供
RequestMappingHandlerMapping、RequestMappingHandlerAdapter或ExceptionHandlerExceptionResolver的自定义
实例，则可以声明WebMVCregistrationAdapter实例来提供此类组件。
*/
If you want to keep Spring Boot MVC features and you want to add additional MVC configuration 
(interceptors, formatters, view controllers, and other features), you can add your own 
@Configuration class of type WebMvcConfigurer but without @EnableWebMvc. If you wish to provide 
custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter, or 
ExceptionHandlerExceptionResolver, you can declare a WebMvcRegistrationsAdapter instance to provide such components.

// 如果您想完全控制Spring MVC，可以添加自己的@Configuration，并用@EnableWebMvc进行注释。
If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc.
```

### 2.2 源码解析

从官方文档中可以得出SpringBoot为SpringMVC做了大量的自动配置,那么我们接下来仔细看看都有些什么?

1. ### 视图解析器

   首先从官方文档中得出能配置的第一项:

   ```java
   Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans. //包含视图解析器
   ```

   从文字上挑选出`ContentNegotiatingViewResolver`表示内容协商视图解析器;

   不难看出这就是我们之前学习springMVC中的视图解析器,之前我们都是手动进行配置,而现在看看springBppt怎么配置的:

   > 视图解析器:根据方法的返回值取得视图对象(view),然后由视图对象决定如何渲染(转发、重定向);

   接下来我们去看看源码:

   首先我们还是得从`WebMvcAutoConfiguration(因为这里是springMVC所有的配置都在这个配置类)`开始找:然后搜索`ContentNegotiatingViewResolver`找到如下方法:

   ```java
   @Bean
   @ConditionalOnBean(ViewResolver.class)
   @ConditionalOnMissingBean(name = "viewResolver", value = ContentNegotiatingViewResolver.class)
   public ContentNegotiatingViewResolver viewResolver(BeanFactory beanFactory) {
   			ContentNegotiatingViewResolver resolver = new ContentNegotiatingViewResolver();
   			resolver.setContentNegotiationManager(beanFactory.getBean(ContentNegotiationManager.class));
   			// ContentNegotiatingViewResolver使用所有其他视图解析器来定位视图，因此它应该具有较高的优先级
   			resolver.setOrder(Ordered.HIGHEST_PRECEDENCE);
   			return resolver;
   }
   ```

   然后我们点击`ContentNegotiatingViewResolver`看看:

   ```java
   public class ContentNegotiatingViewResolver extends WebApplicationObjectSupport
   		implements ViewResolver, Ordered, InitializingBean {..}
   ```

   可以发现是实现了视图解析器接口`ViewResolver`的类,我们就可以把它看做视图解析器;

   - 那思考一下既然实现视图解析器的接口,那该如何接管这个视图解析器呢?

   答:既然要接管那么我们就得按照这个规则来:我们去看这个`ViewResolver`接口:

   ```java
   public interface ViewResolver {
   	@Nullable
   	View resolveViewName(String viewName, Locale locale) throws Exception;//解析视图
   }
   ```

   那么我们在回过头再看看是怎么实现这个的方法的:

   ```java
   @Override  //默认的视图解析器
   	@Nullable //@Nullable 即参数可为null
   	public View resolveViewName(String viewName, Locale locale) throws Exception {
   		RequestAttributes attrs = RequestContextHolder.getRequestAttributes();
   		Assert.state(attrs instanceof ServletRequestAttributes, "No current ServletRequestAttributes");
   		List<MediaType> requestedMediaTypes = getMediaTypes(((ServletRequestAttributes) attrs).getRequest());
   		if (requestedMediaTypes != null) {
               //获取候选的视图
   			List<View> candidateViews = getCandidateViews(viewName, locale, requestedMediaTypes);
               //获取最好的视图
   			View bestView = getBestView(candidateViews, requestedMediaTypes, attrs);
   			if (bestView != null) {
   				return bestView;
   			}
   		}
   
   		....
   	}
   ```

   既然获取候选的视图,那它怎么获得候选的视图的呢?

   我们点击`getCandidateViews()`看看:

   ```java
   private List<View> getCandidateViews(String viewName, Locale locale, List<MediaType> requestedMediaTypes)
   			throws Exception {
   
   		List<View> candidateViews = new ArrayList<>();
   		if (this.viewResolvers != null) {
   			Assert.state(this.contentNegotiationManager != null, "No ContentNegotiationManager set");
               //这里就是遍历所有的视图解析器,从它们的工具类中去获取
   			for (ViewResolver viewResolver : this.viewResolvers) {
                   //把它封装成一个对象
   				View view = viewResolver.resolveViewName(viewName, locale);
   				if (view != null) {
                       //添加进去
   					candidateViews.add(view);
   				}
   				...
   		}
   		if (!CollectionUtils.isEmpty(this.defaultViews)) {
   			candidateViews.addAll(this.defaultViews);
   		}
   		return candidateViews;
   	}
   ```

   可以得出`getCandidateViews`中就是把所有的视图解析器进行遍历解析,所以得出一个结论:

   > ContentNegotiatingViewResolver这个视图解析器就是用来组合所有的视图解析器的

   而我们再研究它这里有个属性`viewResolvers`,看看它是在哪里进行赋值的?

   ```java
   protected void initServletContext(ServletContext servletContext) {
       // 这里它是从beanFactory工具中获取容器中的所有视图解析器
       // ViewRescolver.class 把所有的视图解析器来组合的
       Collection<ViewResolver> matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(this.obtainApplicationContext(), ViewResolver.class).values();
       ViewResolver viewResolver;
       if (this.viewResolvers == null) {
           this.viewResolvers = new ArrayList(matchingBeans.size());
       }
       // ...............
   }
   ```

   这里表示它是在容器中去找视图解析器,那么思考一下我们也可以写一个视图解析器然后放进容器中,然后被加载解析进行组合起来:

   **自定义视图解析器**:

   1. 实现视图解析器接口,并覆写其解析视图方法

      ```java
      @Configuration
      public class MyMvcConfig implements WebMvcConfigurer {
      
          @Bean //加载到Spring容器中
          public ViewResolver myViewResolver() {
              return new MyViewResolver();
          }
      
          /**
           * 我的视图解析器-自定义一个视图解析器
           *
           * @author MiaoDaWei
           * @date 2021/09/24
           */
          public static class MyViewResolver implements ViewResolver {
              @Override
              public View resolveViewName(String viewName, Locale locale) throws Exception {
                  return null;
              }
          }
      }
      ```

2. 由于在SpringMVC执行流程中都会执行到`dispatcherServlet`,所以我们全局搜索`dispatcherServlet`这个类,并找到`doDispatch`这个方法:

   ![image-20210924195722308](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210924195722308.png)

   我们在doDispatcher这里打断点可以发现这里有很多方法,我们找到viewResolvers视图解析器,展开发现默认的是`ContentNegotiatingViewResolver`,然后我们找到自己自定义写的视图解析器,

   得出一个结论:

   > 如果我们想自定义一些定制化的功能,只要写这个组件,然后将它交给springBoot,而springBoot就会帮我们自动转配!

   也即是说springBoot自动配置的mvc中,会从Bean容器中获取候选的所有的视图解析器,然后进行解析封装选择一个最好的视图解析器然后运行;举个例子:我们在之前写Thymeleaf的时候返回视图,就是由ThymeLeaf视图解析器进行解析然后去templates文件夹去匹配!

2. ### 转换器

   我们从`WebMvcAutoConfiguration`这个类点进去搜索`Formatter`找到`mvcConversionService`这个方法:

   ```java
   @Bean
   		@Override
   		public FormattingConversionService mvcConversionService() {
               //这里从配置文件中获取格式化规则
   			Format format = this.mvcProperties.getFormat();
   			WebConversionService conversionService = new WebConversionService(new DateTimeFormatters()
   					.dateFormat(format.getDate()).timeFormat(format.getTime()).dateTimeFormat(format.getDateTime()));
   			addFormatters(conversionService);
   			return conversionService;
   }
   ```

   我们点击这个`this.mvcProperties.getFormat();`看看配置文件:

   ```java
   private final Format format = new Format();
   //然后我们点击这个Format格式类对象
   
   public static class Format {
   
   		/**
   		 * Date format to use, for example `dd/MM/yyyy`.
   		 */
   		private String date;
   
   		/**
   		 * Time format to use, for example `HH:mm:ss`.
   		 */
   		private String time;
   
   		/**
   		 * Date-time format to use, for example `yyyy-MM-dd HH:mm:ss`.
   		 */
   		private String dateTime;
   }
   ```

   以上就是默认的格式转换,

   > 可以发现:转换器就是自动把前台传的日期通过配置文件进行获取格式化规则进行格式化转换给我们后台

   那么试想既然是通过配置文件进行获取的,那么我们可以在yaml中进行修改成我们想要的格式:

   ![image-20210924202442450](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210924202442450.png)

   自定义格式后,如果前台传的不是这个格式就会报错;

   这里进行演示:

   yaml:

   ```yaml
   spring:
     mvc:
       format:
         date: yyyy-MM-dd
   ```

   controller:

   ```java
   @Controller
   public class DateController {
       @RequestMapping("/test")
       public void test(Date date){
           System.out.println("date = " + date.getTime());
       }
   }
   ```

   1. 这是输入正确的数据:

      ![image-20210924204853089](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210924204853089.png)

      控制台:

      ![image-20210924204917432](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210924204917432.png)

   2. 这是输入错误的数据:

      ![image-20210924205011614](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210924205011614.png)

      控制台也会打印错误日志!

      ![image-20210924205041189](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210924205041189.png)

### 2.3 修改springBoot默认设置

通过以上的源码解析可以看出原理都是一样的,springBoot在自动配置很多组件的时候,会先去看容器中是否存在用户自己配置的(如果用户自己配置@bean),如果有就用用户配置的,如果没有就用自动配置的;

就打个比方:比如我们的视图解析器,我们放进容器中,springBoot就会将用户配置的和自己默认定义的组合起来进行组合成候选配置,然后选出一个最好的!

那我们如何在已有的MVC的配置上扩展自己想要的自定义配置呢?

这是官方文档:

```java
/*
如果您希望保留Spring Boot MVC功能，并且希望添加其他MVC配置（拦截器、格式化程序、视图控制器和其他功能），则可以添加自己
的@configuration类，类型为webmvcconfiguer，但不添加@EnableWebMvc。如果希望提供
RequestMappingHandlerMapping、RequestMappingHandlerAdapter或ExceptionHandlerExceptionResolver的自定义
实例，则可以声明WebMVCregistrationAdapter实例来提供此类组件。
*/
If you want to keep Spring Boot MVC features and you want to add additional MVC configuration 
(interceptors, formatters, view controllers, and other features), you can add your own 
@Configuration class of type WebMvcConfigurer but without @EnableWebMvc. If you wish to provide 
custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter, or 
ExceptionHandlerExceptionResolver, you can declare a WebMvcRegistrationsAdapter instance to provide such components.
```

表示:我们要做的就是编写一个`@Configuration`注解类,并且实现接口`WebMvcConfigurer`,但是要注意不能标注@EnableWebMVC注解;

案例:

**引入**:我们之前学习SSM的时候,我们要跳转一个登录界面的时候,由于对应的JSP放在web-inf下面,不能直接通过地址栏访问,所以我们通过访问Controller,然后通过地址去跳转!

Controller:

```java
//如果我们要扩展springMVC,官方建议我们这样去做!因为这样既能保留所有的自动配置,又能使用我们扩展的配置
@Configuration
public class MyMvcConfig implements WebMvcConfigurer {

    @Override
    public void addViewControllers(ViewControllerRegistry registry) {
        //视图跳转
        //浏览器发送/miao,那么就会test页面
        registry.addViewController("/miao").setViewName("test");
    }
}
```

地址栏:

![image-20210924211142062](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210924211142062.png)

这里是跳转成功了,只不过这里没传值而已,但是已经跳转过来了!

#### 2.3.1 why不加@EnableWebMVC注解的原理

在官方文档中说到我们在扩展SpringMVC的时候是不能加入`@EnableWebMvc`这个注解,那么为什么呢?

1. 我们点击这个注解查看:

   ```java
   @Retention(RetentionPolicy.RUNTIME)
   @Target(ElementType.TYPE)
   @Documented
   @Import(DelegatingWebMvcConfiguration.class)
   public @interface EnableWebMvc {
   }
   ```

   可以得出加上这个注解就是导入了这个一个类的意思

2. 我们在`WebMvcAutoConfiguration`自动配置类里找到`WebMvcAutoConfigurationAdapter`这个方法:

   ```java
   @Configuration(proxyBeanMethods = false)
   	@Import(EnableWebMvcConfiguration.class)
   	@EnableConfigurationProperties({ WebMvcProperties.class,
   			org.springframework.boot.autoconfigure.web.ResourceProperties.class, WebProperties.class })
   	@Order(0)
   	public static class WebMvcAutoConfigurationAdapter implements WebMvcConfigurer, ServletContextAware {
           ...
       }
   ```

   我们在其注解中找到`@Import(EnableWebMvcConfiguration.class)`,表示在自动配置时会导入这个类

3. 我们点击这个EnableWebMvcConfiguration这个类查看:

   ```java
   @Configuration(proxyBeanMethods = false)
   	@EnableConfigurationProperties(WebProperties.class)
   	public static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration implements ResourceLoaderAware {
           ...
       }
   ```

   这里可以看出默认继承了`DelegatingWebMvcConfiguration`这个类,跟我们使用注解`@EnableWebMvc`导入的类一模一样

4. 我们点击DelegatingWebMvcConfiguration这个类查看这个方法:

   ```java
   @Autowired(required = false) //自动注入
   	//setConfigurers:设置配置
   	//这里获取所有实现了WebMvcConfigurer接口的东西
   	public void setConfigurers(List<WebMvcConfigurer> configurers) {
           //如果这个集合不为空
   		if (!CollectionUtils.isEmpty(configurers)) {
               //就把这个添加进去
   			this.configurers.addWebMvcConfigurers(configurers);
   		}
   	}
   ```

   这段代码的意思就是会获取容器中的所有实现`WebMvcConfigurer`接口的意思!

5. 我们可以在这个类中去寻找一个我们刚才设置的viewController当做参考，发现它调用了一个

   ```java
   protected void addViewControllers(ViewControllerRegistry registry) {
       this.configurers.addViewControllers(registry);
   }
   ```

6. 我们点进去看一下

   ```java
   
   public void addViewControllers(ViewControllerRegistry registry) {
       Iterator var2 = this.delegates.iterator();
   
       while(var2.hasNext()) {
           // 将所有的WebMvcConfigurer相关配置来一起调用！包括我们自己配置的和Spring给我们配置的
           WebMvcConfigurer delegate = (WebMvcConfigurer)var2.next();
           delegate.addViewControllers(registry);
       }
   }
   ```

   所以得出**结论**：所有的WebMvcConfiguration都会被作用，不止Spring自己的配置类，我们自己的配置类当然也会被调用；

#### 2.3.2 全面接管springMVC

官方文档:

```java
If you want to take complete control of Spring MVC
you can add your own @Configuration annotated with @EnableWebMvc.
//翻译:如果你想要全面接管spsringMVC,那么你要添加@Configuration注解和@EnableWebMvc注解
```

> 全面接管即：SpringBoot对SpringMVC的自动配置不需要了，所有都是我们自己去配置！

当前,我们工作中肯定不推荐全面接管springMVC;不过我们来分析一下为什么说加了这个注解就会全面失效:

1. 我们点击`@EnableWebMvc`这个注解里面:发现它这里导了一个类

   ```java
   @Import({DelegatingWebMvcConfiguration.class})
   public @interface EnableWebMvc {
   }
   ```

2. 我们点击它`DelegatingWebMvcConfiguration`,发现继承了一个父类 WebMvcConfigurationSupport

   ```java
   public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport {
     // ......
   }
   ```

3. 不慌,我们暂时先回到`WebMvcAutoConfiguration`的自动配置类里面:

   ```java
   @ConditionalOnMissingBean(WebMvcConfigurationSupport.class) //注解意思:当这个容器中没有这个组件的时候,那么这个配置类才会生效
   ...
   public class WebMvcAutoConfiguration {...}
   ```

   而这个组件又跟我们@EnableWebMvc注解中导入的类的父类一模一样,那么也可以得出结论:

   > 加上@EnableWebMvc就会使我们MVC自动配置类全盘失效!

   注意:我们在底层代码中看到许多带有`xxx Configuration`这个配置类,帮助我们进行扩展配置,只要看见了这个东西,我们就要注意了!
