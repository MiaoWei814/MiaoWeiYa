# Spring Boot笔记

## 1. 简介:

**引入**:Spring诞生时Java企业版的**轻量级代替品**。无需开发重量级的EJB，Spring为企业级Java开发提供了一种相对简单的方法：通过依赖注入和面向切面编程，用简单的对象实现了EJB的功能！\

注意:Spring是为了解决企业级应用开发的复杂性而创建的,简化开发!

Spring是如何简化开发的:

```
为了降低Java开发的复杂性,Spring采用了以下4种关键策略:
1.基于POJO的轻量级和最小侵入性编程,所有东西都是bean
2.通过IOC,依赖注入(DI)和面向接口实现松耦合
3.基于切面(Aop)和惯例进行声明式编程;
4.通过切面和模板减少样式代码,比如:RedisTemplate,xxxTemplate
```

**注意**：虽然Spring的组件代码是轻量级，但它的配置却是重量级的！

> 理解：这句话的意思就是说Spring的诞生就是解决了对象之间的依赖关系，让对象之间进行解耦合，这些都是Spring容器进行负责处理,虽然最终我们可以让对象之间解耦合,但是我们却要针对每一个对象去进行配置,项目越来越大这配置文件中的对象就越来越繁杂冗余!

来看Spring的发展史:

第一阶段:xml配置:

```
在Spring 1.x时代,使用Spring开发满眼都是xml配置的Bean,随着项目的扩大,我们需要把xml配置文件放到不同的配置文件里,在那个时候就需要在频繁的在开发的类和配置文件之间进行切换
```

第二阶段:注解配置:

```
在Spring 2.x时代,随着JDK1.5带来的注解支持,Spring提供了声明Bean的注解(比如:@Controller、@Service),大大减少了配置量,主要使用的方式是应用的基本配置(如配合数据库配置,扫描包路径)用xml配置文件,业务配置用注解!
```

第三阶段:java配置:

```
Spring 3.x引入了基于Java的配置能力,这是一种类似安全的可重构配置方式,可以代替XML,我们目前刚好处于这个时代,Spring 4.x和Spring Boot都推荐使用Java配置。
```

**结论**：

1. 所有这些配置都代表了开发时的损耗。因为在思考**Spring特性配置**和**解决业务问题**之间需要进行思维切换，所以写配置挤占了写应用程序逻辑的时间！
2. 除此之外，项目的**依赖管理**也是件吃力不讨好的事情。决定项目里用哪些库就已经够让人头疼的了，你还要知道这些库的哪个**版本**和其他库不会有**冲突**，这难题实在太棘手，并且依赖管理也是一种损耗，添加依赖不是写应用程序代码，一旦选错了依赖的版本，随之而来的不兼容问题会是生产力杀手

> Spring Boot的产生就是简化Spring而诞生的!Spring Boot(微框架)=SpringMvc(控制器)+Spring(项目管理)

**概述**:Spring Boot简化了基于Spring的应用开发,只需要"run"就能创建一个独立的、生产级别的Spring应用。Spring Boot为Spring平台及第三方库提供了开箱即用的设置（提供默认设置),这样我们就可以简单的开始使用,多数的Spring Boot应用只需要很少的Spring配置。

**Spring Boot 主要优点:**

1. 为所有Spring开发者提供更快的入门
2. **开箱即用**,提供各种默认配置来简化项目配置
3. 内嵌式容器简化Web项目
4. 没有冗余代码生成和XML配置的要求

```
理解:
1.spring Boot就是一个javaweb的开发框架,和springMVC类似,好处就在于简化开发:约定大于配置
2.springBoot基于Spring开发,但是要区别于该Spring Boot不是用来替代Spring的解决方案,而是跟Spring框架紧密集合用于提升Spring开发者体验的工具!
3.SpringBoot其实并不是什么新的框架,只是整合了所有的框架,只是默认配置了很多框架的使用方式;
```



## 2.简单运行

**使用IDEA创建项目:**

1. 创建一个新项目
2. 选择spring initalizr ， 可以看到默认就是去官网的快速构建工具那里实现
3. 填写项目信息
4. 选择初始化的组件（初学勾选 Web 即可）
5. 填写项目路径
6. 等待项目构建成功

**创建完毕后会自动生成以下文件:**

1. 程序的主启动类
2. 一个application.properties 配置文件
3. 一个 测试类
4. 一个 pom.xml

**编写接口:**

1. 在主程序的同级目录下,新建一个Controller包,**注意一定要在同级目录下,否则识别不到**
2. 在包中新建一个HelloController类

```java
@RestController
public class HelloController {
 
    @RequestMapping("/")
    public String sayHello(){
        return "Hello Spring Boot!";
    }
}
```

3. 编写完毕然后运行主程序,然后在控制台就可以看见tomcat访问的端口号:

```
2021-09-17 20:37:10.218  INFO 16840 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8888 (http) with context path ''
```

4. 页面访问:

![image-20210917203813895](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210917203813895.png)

**踩坑记录:**
1.我把新建的Controller的包放在其他路径下就是不放在主程序的同级目录下,那么就会发生404,如:


![四、创建第一个springboot项目_第一个_06](https://gitee.com/miawei/pic-go-img/raw/master/imgs/2019021916031092.png)

解决办法是:

```java
@ComponentScan(basePackages = {"com.example.*"})//放在主程序的类上,表示覆写自定义包下的类,具体什么原理在自动装配原理那节详细讲
```

------

这种就是通过在IDEA工具进行启动访问,还有一种就是通过打包的方式运行

![image-20210917204039104](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210917204039104.png)

打成jar包后,我们在所在的文件夹下运行该jar包,就可以在任何地方进行访问了:

![image-20210917204143883](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210917204143883.png)

cmd运行:

![image-20210917204320615](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210917204320615.png)

> 这里之所以可以直接运行,是因为springBoot是内嵌式容器也就是tomcat!

总结:

1. spring Boot以约定大于配置的核心思想
2. 程序=数据结构+算法
3. spring Boot就是一个spring mvc框架
4. spring Boot的核心东西:自动装配!

还有在resource目录下的文件如果被spring boot识别成功就会有一个小图标,如:

<img src="https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210917205036312.png" alt="image-20210917205036312" style="zoom:200%;" />

还有做下笔记我们启动spring boot有启动图案,可以改的:

> 在resource下新建banner.txt文件,然后https://www.bootschool.net/ascii 这个网站生成,然后拷贝到文件中即可!

这里写一下微服务的概念:

**微服务就是把业务拆分成模块**

单体应用架构:把一个应用中的所有应用服务封装到一个应用;

微服务:把每个服务独立出来,把独立出来的功能元素的动态组合,

## 3.自动装配原理

我们在创建编写spring boot的时候,就在思考是怎么运行起来的呢?新建一个spring boot项目又不像SSM那样进行整合和创建过多的依赖配置,我们新建后可以编写http接口访问?我们先来看pom.xml依赖开始:

### 3.1 pom.xml

```xml-dtd
 	<parent>
        <!--父依赖-->
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.5.4</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
```

可以发现这里是一个父依赖,主要管理项目的资源过滤及插件;

点进去,发现还有一个父依赖:

```xml-dtd
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-dependencies</artifactId>
    <version>2.5.4</version>
</parent>
```

这里才是真正管理spring Boot应用里面所有依赖版本的地方,springBoot的版本控制中心!

> 总结:以后我们在导入依赖的时候不需要写对应的版本,因为当前pom依赖继承了父依赖,而在父依赖里已经定义了这些版本在父工程中!当然父工程中没有改依赖那么就需要手动配置版本了!

而再来看看启动器:spring-boot-starter:

```xml-dtd
<dependency>
   <groupId>org.springframework.boot</groupId>
   <artifactId>spring-boot-starter-web</artifactId> <!--启动器,说白了就是spring boot的启动场景,它就会帮我们导入web环境所有的依赖-->
            <!--这可以不要版本,因为是继承父依赖的-->
</dependency>
```

其中:

1. **spring-boot-starter-xxx**:就是spring-boot的场景启动器
2. **spring-boot-starter-web**:帮我们导入了web模块正常运行所依赖的组件;

**说明**:SpringBoot将所有的功能场景抽取出来,做成一个个的starter(启动器),只需要在项目中引入这些starter即可,所有相关的依赖都会导入进来,我们要用什么功能就导入什么样的场景启动器即可!

**理解**:在构建项目的时候,我们会勾选上web这个模块,然后在项目初始化的时候spring-boot就会将比如dispatcherServlet,servlet,都会导入到项目依赖中

> spring Boot会将所有的功能场景,都变成一个个的启动器,我们要使用什么功能就只需要找到对应的启动器就可以了`starter`

### 3.2 主启动类

```java
@SpringBootApplication  //来标注一个主程序类->说明这是一个Spring Boot应用
public class SpringbootProjectApplication {
    public static void main(String[] args) {
        //将springboot应用启动,这里以为是启动了一个方法没想到是启动了一个服务!
        SpringApplication.run(SpringbootProjectApplication.class, args);
    }
}
```

我们接下来就来分析一下这个主程序都干了些东西!

1. #### @SpringBootApplication

   作用:标注在某个类上说明这个类是springBoot的主配置类,Spring Boot就应该运行这个类的main方法来启动SpringBoot应用;

   进入这个注解可以发现上面还有很多注解:

   ```java
   @SpringBootConfiguration
   @EnableAutoConfiguration
   @ComponentScan(
       excludeFilters = {@Filter(
       type = FilterType.CUSTOM,
       classes = {TypeExcludeFilter.class}
   ), @Filter(
       type = FilterType.CUSTOM,
       classes = {AutoConfigurationExcludeFilter.class}
   )}
   )
   public @interface SpringBootApplication {
       // ......
   }
   ```

2. #### @ComponentScan

   这个注解在spring很重要,它对应XML配置中的元素,也就是扫描我们默认的包下的注解比如@Controller然后加载到我们IOC容器中!

   作用:自动扫描并加载符合条件的组件或者bean,将这个bean定义加载到IOC容器中,默认扫描当前类下的package

3. #### @SpringBootConfiguration

   作用:SpringBoot的配置类,标注在某个类上,表示这是一个SpringBoot的配置类,它表示就是支持JavaConfig形式的IOC容器的配置类

   ```java
   这个javaConfig形式的配置类就是跟我们平常使用的xml配置文件也是一样的,只不过两者配置方式不一样!给你们来个经典案例:
   javaconfig:
   @Configuration
   public class MockConfiguration{
       @Bean
       public MockService mockService(){
           return new MockServiceImpl(dependencyService());
       }
   }
   xml:
   <bean id="mockService" class="..MockServiceImpl">
      <propery name ="dependencyService" ref="dependencyService" />
   </bean>
   ```

   我们在点进去再看看:

   ```java
   //点击这个注解进入下面那个@Component
   @Configuration  //说百了就是支持JavaConfig的方式进行配置
   public @interface SpringBootConfiguration {...}
   
   @Component
   public @interface Configuration {...}
   ```

   这里的@Configuration说明这是一个配置类,配置类就是对应的Spring的xml配置文件;而再点进去得到的@Component这就说明该启动类本身也就是Spring中的一个组件而已,负责启动应用!

   ------

   我们再回到@SpringBootApplication注解中再看:

4. #### @EnableAutoConfiguration

   **开启自动配置功能**

   以前我们需要自己配置的东西,而现在SpringBoot可以自动帮我们配置;

   而@EbableAutoConfiguration告诉springBoot开启自动配置功能,这样自动配置才能生效;

   点击注解继续查看:

5. #### @AutoConfigurationPackage

   **自动配置包**

   ```java
   @Import(AutoConfigurationPackages.Registrar.class)
   public @interface AutoConfigurationPackage {...}
   ```

6. #### @Import

   这是Spring底层注解,给容器中导入一个组件;

   Registrar.class作用:将主启动类的所在包下面所有子包里面的所有组件扫描到Spring容器中;(所以为什么说要跟主程序同一个包才可以)

   我们在点击进去查看:

   ```java
   @Override
   public void registerBeanDefinitions(AnnotationMetadata metadata,
           BeanDefinitionRegistry registry) {
       register(registry, new PackageImport(metadata).getPackageName());
   }
   ```

   表示在默认的情况下就是将:主配置类(@SpringBootApplication)的所在包及其子包里面的部件扫描到Spring容器中!

   思考:这里也是扫描包加载到spring容器那么我们之前使用@ComponentScan的功能不就是重复了吗?

   > 比如说,我们使用Spring Data JPA,可能会在实体类上写@Entity注解,而这个注解是由@AutoConfigurationPackage扫描并加载,而我们平时开发用的@Controller/@Service...这些注解是由CompoentScan来扫描并加载的; 简单理解就是:两者扫描的对象都是不一致的!

   ------

   回到上一步:

7. #### @Import(AutoConfigurationImportSelector.class)

   **给容器导入组件**

   AutoConfigurationImportSelector:自动配置导入选择器,那么它会导入哪些组件的选择器呢?我们再点击这个源码查看:

   - 首先看下这里:

     ```java
     @Override
     //所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中
     	public String[] selectImports(AnnotationMetadata annotationMetadata) {
     		if (!isEnabled(annotationMetadata)) {
     			return NO_IMPORTS;
     		}
     		AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(annotationMetadata);
     		return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());
     	}
     ```
   
     表示加载元数据,表示把pom.xml文件中的数据加载进来,加载完后就进入下一步:
   
   - 获得自动配置实体:
   
     ```java
     protected AutoConfigurationEntry getAutoConfigurationEntry(AnnotationMetadata annotationMetadata) {
     		if (!isEnabled(annotationMetadata)) {
     			return EMPTY_ENTRY;
     		}
     		AnnotationAttributes attributes = getAttributes(annotationMetadata);
     		List<String> configurations = getCandidateConfigurations(annotationMetadata, attributes);
     		configurations = removeDuplicates(configurations);
     		Set<String> exclusions = getExclusions(annotationMetadata, attributes);
     		checkExcludedClasses(configurations, exclusions);
     		configurations.removeAll(exclusions);
     		configurations = getConfigurationClassFilter().filter(configurations);
     		fireAutoConfigurationImportEvents(configurations, exclusions);
     		return new AutoConfigurationEntry(configurations, exclusions);
     	}
     ```
   
   - 然后点击其中的getCandidateConfigurations来获取候选的配置:
   
     ```java
     //获得所有的配置
     protected List<String> getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) {
         	//这里getSpringFactoriesLoaderFactoryClass()返回的是我们最开始看的启动自动导入配置文件的注解类,是:@EnableAutoConfiguration
     		List<String> configurations = SpringFactoriesLoader.SpringFactoriesLoader(getSpringFactoriesLoaderFactoryClass(),
     		//getBeanClassLoader这是一个加载器,相当于当前类的                                                                                  
     				getBeanClassLoader());
         	//这里提个彩蛋:这里断言可以如果发现不再就会给出提示说 META-INF/spring.factories这个文件找不到.那么这个有什么用呢?
     		Assert.notEmpty(configurations, "No auto configuration classes found in META-INF/spring.factories. If you "
     				+ "are using a custom packaging, make sure that file is correct.");
     		return configurations;
     }
     //然后获取了哪些配置呢?就是这里
     //这里是getSpringFactoriesLoaderFactoryClass返回的是注解类:  意思是加载类,加载启动类2下的所有资源被导入
     protected Class<?> getSpringFactoriesLoaderFactoryClass() {
     		return EnableAutoConfiguration.class;
     }
     ```
   
   - 我们在点击`SpringFactoriesLoader`的静态方法`SpringFactoriesLoader`的源码查看:
   
     ```java
     //这是加载spring.factories这个自动配置文件的,而这里factorType表示加载了一个类这个类就是我们标注了@SpringBootApplication的这个类
     public static List<String> loadFactoryNames(Class<?> factoryType, @Nullable ClassLoader classLoader) {
     		ClassLoader classLoaderToUse = classLoader;
     		if (classLoaderToUse == null) {
     			classLoaderToUse = SpringFactoriesLoader.class.getClassLoader();
     		}
         //获取类的名字
     		String factoryTypeName = factoryType.getName();
         //这里它又调用loadSpringFactories方法,获取默认的包名,为空则返回空的集合
     		return loadSpringFactories(classLoaderToUse).getOrDefault(factoryTypeName, Collections.emptyList());
     	}
     ```
   
   - 我们继续查看loadSpringFactories源码里看:
   
     ```java
     private static Map<String, List<String>> loadSpringFactories(ClassLoader classLoader) {
         //这里先去缓存里去加载
     		Map<String, List<String>> result = cache.get(classLoader);
     		if (result != null) {
     			return result;
     		}
     
     		result = new HashMap<>();
     		try {
                 //去获取一个资源 "META-INF/spring.factories",这里通过class类加载器去获取资源,将里面所有自动配置类加载进来
     			Enumeration<URL> urls = classLoader.getResources(FACTORIES_RESOURCE_LOCATION);
                 //将获取的资源进行遍历,封装成为一个Properties
                 //判断有没有更多的元素,也即是从资源配置下找存在是否可以自动配置的东西,遍历完成之后封装为Properties供我们使用!
     			while (urls.hasMoreElements()) {
                     //如果有的话就放在url里面
     				URL url = urls.nextElement();
     				UrlResource resource = new UrlResource(url);
                     //把url这些资源加载到properties配置类里面,供我们使用
     				Properties properties = PropertiesLoaderUtils.loadProperties(resource);
     				for (Map.Entry<?, ?> entry : properties.entrySet()) {
     					String factoryTypeName = ((String) entry.getKey()).trim();
     					String[] factoryImplementationNames =
     							StringUtils.commaDelimitedListToStringArray((String) entry.getValue());
     					for (String factoryImplementationName : factoryImplementationNames) {
     						result.computeIfAbsent(factoryTypeName, key -> new ArrayList<>())
     								.add(factoryImplementationName.trim());
     					}
     				}
     			}
     
     			// Replace all lists with unmodifiable lists containing unique elements
     			result.replaceAll((factoryType, implementations) -> implementations.stream().distinct()
     					.collect(Collectors.collectingAndThen(Collectors.toList(), Collections::unmodifiableList)));
                 //放入到缓存里面
     			cache.put(classLoader, result);
     		}
     		catch (IOException ex) {
     			throw new IllegalArgumentException("Unable to load factories from location [" +
     					FACTORIES_RESOURCE_LOCATION + "]", ex);
     		}
     		return result;
     	}
     ```
   
   - 这里可以发现有个关键词:`FACTORIES_RESOURCE_LOCATION`这是常量对应的是:"META-INF/spring.factories",全局搜索:	


8. ## spring.factories(自动配置的核心文件)

   ![image-20210918114949624](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210918114949624.png)
   
   根据源头我们找到了spring.factories然后将其打开,可以发现有很多的配置的文件,**这就是自动配置的根源之所在**!
   
   我们往下翻找到`Auto Configure(自动配置)`下的`WebMvcAutoConfiguration`这个类,打开看看:
   
9. #### WebMvcAutoConfiguration

   <img src="https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210918150043307.png" alt="image-20210918150043307" style="zoom: 80%;" />

   ​		

   @Configuration:表示这是Java的一个配置类

   @ConditionalOnClass:这是spring注解表示通过一些条件来判断是否注入
   
   我们继续在当前类里往下翻:
   
   ![image-20210918210321016](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210918210321016.png)
   
   这个不难发现就是springMVC中的视图解析器,这个都已经自动配置了,还有一些过滤器啊什么的都是已经自动配置好了 	
   
   其中可以发现:这些一个个的都是Java Config配置类,而且都注入了一些Bean!
   
   **结论**:自动配置真正实现是从classPath中搜寻所有的`META-INF/spring.factories`配置文件,并将其中对应的`org.springframework.boot.autoconfigure.`包下的配置项,通过反射实例化为对应标注了`@Configuration`的JavaConfig形式的IOC容器配置类,然后将这些都汇总成为一个实例并加载到IOC容器中。
   
   
   
   -> 但是思考一个问题:既然是加载spring.factories里的所有的自动配置文件,那么为什么只生效了部分呢?
   
   比如我们随便点击一个没导入包的类进入:
   
   ![image-20210918230144508](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210918230144508.png)

可以发现`@ConditionalOnClass`这个就是一个判断条件,判断条件成立才会加载这个类!比如说这里必须这个jar包存在那么这个类才会生效!

### 3.3 画图解析

![自动装配原理分析](https://gitee.com/miawei/pic-go-img/raw/master/imgs/%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90.png)



 ### 3.3 总结

结论:springBoot所有的自动配置都是在启动的时候扫描并加载:`spring.factories`所有的自动配置类都在这里面,但是不一定生效,要判断条件是否成立,只要导入了对应的start,就有对应的启动器了,有了启动器,我们自动装配就会生效,然后配置成功!

步骤:

1. SpringBoot在启动的时候会从类路径下的`META-INF/spring.factories`中获取指定的值(就是一个个的URL然后遍历封装到Properties);
2. 将这些值作为自动配置类的导入容器(这个容器就是在具体的配置类中的`@Configuration`和方法上的`@Bean`),自动配置类就生效,帮我们进行自动配置工作
3. 整个J2EE的整体解决方案和自动配置都在(xxxAutoConfiguration),就是给容器中导入这个场景需要的所有组件,并配置好这些组件
4. 解决方案和自动配置都在`spring-boot-autoconfigure-2.5.4.jar`这个包下
5. 它会把所有需要导入的组件,以类名(配置文件中都是全限定类名)的形式返回,这些组件就会被添加到容器
6. 容器中也会存在非常多的xxxAutoConfiguration的文件,就是这些类给容器中导入了这个场景需要的所有组件(`@Bean`),并自动配置@Configuration
7. 有了自动配置类,免去了我们手动编写配置注入功能组件等的工作!

## 4.启动类

我们来看一下启动类是如何运行的:

```java
public static void main(String[] args) {
        TimeInterval timer = DateUtil.timer();
        //将springboot应用启动
        SpringApplication.run(SpringbootProjectApplication.class, args);
        //启动日志
        Console.log("〓〓〓系统启动成功,耗时{}〓〓〓，当前时间是{}", timer.intervalPretty(), DateUtil.now());
    }
```

最初的时候以为就是运行个main方法,没想到这里就是直接运行了一个服务!

SpringApplication调用一个静态方法run,该方法里有个参数,一个是当前类,一个是当前命令行参数

SpringApplication这个类主要做了以下四件事情:

1. 推断应用的类型是普通的java项目还是web项目
2. 查找并加载所有可用初始化器 ， 设置到initializers属性中
3. 找出所有的应用程序监听器，设置到listeners属性中
4. 推断并设置main方法的定义类，找到运行的主类

查看构造器:

```java

public SpringApplication(ResourceLoader resourceLoader, Class... primarySources) {
    // ......
    this.webApplicationType = WebApplicationType.deduceFromClasspath();
    this.setInitializers(this.getSpringFactoriesInstances();
    this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class));
    this.mainApplicationClass = this.deduceMainApplicationClass();
}
```

run方法流程分析:

![img](https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7L1vFQMnaRIJSmeZ58T2eZicjafiawQLp9u8wc4ic1Mjy6OyfibzfjVofeL5pnS1NSFKVjlIg6neI9ySg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

   跟着源码一起看效果会更好哦!

## 5.配置文件

在springBoot使用一个全局的配置文件,我们在创建springBoot的时候就会初始化一个文件`application.properties`这个文件,不过这个文件官方并不推荐,推荐的是另一种文件`yaml`格式的!

- application.properties
  - 语法结构:`key=value`
- application.yaml
  - 语法结构: `key:空格value`

**注意**:配置文件的名称是固定的!

因为springBoot底层就已经以这个名称写好了,说白了就是大家一起约定一下写一样的名字;

**解释**:

在pom.xml中的`spring-boot-starter-parent`中已经标注了:

```xml-dtd
<resource>
        <directory>${basedir}/src/main/resources</directory>
        <filtering>true</filtering>
        <includes>
          <include>**/application*.yml</include>
          <include>**/application*.yaml</include>
          <include>**/application*.properties</include>
        </includes>
</resource>
```

表示获取resource下的配置文件,并且这里还存在优先级问题,也就是如果同时存在的话!

**配置文件的作用**:修改SpringBoot自动配置的默认值,因为SpringBoot在底层都给我们自动配置好了

### 5.1 yaml概述

**概述**:YAML是 "YAML Ain't a Markup Language" （YAML不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是："Yet Another Markup Language"（仍是一种标记语言）

> 这种语言以数据为中心,而不是以标记语言为重点!

以前的配置文件,大多数都是使用xml来配置;比如一个简单的端口配置,我们来对比下yaml和xml:

传统的xml配置:

```xml
<servr>
	<port>8081</port>
</servr>
```

yaml配置:

```yaml
server:
	port: 8081
```

### 5.2 语法

1. ### 字面量:普通的值[数字,布尔值,字符串]

   ```yaml
   k: v
   ```

    字面量直接写在后面就可以,字符串默认不用加上双引号或者单引号

   **注意**:

   1. ""双引号,不会转义字符串里面的特殊字符,特殊字符会作为本身想表示的意思
      - 比如:name: "你好 \n 吗",然后输出:你好 换行 吗
   2. ''单引号,会转义特殊字符,特殊字符最终会变成和普通字符一样输出
      - 比如:name: '你好 \n 吗',然后输出:你好 \n 吗

2. ### 对象、Map(键值对)

   ```yaml
   # 对象、Map格式
   k：
   	v1: xx
   	v2: xx
   ```

   我们一般使用换行的形式来表达键值对的属性和值的关系,但是要注意缩进关系!比如:

   ```yaml
   student:
   	name: Miao
   	age: 3
   ```

   行内写法:

   ```yaml
   student: {name: Miao,age: 3}
   ```

3. ### 数组(List、set)

   用 - 值表示数组中的一个元素,比如:

   ```yaml
   zoo:
   	- cat
   	- dog
   	- pig
   ```

   行内写法:

   ```yaml
   zoo: [cat,dog,pig]
   ```

**注意事项**:

在yaml语法中对于空格是有着比较严格的要求!

1. 空格不能省略;
2. 以缩进来控制层级关系,只要左边对齐的一列数据都是同一个层级的
3. 属性和值的大小写都是十分敏感的;



   































