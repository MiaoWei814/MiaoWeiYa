# Spring Boot笔记

## 1. 简介:

**引入**:Spring诞生时Java企业版的**轻量级代替品**。无需开发重量级的EJB，Spring为企业级Java开发提供了一种相对简单的方法：通过依赖注入和面向切面编程，用简单的对象实现了EJB的功能！\

注意:Spring是为了解决企业级应用开发的复杂性而创建的,简化开发!

Spring是如何简化开发的:

```
为了降低Java开发的复杂性,Spring采用了以下4种关键策略:
1.基于POJO的轻量级和最小侵入性编程,所有东西都是bean
2.通过IOC,依赖注入(DI)和面向接口实现松耦合
3.基于切面(Aop)和惯例进行声明式编程;
4.通过切面和模板减少样式代码,比如:RedisTemplate,xxxTemplate
```

**注意**：虽然Spring的组件代码是轻量级，但它的配置却是重量级的！

> 理解：这句话的意思就是说Spring的诞生就是解决了对象之间的依赖关系，让对象之间进行解耦合，这些都是Spring容器进行负责处理,虽然最终我们可以让对象之间解耦合,但是我们却要针对每一个对象去进行配置,项目越来越大这配置文件中的对象就越来越繁杂冗余!

来看Spring的发展史:

第一阶段:xml配置:

```
在Spring 1.x时代,使用Spring开发满眼都是xml配置的Bean,随着项目的扩大,我们需要把xml配置文件放到不同的配置文件里,在那个时候就需要在频繁的在开发的类和配置文件之间进行切换
```

第二阶段:注解配置:

```
在Spring 2.x时代,随着JDK1.5带来的注解支持,Spring提供了声明Bean的注解(比如:@Controller、@Service),大大减少了配置量,主要使用的方式是应用的基本配置(如配合数据库配置,扫描包路径)用xml配置文件,业务配置用注解!
```

第三阶段:java配置:

```
Spring 3.x引入了基于Java的配置能力,这是一种类似安全的可重构配置方式,可以代替XML,我们目前刚好处于这个时代,Spring 4.x和Spring Boot都推荐使用Java配置。
```

**结论**：

1. 所有这些配置都代表了开发时的损耗。因为在思考**Spring特性配置**和**解决业务问题**之间需要进行思维切换，所以写配置挤占了写应用程序逻辑的时间！
2. 除此之外，项目的**依赖管理**也是件吃力不讨好的事情。决定项目里用哪些库就已经够让人头疼的了，你还要知道这些库的哪个**版本**和其他库不会有**冲突**，这难题实在太棘手，并且依赖管理也是一种损耗，添加依赖不是写应用程序代码，一旦选错了依赖的版本，随之而来的不兼容问题会是生产力杀手

> Spring Boot的产生就是简化Spring而诞生的!Spring Boot(微框架)=SpringMvc(控制器)+Spring(项目管理)

**概述**:Spring Boot简化了基于Spring的应用开发,只需要"run"就能创建一个独立的、生产级别的Spring应用。Spring Boot为Spring平台及第三方库提供了开箱即用的设置（提供默认设置),这样我们就可以简单的开始使用,多数的Spring Boot应用只需要很少的Spring配置。

**Spring Boot 主要优点:**

1. 为所有Spring开发者提供更快的入门
2. **开箱即用**,提供各种默认配置来简化项目配置
3. 内嵌式容器简化Web项目
4. 没有冗余代码生成和XML配置的要求

```
理解:
1.spring Boot就是一个javaweb的开发框架,和springMVC类似,好处就在于简化开发:约定大于配置
2.springBoot基于Spring开发,但是要区别于该Spring Boot不是用来替代Spring的解决方案,而是跟Spring框架紧密集合用于提升Spring开发者体验的工具!
3.SpringBoot其实并不是什么新的框架,只是整合了所有的框架,只是默认配置了很多框架的使用方式;
```



## 2.简单运行

**使用IDEA创建项目:**

1. 创建一个新项目
2. 选择spring initalizr ， 可以看到默认就是去官网的快速构建工具那里实现
3. 填写项目信息
4. 选择初始化的组件（初学勾选 Web 即可）
5. 填写项目路径
6. 等待项目构建成功

**创建完毕后会自动生成以下文件:**

1. 程序的主启动类
2. 一个application.properties 配置文件
3. 一个 测试类
4. 一个 pom.xml

**编写接口:**

1. 在主程序的同级目录下,新建一个Controller包,**注意一定要在同级目录下,否则识别不到**
2. 在包中新建一个HelloController类

```java
@RestController
public class HelloController {
 
    @RequestMapping("/")
    public String sayHello(){
        return "Hello Spring Boot!";
    }
}
```

3. 编写完毕然后运行主程序,然后在控制台就可以看见tomcat访问的端口号:

```
2021-09-17 20:37:10.218  INFO 16840 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8888 (http) with context path ''
```

4. 页面访问:

![image-20210917203813895](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210917203813895.png)

**踩坑记录:**
1.我把新建的Controller的包放在其他路径下就是不放在主程序的同级目录下,那么就会发生404,如:


![四、创建第一个springboot项目_第一个_06](https://gitee.com/miawei/pic-go-img/raw/master/imgs/2019021916031092.png)

解决办法是:

```java
@ComponentScan(basePackages = {"com.example.*"})//放在主程序的类上,表示覆写自定义包下的类,具体什么原理在自动装配原理那节详细讲
```

------

这种就是通过在IDEA工具进行启动访问,还有一种就是通过打包的方式运行

![image-20210917204039104](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210917204039104.png)

打成jar包后,我们在所在的文件夹下运行该jar包,就可以在任何地方进行访问了:

![image-20210917204143883](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210917204143883.png)

cmd运行:

![image-20210917204320615](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210917204320615.png)

> 这里之所以可以直接运行,是因为springBoot是内嵌式容器也就是tomcat!

总结:

1. spring Boot以约定大于配置的核心思想
2. 程序=数据结构+算法
3. spring Boot就是一个spring mvc框架
4. spring Boot的核心东西:自动装配!

还有在resource目录下的文件如果被spring boot识别成功就会有一个小图标,如:

<img src="https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210917205036312.png" alt="image-20210917205036312" style="zoom:200%;" />

还有做下笔记我们启动spring boot有启动图案,可以改的:

> 在resource下新建banner.txt文件,然后https://www.bootschool.net/ascii 这个网站生成,然后拷贝到文件中即可!

这里写一下微服务的概念:

**微服务就是把业务拆分成模块**

单体应用架构:把一个应用中的所有应用服务封装到一个应用;

微服务:把每个服务独立出来,把独立出来的功能元素的动态组合,

## 3.自动装配原理

我们在创建编写spring boot的时候,就在思考是怎么运行起来的呢?新建一个spring boot项目又不像SSM那样进行整合和创建过多的依赖配置,我们新建后可以编写http接口访问?我们先来看pom.xml依赖开始:

### 3.1 pom.xml

```xml-dtd
 	<parent>
        <!--父依赖-->
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.5.4</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
```

可以发现这里是一个父依赖,主要管理项目的资源过滤及插件;

点进去,发现还有一个父依赖:

```xml-dtd
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-dependencies</artifactId>
    <version>2.5.4</version>
</parent>
```

这里才是真正管理spring Boot应用里面所有依赖版本的地方,springBoot的版本控制中心!

> 总结:以后我们在导入依赖的时候不需要写对应的版本,因为当前pom依赖继承了父依赖,而在父依赖里已经定义了这些版本在父工程中!当然父工程中没有改依赖那么就需要手动配置版本了!

而再来看看启动器:spring-boot-starter:

```xml-dtd
<dependency>
   <groupId>org.springframework.boot</groupId>
   <artifactId>spring-boot-starter-web</artifactId> <!--启动器,说白了就是spring boot的启动场景,它就会帮我们导入web环境所有的依赖-->
            <!--这可以不要版本,因为是继承父依赖的-->
</dependency>
```

其中:

1. **spring-boot-starter-xxx**:就是spring-boot的场景启动器
2. **spring-boot-starter-web**:帮我们导入了web模块正常运行所依赖的组件;

**说明**:SpringBoot将所有的功能场景抽取出来,做成一个个的starter(启动器),只需要在项目中引入这些starter即可,所有相关的依赖都会导入进来,我们要用什么功能就导入什么样的场景启动器即可!

**理解**:在构建项目的时候,我们会勾选上web这个模块,然后在项目初始化的时候spring-boot就会将比如dispatcherServlet,servlet,都会导入到项目依赖中

### 3.2 主启动类

