# 使用到的技术

## 1. 图片上传-fastdfs

首先这是一个分布式文件系统

![image-20211027225924233](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211027225924233.png)

```
为什么需要分布式文件系统:

在使用Fastdfs之前的单体上传文件缺点:
	1. 图片上传和其他crud请求都在一个服务器进行处理,这样服务器压力会比较大
	2. 不能在集群环境中使用,每一个服务器磁盘都是独立的!
使用fastdfs的优点:
	1.存储量大,因为使用的是分布式集群服务器
	2.单点故障,因为在集群中任何一台服务器出现故障都不会影响整体的运行,效率得到提升

理解:因为在这之前我们服务器使用的是一种单体架构方式,所有请求都是一个服务器处理,图片上传也是上传到本地硬盘中进行存储!而随着项目的不断发展和推进,项目分裂出分布式服务器,那么这个时候文件如果还是用之前的文件上传,那么在集群环境中是不可行的,因为每一个服务器所在的磁盘都是独立的!所以我们需要使用一种分布式文件管理系统进行单独管理上传服务器!

为什么选择fastdfs:
	我们之所以选择它是因为首先它是一种开源的分布式文件系统,它具有高可用、高可靠、负载均衡、冗余备份、线性扩容等特点，它给我的使用感受呢就是存储量大，因为使用单独的服务器集群去管理存储，并且它还是单点故障，也就是说在集群中如果有一台服务器出现了故障那么文件管理系统依然还能运行！那么这就是高可用和高可靠！并且既然是集群那么肯定就是主从复制，主节点负责上传文件而从节点负责文件的读，如果并发量很大的情况下，我们还可以进行线性扩容从节点，这样达到了一个均衡的一个目的！
```

解释:

​	FastDFS 是用 c 语言编写的一款开源的分布式文件系统。FastDFS 为互联网量身定制，充分考虑了`冗余备份`、`负载均衡`、`线性扩容`等机制，并注重高可用、高性能等指标，使用 FastDFS很容易搭建一套`高性能的文件服务器集群`提供文件上传、下载等服务。

​	FastDFS 架构包括 **Tracker server** 和 **Storage server**。客户端请求 Tracker server 进行文件上传、下载，通过 Tracker server 调度最终由 Storage server 完成文件上传和下载。

每个部分的作用:

1. **Tracker server**
   - 作用是`负载均衡和任务调度`，通过 Tracker server 在文件上传时可以根据一些策略找到 Storage server 提供文件上传服务。可以将 tracker 称为追踪服务器或调度服务器。
2. **Storage server**
   - 作用是`文件存储`，客户端上传的文件最终存储在 Storage 服务器上，Storage server 没有实现自己的文件系统而是利用操作系统 的文件系统来管理文件。可以将storage称为存储服务器。

**理解**:Fastdfs是一个分布式文件管理系统,是一种以负载均衡、冗余备份、线性扩容等机制的服务器集群,既然是集群那么也意味着是一种主从复制的结构,主机负责上传从机负责读这样极大的提高了程序的性能问题,因为一般读的时间大于写的时间,Fastdfs主要以`Trackert server`和`Storage server`,前者主要来接收文件上传根据相关策略来决定使用哪一个服务器进行存储,这也是一种负载均衡的机制!而Storage Server主要以存储为主,简单的可以理解为:前者来决定上传到哪一个服务器是一个决定者,而后者是负责存储的,

### 1.1 架构

![image-20211029155647214](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211029155647214.png)

服务端两个角色:

- Tracker：`管理集群`，tracker 也可以实现集群。每个 tracker 节点地位平等。收集 Storage 集群的状态。
- Storage：`实际保存文件`  Storage 分为多个组，每个组之间保存的文件是不同的。每个组内部可以有多个成员，组成员内部保存的内容是一样的，组成员的地位是一致的，没有主从的概念

相关地址:

- 官方网站：https://github.com/happyfish100/
- 配置文档：https://github.com/happyfish100/fastdfs/wiki/
- 参考资料：https://www.oschina.net/question/tag/fastdfs
- Java客户端：https://github.com/happyfish100/fastdfs-client-java

### 1.2 上传流程

![image-20211029155832268](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211029155832268.png)

客户端上传文件后存储服务器将文件 ID 返回给客户端，此文件 ID 用于以后访问该文件的索引信息。文件索引信息包括：组名，虚拟磁盘路径，数据两级目录，文件名。

![image-20211029160000116](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211029160000116.png)

其中：

- 组名（卷）：文件上传后所在的 storage 组名称，在文件上传成功后有 storage 服务器返回，需要客户端自行保存。
- 虚拟磁盘路径：storage 配置的虚拟路径，与磁盘选项 store_path*对应。如果配置了 store_path0 则是 M00，如果配置了 store_path1 则是 M01，以此类推
- 数据两极目录：storage 服务器在每个虚拟磁盘路径下创建的两级目录，用于存储数据文件。
- 文件名：与文件上传时不同。是由存储服务器根据特定信息生成，文件名包含：源存储服务器 IP 地址、文件创建时间戳、文件大小、随机数和文件拓展名等信息。

### 1.3 使用：

这是maven：

```xml
<!--fastdfs分布式文件管理系统-->
        <dependency>
            <groupId>cn.bestwu</groupId>
            <artifactId>fastdfs-client-java</artifactId>
            <version>1.27</version>
        </dependency>
```

添加配置文件fdfs_client.conf ，将其中的服务器地址设置为192.168.25.133

```c#
tracker_server=47.95.117.210:22122
```

这是封装的工具类:

```java
package cn.miao.basic.util;

import org.csource.common.NameValuePair;
import org.csource.fastdfs.*;

import java.net.URL;

/**
 * @program: backstageProject
 * @description: fastDfs工具类
 * @author: MiaoWei
 * @create: 2021-10-27 20:16
 **/
public class FastDfsUtil {
    private static final String CONF_FILENAME = "F:\\源码时代\\学习项目\\twoPoject\\backstageProject\\src\\main\\resources\\fdfs_client.conf";
    //从classpath
//    public static String CONF_FILENAME = FastDfsUtil.class.getClassLoader()
//            .getResource("fdfs_client.conf").getFile();


    public static void main(String[] args) {
        URL resource = FastDfsUtil.class.getClassLoader()
                .getResource("fdfs_client.conf");
        String resourceFile = resource.getFile();
        System.out.println("resourceFile = " + resourceFile);
    }
    /**
     * 上传文件
     *
     * @param file
     * @param extName
     * @return
     */
    public static String upload(byte[] file, String extName) {

        try {

            ClientGlobal.init(CONF_FILENAME);

            TrackerClient tracker = new TrackerClient();
            TrackerServer trackerServer = tracker.getConnection();
            StorageServer storageServer = null;

            StorageClient storageClient = new StorageClient(trackerServer, storageServer);
            NameValuePair[] nvp = new NameValuePair[]{
                    new NameValuePair("age", "18"),
                    new NameValuePair("sex", "male")
            };
            String[] fileIds = storageClient.upload_file(file, extName, nvp);

//            System.out.println(fileIds.length);
//            System.out.println("组名：" + fileIds[0]); // group1
//            System.out.println("路径: " + fileIds[1]); // saldfj/sdfas/sdaf.jpg
            return "/" + fileIds[0] + "/" + fileIds[1];

        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    /**
     * 上传文件
     *
     * @param extName
     * @return
     */
    public static String upload(String path, String extName) {

        try {
            ClientGlobal.init(CONF_FILENAME);

            TrackerClient tracker = new TrackerClient();
            TrackerServer trackerServer = tracker.getConnection();
            StorageServer storageServer = null;
            StorageClient storageClient = new StorageClient(trackerServer, storageServer);
            String fileIds[] = storageClient.upload_file(path, extName, null);

//            System.out.println(fileIds.length);
//            System.out.println("组名：" + fileIds[0]);
//            System.out.println("路径: " + fileIds[1]);
            return "/" + fileIds[0] + "/" + fileIds[1];

        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    /**
     * 下载文件
     *
     * @param groupName
     * @param fileName
     * @return
     */
    public static byte[] download(String groupName, String fileName) {
        try {

            ClientGlobal.init(CONF_FILENAME);

            TrackerClient tracker = new TrackerClient();
            TrackerServer trackerServer = tracker.getConnection();
            StorageServer storageServer = null;

            StorageClient storageClient = new StorageClient(trackerServer, storageServer);
            byte[] b = storageClient.download_file(groupName, fileName);
            return b;
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }


    /**
     * 删除文件
     *
     * @param groupName
     * @param fileName
     */
    public static void delete(String groupName, String fileName) {
        try {
            ClientGlobal.init(CONF_FILENAME);

            TrackerClient tracker = new TrackerClient();
            TrackerServer trackerServer = tracker.getConnection();
            StorageServer storageServer = null;

            StorageClient storageClient = new StorageClient(trackerServer,
                    storageServer);
            int i = storageClient.delete_file(groupName, fileName);
            System.out.println(i == 0 ? "删除成功" : "删除失败:" + i);
        } catch (Exception e) {
            e.printStackTrace();
            throw new RuntimeException("删除异常," + e.getMessage());
        }
    }
}
```

浏览器访问的是:[http://122.51.119.246:8888/group1/M00/00/00/wKgZhVkMP4KAZEy-AAA-tCf93Fo973.jpg](http://192.168.25.133/group1/M00/00/00/wKgZhVkMP4KAZEy-AAA-tCf93Fo973.jpg)

>  上传用22122端口
>
>  访问用8888端口



## 2.前端服务器

我们之前的前端使用的vue脚手架搭建起来的,所以可以使用npm run dev进行启动服务,而如果是纯HTML那么我们该如何去启动呢?如何方便我们调试呢?

```properties
# 安装
npm install -g live-server
# 启动,指定端口
live-server --port=80  
```

这种呢就是把当前路径下的web资源当做一个服务的内容启动起来，并可以指定端口

![image-20211029180035016](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211029180035016.png)

## 3.三方登录

三方登录顾名思义就是使用第三方主流平台如:微信、QQ、支付宝等等;这样的好处就是免于我们繁杂的注册流程!

> 三方登录协议-OAuth2.0

`OAUTH协议为用户资源的授权提供了一个安全的、开放而又简易的标准`。与以往的授权方式不同之处是`OAUTH的授权不会使第三方触及到用户的帐号信息（如用户名与密码）`,即第三方无需使用用户的用户名与密码就可以申请获得该用户资源的授权，因此OAUTH是安全的。oAuth是Open Authorization的简写，目前的版本是2.0版。

![img](https://gitee.com/miawei/pic-go-img/raw/master/imgs/wpsB55A.tmp.jpg)

这是官网地址:https://oauth.net/2/

理解:使用这种协议的好处就是不会去触及第三方用户的隐私性信息,如:密码等隐私性较高的东西!只会进行授权的操作拿到一些我们能够看见的东西

> OAuth的思路

​	OAuth在"客户端"与"服务提供商"之间，设置了一个`授权层`（authorization layer）。"客户端"不能直接登录"服务提供商"，只能登录授权层，以此将用户与客户端区分开来。"客户端"登录授权层使用的是令牌（token），与用户的密码不同。用户可以在登录的时候，指定令牌的权限范围和有效期。

"客户端"登录授权层以后，"服务提供商"根据令牌的权限范围和有效期，向"客户端"开放用户储存的资料。

> 运行流程

![image-20211101154816858](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211101154816858.png)

步骤:

1. A: 用户打开客户端以后,客户端要求用户给予授权;
2. B: 用户同意给予客户端授权
3. C: 客户端使用上一步获取的授权,向认证服务器申请令牌,
4. D: 认证服务器对客户端进行认证以后,确认无误,同意发放令牌
5. E: 客户端使用令牌,向资源服务器申请获取资源
6. F: 资源服务器确认令牌无误,同意向客户端开放资源;

其实总的来说`token`是一个关键的东西,结合OAuth的思路来进行思考:客户端会首先发起一个授权界面,一旦用户同意了授权那么就可以申请获取token令牌,拿到token令牌以后就表示登录到客户端与服务提供商之间的`授权层`,而到了这一层,我们就可以根据令牌向服务提供商申请想要的资源,如:用户个人信息,服务提供商拿到这个令牌确认可以就开放对应的资源!

其实再缩减就是这三个步骤:**用户授权**、**获取令牌**、**访问受限资源**

**注意**：在上述六个步骤中，B是关键，因为用户无论怎样只要给客户端授权，客户端才能根据这个授权去获取令牌，进而凭借令牌来获取资源！



**结合自己业务中登录的流程的理解**：首先当用户点击微信登录按钮此时会发起一个链接请求到第三方服务提供商，服务提供商会根据请求过来的qppid返回一个授权二维码，然后用户扫码进行选择是否授权，而如果用户一旦授权那么第三方服务提供商进行重定向到本机项目中的回调页面然后返回一个授权码；此时我们拿到授权码后发起后端请求携带授权码到后端进行进一步的操作，在后端里通过携带过来的授权码和appid和struct向服务器申请令牌(token),然后第三方提供商就会对客户端携带的数据进行认证待确认无误后就会发放令牌token,而我们拿到token此时就已经进入到OAuth中定义的客户端与服务端之间的"授权层",在授权层里我们根据收到的令牌向服务器申请相关资源,而我们在后台服务器里通过拿到token(令牌)我们就能获取到用户的个人信息!然后进行相关的业务操作!

当获取到token之后,同时拿到oppenid,我们要知道oppenid是唯一的凭证所以就可以先去微信用户表中查询是否存在该用户,存在判断是否绑定用户id,如果都满足,直接免密登录将用户个人信息放入redis缓存中,而如果获取不到数据那么就会把token令牌和oppenid携带返回给前端,前端拿到之后跳转到绑定手机号界面,通过将手机号和token令牌和oppenid一起携带到后端接口,进行对数据库表的新增!



> 客户端授权-授权码模式

客户端必须得到用户的授权，才能获取令牌，那么OAuth定义了四种授权方式：

- 授权码模式
- 简化模式
  - 拿到授权二维码就可以直接放行
- 密码模式
  - 在获取的资源那里设置密码,所以不需要拿到授权和token就可以直接进入
- 客户端模式
  - 直接进我们想要的资源,根本不需要token和授权

这里主要介绍第一种方式:`授权码模式`

​	`授权模式是功能最完整、流程最严密的授权模式`,它的特点就是通过客户端的后台服务器与"服务提供商"的认证服务器进行互动,来看下一张图:

![image-20211101162020098](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211101162020098.png)

流程:

A: 用户访问客户端,后者将前者导向认证服务器

B: 用户选择是否给予客户端授权

C: 假设用户给予授权,认证服务器将用户导向客户端实线指定的：“重定向URI”，同时附上一个授权码

D：客户端收到授权码，附上早先的"重定向URI",向认证服务器申请令牌。这一步是在客户端的后台服务器上完成的，对用户不可见。

E：认证服务器核对了授权码和重定向URI，确认无误后，向客户端发送访问令牌（access_token）和更新令牌(refresh_token)

> 网站微信登录原理

这是官方给出的文档:https://developers.weixin.qq.com/doc/oplatform/Mobile_App/WeChat_Login/Development_Guide.html

这是一个过程:

![image-20211101163030290](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211101163030290.png)

> 核心代码实现:

步骤:

1. 用户点击第三方微信登录按钮,获取code授权码

   ```html
   <li><a href="https://open.weixin.qq.com/connect/qrconnect?appid=wxd853562a0548a7d0&redirect_uri=http://bugtracker.itsource.cn/callback.html&response_type=code&scope=snsapi_login&state=3#wechat_redirect"><i class="am-icon-weixin am-icon-sm"></i><span>微信登录</span> </a></li>
   ```

   ![image-20211101163547412](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211101163547412.png)

   ​	其中`redirect_uri`表示的重定向的地址,微信第三方通过appid会返回一个授权二维码,需要用户扫码进行确认是否进行授权操作!

2. 跳转到重定向页面,此时http地址后跟着指定参数`code`,表示我们已经拿到了授权码了

   ```javascript
   mounted() {
       //注:本页面是回调页面,也就是说在login页面发起微信登录然后通过参数appid或回调重定向页面到本页面
       //回调到本页面会带1个参数: code授权码
       //解析参数上
       let url = location.href; // http://bugtracker.itsource.cn/callback.html?code=051p2m100kZ6GM1ge7100yhviD4p2m1m&state=3
   
       //  根据url生成对象
       let paramObj = parseUrlParams2Obj(url);
   
       //   let binderUrl="http://bugtracker.itsource.cn/binder.html";
       //封装请求参数
       let param = {"code": paramObj.code};
       // 发送请求
       this.$http.post("/user/wechat", param)
           .then(result => {
           //200表示免密登录成功
           if (result.data.code===200) {
               // 把用户信心保存到localStorage
               // alert("登录成功");
               //1.将token和登录信息存入localStorage
               let {token, loginfo} = result.data.data;
               localStorage.setItem("token", token);
               localStorage.setItem("loginInfo", JSON.stringify(loginfo));
               //2.跳转到首页，并显示登录信息
               location.href = "index.html";
           }else if(result.data.code===204){
               //其他信息表示是第一次登录那么应跳转到绑定页面
               //1.获取的openID和access_token放入localStorage
               let {access_token,openid} = result.data.data;
               localStorage.setItem("openid",openid );
               localStorage.setItem("access_token", access_token);
               //2.跳转到绑定界面
               location.href = "binder.html";
           }
       }) 
     }
   ```

3. 发起异步请求,将获取的授权码(code)通过后端服务器进行发起get请求获取到token令牌,登录到授权层

   ```java
   String WXCHAT_TOKEN_BY_CODE = "https://api.weixin.qq.com/sns/oauth2/access_token?appid={}&secret={}&code={}&grant_type=authorization_code";
   private String appid=wxd853562a0548a7d0;
   private String secret=4a5d5615f93f24bdba2ba8534642dbb6;
   
   @Override
   public AjaxResult loginWeChat(Map<String, String> map) {
       String response = HttpUtil.get(CharSequenceUtil.format(WXCHAT_TOKEN_BY_CODE, appid, secret, code));
   	...
        //其他业务   
   }
   
   ```

   在官方也有阐释:

   ![image-20211101164722343](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211101164722343.png)

   通过这个我们就可以获取到token,就可以进入OAuth思路中客户端和服务提供商之间的"授权层",通过这个授权层我们就可以拿到我想要的对应的资源

4. 通过token令牌我们可以获取到指定的用户信息:

   ```java
   /**
   	* 微信获取用户个人信息
   */
   String WXCHAT_ACCESS_TOKEN = "https://api.weixin.qq.com/sns/userinfo?access_token={}&openid={}";
   
   public AjaxResult binderWxChat(BinderWeChatDto dto) {
       //这里token和openid都是上面获取到的
       String response = HttpUtil.get(CharSequenceUtil.format(WXCHAT_ACCESS_TOKEN, dto.getAccessToken(), dto.getOpenId())); 
   }
   ```

   官方这里简述:

   ![image-20211101165253027](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211101165253027.png)

> 总的流程就是这样,就没有了

其实使用微信三方登录无非就三步:

1. 发起链接地址出现授权二维码让用户进行授权操作
2. 授权成功重定向指定页面拿到授权码code
3. 发起请求到后端服务器通过code获取到token
4. 通过token获取到用户个人信息!

> 注意:因为这个第三方登录需要300人民币才有资获取,所以这是使用源码的,而源码在注册的时候绑定了端口为80,所以我们必须也要启动端口为80,并且重定向是从服务器商进行重定向,所以我们的项目映射为公网才可以,因为是微信平台进行重定向所以我们需要将本地IP转为域名的方式,才能找得到!如果不改的话那么我们重定向12.0.0.1就会重定向到第三方平台的本机!

我们可以将当前ip进行封装为公网地址,在hosts文件修改:

![image-20211101171503950](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211101171503950.png)

![image-20211101171605627](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211101171605627.png)

## 4. Vue-Quill-Editor 富文本编辑器

在Vue页面中嵌套一个富文本编辑器使用:

效果图:

![image-20211104143637391](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211104143637391.png)

这是对应的CSDN详细解释:https://blog.csdn.net/senmage/article/details/82388728

安装npm依赖

```nginx
npm install vue-quill-editor --save
npm install quill --save
```

使用:

```javascript
/*引入富文本编辑器 + 它的样式*/
import {quillEditor} from "vue-quill-editor"; //调用编辑器
import 'quill/dist/quill.core.css';
import 'quill/dist/quill.snow.css';
import 'quill/dist/quill.bubble.css';
/*引入富文本编辑器集成FastDfsjs控件,不集成的话图片会使用base64进行转码,会非常庞大!*/
import quillConfig from '../../common/js/quill-config.js'


export default {
  components: {
    quillEditor
  },
    data() {
        return {
            quillOption: quillConfig  //默认为null,这是改为fastdfs控件,是方便文件的回显和上传
            ...
        }
    }
}
```

这是页面:

```javascript
<quill-editor v-model="editForm.detail.intro" :options="quillOption"></quill-editor>
```

这是quill-config.js:

```js
/*富文本编辑图片上传配置*/
const uploadConfig = {
    fastDfsUrl:'http://47.95.117.210:8888',  //  查看路径
    action:  'http://localhost:8080/fastDfs/upload',  // 必填参数 图片上传地址
    methods: 'POST',  // 必填参数 图片上传方式
    token: '',  // 可选参数 如果需要token验证，假设你的token有存放在sessionStorage
    name: 'file',  // 必填参数 文件的参数名
    size: 500,  // 可选参数   图片大小，单位为Kb, 1M = 1024Kb
    accept: 'image/png, image/gif, image/jpeg, image/bmp, image/x-icon'  // 可选 可上传的图片格式
};

// toolbar工具栏的工具选项（默认展示全部）
const toolOptions = [
    ['bold', 'italic', 'underline', 'strike'],
    ['blockquote', 'code-block'],
    [{'header': 1}, {'header': 2}],
    [{'list': 'ordered'}, {'list': 'bullet'}],
    [{'script': 'sub'}, {'script': 'super'}],
    [{'indent': '-1'}, {'indent': '+1'}],
    [{'direction': 'rtl'}],
    [{'size': ['small', false, 'large', 'huge']}],
    [{'header': [1, 2, 3, 4, 5, 6, false]}],
    [{'color': []}, {'background': []}],
    [{'font': []}],
    [{'align': []}],
    ['clean'],
    ['link', 'image', 'video']
];
const handlers = {
    image: function image() {
        var self = this;
        var fileInput = this.container.querySelector('input.ql-image[type=file]');
        if (fileInput === null) {
            fileInput = document.createElement('input');
            fileInput.setAttribute('type', 'file');
            // 设置图片参数名
            if (uploadConfig.name) {
                fileInput.setAttribute('name', uploadConfig.name);
            }
            // 可设置上传图片的格式
            fileInput.setAttribute('accept', uploadConfig.accept);
            fileInput.classList.add('ql-image');
            // 监听选择文件
            fileInput.addEventListener('change', function () {
                // 创建formData
                var formData = new FormData();
                formData.append(uploadConfig.name, fileInput.files[0]);
                formData.append('object','product');
                // 如果需要token且存在token
                if (uploadConfig.token) {
                    formData.append('token', uploadConfig.token)
                }
                // 图片上传
                var xhr = new XMLHttpRequest();
                xhr.open(uploadConfig.methods, uploadConfig.action, true);
                // 上传数据成功，会触发
                xhr.onload = function (e) {
                    if (xhr.status === 200) {
                        var res = JSON.parse(xhr.responseText);
                        let length = self.quill.getSelection(true).index;
                        //这里很重要，你图片上传成功后，img的src需要在这里添加，res.path就是你服务器返回的图片链接。
                        self.quill.insertEmbed(length, 'image', uploadConfig.fastDfsUrl+res.msg);   //这里注意要修改
                        self.quill.setSelection(length + 1)
                    }
                    fileInput.value = ''
                };
                // 开始上传数据
                xhr.upload.onloadstart = function (e) {
                    fileInput.value = ''
                };
                // 当发生网络异常的时候会触发，如果上传数据的过程还未结束
                xhr.upload.onerror = function (e) {
                };
                // 上传数据完成（成功或者失败）时会触发
                xhr.upload.onloadend = function (e) {
                    // console.log('上传结束')
                };
                xhr.send(formData)
            });
            this.container.appendChild(fileInput);
        }
        fileInput.click();
    }
};

export default {
    placeholder: '',
    theme: 'snow',  // 主题
    modules: {
        toolbar: {
            container: toolOptions,  // 工具栏选项
            handlers: handlers  // 事件重写
        }
    }
};
```

## 5. 集成百度地图

我们可以在页面上进行内嵌百度地图,这样我们可以输入关键字就可以获取地图相关信息之类的;

首先要获取百度地图第三方的key:

http://lbsyun.baidu.com/

![image-20211104144820105](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211104144820105.png)

这是DEMO:https://lbsyun.baidu.com/jsdemo.htm#a6_2,可以参考这个demo

根据这个demo我们可以直接放入到我们想要内嵌地图的页面,要记住要放入我们刚刚注册的AK;

当然我这里直接放AK的链接:https://lbsyun.baidu.com/apiconsole/key#/home

然后这里记录一个工具类:用于解析地址计算距离用户最近的商家

1. 可以根据地址获取对应的坐标
2. 根据很多地址来获取相对于自己较近的一个地址

**注**:当然我认为这个地址距离我认为是可以通过redis的geo来处理!

```java
package cn.miao.common.util;


import cn.hutool.core.collection.CollUtil;
import cn.miao.common.exception.MiaoRuntimeException;
import cn.miao.project.domain.Point;
import cn.miao.project.domain.domain.Shop;

import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;
import java.util.List;

/**
 * 位置相关工具类
 *
 * @author MiaoDaWei
 */
@SuppressWarnings("all")
public class DistanceUtil {
    /**
     * 百度程序应用程序的AK
     */
    private static final String APPLICATION_KEY = "ki7G2ODhCwdPNN1pf92rhEYQsV2Rj7CQ";
    //地球半径,进行经纬度运算需要用到的数据之一
    private static final double EARTH_RADIUS = 6378137;

    public static Point getPoint(String address) {
//        String Application_ID="PQ9FAt6qg7taDWj6LLABYO7u6bSETXhD";//配置上自己的百度地图应用的AK
        try {
            String sCurrentLine = "";
            String sTotalString = "";
            InputStream urlStream;
            //https://lbsyun.baidu.com/index.php?title=webapi/guide/webservice-geocoding 这是官方文档
            URL url = new URL("http://api.map.baidu.com/geocoding/v3/?address=" + address + "&output=json&ak=" + APPLICATION_KEY + "&callback=showLocation");
            HttpURLConnection connection = (HttpURLConnection) url.openConnection();
            connection.connect();
            urlStream = connection.getInputStream();
            BufferedReader reader = new BufferedReader(new InputStreamReader(urlStream));
            String str = reader.readLine();
//            System.out.println(str);
            //用经度分割返回的网页代码
            String s = "," + "\"" + "lat" + "\"" + ":";
            String[] strs = str.split(s, 2);
            String s1 = "\"" + "lng" + "\"" + ":";
            String[] a = strs[0].split(s1, 2);
            s1 = "}" + "," + "\"";
            String[] a1 = strs[1].split(s1, 2);

            Point point = new Point();
            point.setLng(Double.valueOf(a[1]));
            point.setLat(Double.valueOf(a1[0]));
            return point;
        } catch (Exception e) {
            e.printStackTrace();
            throw new MiaoRuntimeException("获取地址位置信息失败!请输入正确的地理位置坐标");
        }
    }

    //根据坐标点获取弧度
    private static double rad(double d) {
        return d * Math.PI / 180.0;
    }

    /**
     * 根据两点间经纬度坐标（double值），计算两点间距离，单位为米
     *
     * @param point1 A点坐标
     * @param point2 B点坐标
     * @return
     */
    public static double getDistance(Point point1, Point point2) {
        double radLat1 = rad(point1.getLat());
        double radLat2 = rad(point2.getLat());
        double a = radLat1 - radLat2;
        double b = rad(point1.getLng()) - rad(point2.getLng());
        double s = 2 * Math.asin(Math.sqrt(Math.pow(Math.sin(a / 2), 2) +
                Math.cos(radLat1) * Math.cos(radLat2) * Math.pow(Math.sin(b / 2), 2)));
        s = s * EARTH_RADIUS;
        s = Math.round(s * 10000) / 10000;
        return s;
    }

    /**
     * 根据两点间经纬度坐标（double值），计算两点间距离，单位为米
     *
     * @param point 用户指定的地址坐标
     * @param shops 商店
     * @return
     */
    public static Shop getNearestShop(Point point, List<Shop> shops) {
        if (CollUtil.isEmpty(shops)) {
            throw new MiaoRuntimeException("暂无店铺进行处理");
        }
        //如果传过来的集合只有一家店铺,那么直接将这家店铺的信息返回就是最近的店铺了
        Shop shop = shops.get(0);
        //获取集合中第一家店铺到指定地点的距离
        double distance = getDistance(point, getPoint(shops.get(0).getAddress()));
        //如果有多家店铺,那么就和第一家店铺到指定地点的距离做比较
        if (shops.size() > 1) {
            for (int i = 1; i < shops.size(); i++) {
                if (getDistance(point, getPoint(shops.get(i).getAddress())) < distance) {
                    shop = shops.get(i);
                }
            }
        }
        return shop;
    }

//    public static void main(String[] args) {
//        System.out.println(getPoint("成都市武侯区天府新谷-10号楼"));
//    }
}
```

## 6. 订单流程(三方支付-支付宝)

### 6.1 订单流程

这是一个大概的流程图:

![1620963078374](https://gitee.com/miawei/pic-go-img/raw/master/imgs/1620963078374.png)

业务流程:

​	首先商家上架宠物,然后用户在宠物列表进行选购,通过商品的详情页面进行一个购买下单的操作,而在后台通过下单的请求参数进行相关的保存订单信息!

### 6.2 三方支付的原理

这是一个总的支付流程:

![image-20211106163442703](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211106163442703.png)

**理解**:用户通过订单详情页点击立即购买,这时就会立即发起一个下单请求到后台去,后台接收请求参数进行下单的保存并冻结相关的相关商品。同时将需要第三方支付需要的流水参数所在的支付单的表也进行一个保存，然后操作成功后就会返回一个支付单号，前台页面返回收到操作成功的标志后就会发起一个支付的申请，后台会根据刚刚保存的支付单进行向第三方支付接口进行发起支付，等待支付成功后，就会有两个回调结果，第一个回调是异步回调，这步是将调用后台接口进行支付结果进行相关业务的处理，如：修改订单的状态和保存支付的流水等等。同时还要一个同步回调，这个同步回调是第三方支付是支付结束后重定向到我们刚刚支付的页面，用于告诉客户端用户已经支付成功了！

注意:其实可以将保存订单放在支付业务那里去操作,但是为了一个分离服务更具有独立性的概念思想,因为支付有不同的场景,每个场景保存订单的参数都是可能不一样的,所以这里就将其抽出来,在支付业务中只需要获取订单号进行查询就可以发起第三方支付,这种要更具有健壮性!

> 要注意无论支付成功还是失败，都有两次回调，一次异步一次同步

支付场景：

- 下单支付【用户 -> 平台】：普通用户购买某产品，在线支付 ： 用户账户(银行，支付宝，微信) -> 平台账户
- 账户充值【用户 -> 平台】：普通用户在平台充值，把银行卡,支付宝，微信中的只是金额充值到平台账户中(虚拟账户，在平台只是一个数字而已)
- 账户提现【平台 -> 用户】：普通用户要把平台账户余额中的钱提取到银行卡，支付宝，微信 ，发起提现申请

支付理解：

![1620992844833](https://gitee.com/miawei/pic-go-img/raw/master/imgs/1620992844833.png)

**理解**：初期最早支付是银行才有的权利后面将支付的权利进行挂牌售卖，但所需金钱过于庞大所以一般很少有公司能买得起但是像支付宝微信这些有实力进行购买了这种支付牌照就可以通过支付去直接将银行用户账户的钱进行操作，但是现在是有价无市并且我们平台无法直接对接银行进行转账的操作，所以我们需要通过这些第三方支付提供的接口进行相关的支付操作，那么这第三方支付网关是如何进行转账的操作的呢？首先商家需要在第三方支付上开通一个账户，用户呢也需要登录到第三方支付的账户上，这样就同时有商家和用户的账户，当用户进行扫码付款的时候，钱就会直接转账到商家的账户上，但同时也有另外一种模式就是钱会先扫给平台，然后由平台赚差价再转商家账户上！但是要注意转账是要通过第三方支付网关对接银行进行转账的操作，通过银行的操作的回调结果是成功还是失败决定了平台用户的支付结果，并且也要记住这个转账操作是具有原子性的！

> 理解的核心点就是三方支付就是我们对接银行的中间商,我们支付需要商家和用户登录三方支付平台账户才能有权进行转账操作!
