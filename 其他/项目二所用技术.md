# 使用到的技术

## 1. 图片上传-fastdfs

首先这是一个分布式文件系统

![image-20211027225924233](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/imgs/image-20211027225924233.png)

```
为什么需要分布式文件系统:

在使用Fastdfs之前的单体上传文件缺点:
	1. 图片上传和其他crud请求都在一个服务器进行处理,这样服务器压力会比较大
	2. 不能在集群环境中使用,每一个服务器磁盘都是独立的!
使用fastdfs的优点:
	1.存储量大,因为使用的是分布式集群服务器
	2.单点故障,因为在集群中任何一台服务器出现故障都不会影响整体的运行,效率得到提升

理解:因为在这之前我们服务器使用的是一种单体架构方式,所有请求都是一个服务器处理,图片上传也是上传到本地硬盘中进行存储!而随着项目的不断发展和推进,项目分裂出分布式服务器,那么这个时候文件如果还是用之前的文件上传,那么在集群环境中是不可行的,因为每一个服务器所在的磁盘都是独立的!所以我们需要使用一种分布式文件管理系统进行单独管理上传服务器!

为什么选择fastdfs:
	我们之所以选择它是因为首先它是一种开源的分布式文件系统,它具有高可用、高可靠、负载均衡、冗余备份、线性扩容等特点，它给我的使用感受呢就是存储量大，因为使用单独的服务器集群去管理存储，并且它还是单点故障，也就是说在集群中如果有一台服务器出现了故障那么文件管理系统依然还能运行！那么这就是高可用和高可靠！并且既然是集群那么肯定就是主从复制，主节点负责上传文件而从节点负责文件的读，如果并发量很大的情况下，我们还可以进行线性扩容从节点，这样达到了一个均衡的一个目的！
```

解释:

​	FastDFS 是用 c 语言编写的一款开源的分布式文件系统。FastDFS 为互联网量身定制，充分考虑了`冗余备份`、`负载均衡`、`线性扩容`等机制，并注重高可用、高性能等指标，使用 FastDFS很容易搭建一套`高性能的文件服务器集群`提供文件上传、下载等服务。

​	FastDFS 架构包括 **Tracker server** 和 **Storage server**。客户端请求 Tracker server 进行文件上传、下载，通过 Tracker server 调度最终由 Storage server 完成文件上传和下载。

每个部分的作用:

1. **Tracker server**
   - 作用是`负载均衡和任务调度`，通过 Tracker server 在文件上传时可以根据一些策略找到 Storage server 提供文件上传服务。可以将 tracker 称为追踪服务器或调度服务器。
2. **Storage server**
   - 作用是`文件存储`，客户端上传的文件最终存储在 Storage 服务器上，Storage server 没有实现自己的文件系统而是利用操作系统 的文件系统来管理文件。可以将storage称为存储服务器。

**理解**:Fastdfs是一个分布式文件管理系统,是一种以负载均衡、冗余备份、线性扩容等机制的服务器集群,既然是集群那么也意味着是一种主从复制的结构,主机负责上传从机负责读这样极大的提高了程序的性能问题,因为一般读的时间大于写的时间,Fastdfs主要以`Trackert server`和`Storage server`,前者主要来接收文件上传根据相关策略来决定使用哪一个服务器进行存储,这也是一种负载均衡的机制!而Storage Server主要以存储为主,简单的可以理解为:前者来决定上传到哪一个服务器是一个决定者,而后者是负责存储的,

### 1.1 架构

![image-20211029155647214](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/imgs/image-20211029155647214.png)

服务端两个角色:

- Tracker：`管理集群`，tracker 也可以实现集群。每个 tracker 节点地位平等。收集 Storage 集群的状态。
- Storage：`实际保存文件`  Storage 分为多个组，每个组之间保存的文件是不同的。每个组内部可以有多个成员，组成员内部保存的内容是一样的，组成员的地位是一致的，没有主从的概念

相关地址:

- 官方网站：https://github.com/happyfish100/
- 配置文档：https://github.com/happyfish100/fastdfs/wiki/
- 参考资料：https://www.oschina.net/question/tag/fastdfs
- Java客户端：https://github.com/happyfish100/fastdfs-client-java

### 1.2 上传流程

![image-20211029155832268](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/imgs/image-20211029155832268.png)

客户端上传文件后存储服务器将文件 ID 返回给客户端，此文件 ID 用于以后访问该文件的索引信息。文件索引信息包括：组名，虚拟磁盘路径，数据两级目录，文件名。

![image-20211029160000116](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/imgs/image-20211029160000116.png)

其中：

- 组名（卷）：文件上传后所在的 storage 组名称，在文件上传成功后有 storage 服务器返回，需要客户端自行保存。
- 虚拟磁盘路径：storage 配置的虚拟路径，与磁盘选项 store_path*对应。如果配置了 store_path0 则是 M00，如果配置了 store_path1 则是 M01，以此类推
- 数据两极目录：storage 服务器在每个虚拟磁盘路径下创建的两级目录，用于存储数据文件。
- 文件名：与文件上传时不同。是由存储服务器根据特定信息生成，文件名包含：源存储服务器 IP 地址、文件创建时间戳、文件大小、随机数和文件拓展名等信息。

### 1.3 使用：

这是maven：

```xml
<!--fastdfs分布式文件管理系统-->
        <dependency>
            <groupId>cn.bestwu</groupId>
            <artifactId>fastdfs-client-java</artifactId>
            <version>1.27</version>
        </dependency>
```

添加配置文件fdfs_client.conf ，将其中的服务器地址设置为192.168.25.133

```c#
tracker_server=47.95.117.210:22122
```

这是封装的工具类:

```java
package cn.miao.basic.util;

import org.csource.common.NameValuePair;
import org.csource.fastdfs.*;

import java.net.URL;

/**
 * @program: backstageProject
 * @description: fastDfs工具类
 * @author: MiaoWei
 * @create: 2021-10-27 20:16
 **/
public class FastDfsUtil {
    private static final String CONF_FILENAME = "F:\\源码时代\\学习项目\\twoPoject\\backstageProject\\src\\main\\resources\\fdfs_client.conf";
    //从classpath
//    public static String CONF_FILENAME = FastDfsUtil.class.getClassLoader()
//            .getResource("fdfs_client.conf").getFile();


    public static void main(String[] args) {
        URL resource = FastDfsUtil.class.getClassLoader()
                .getResource("fdfs_client.conf");
        String resourceFile = resource.getFile();
        System.out.println("resourceFile = " + resourceFile);
    }
    /**
     * 上传文件
     *
     * @param file
     * @param extName
     * @return
     */
    public static String upload(byte[] file, String extName) {

        try {

            ClientGlobal.init(CONF_FILENAME);

            TrackerClient tracker = new TrackerClient();
            TrackerServer trackerServer = tracker.getConnection();
            StorageServer storageServer = null;

            StorageClient storageClient = new StorageClient(trackerServer, storageServer);
            NameValuePair[] nvp = new NameValuePair[]{
                    new NameValuePair("age", "18"),
                    new NameValuePair("sex", "male")
            };
            String[] fileIds = storageClient.upload_file(file, extName, nvp);

//            System.out.println(fileIds.length);
//            System.out.println("组名：" + fileIds[0]); // group1
//            System.out.println("路径: " + fileIds[1]); // saldfj/sdfas/sdaf.jpg
            return "/" + fileIds[0] + "/" + fileIds[1];

        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    /**
     * 上传文件
     *
     * @param extName
     * @return
     */
    public static String upload(String path, String extName) {

        try {
            ClientGlobal.init(CONF_FILENAME);

            TrackerClient tracker = new TrackerClient();
            TrackerServer trackerServer = tracker.getConnection();
            StorageServer storageServer = null;
            StorageClient storageClient = new StorageClient(trackerServer, storageServer);
            String fileIds[] = storageClient.upload_file(path, extName, null);

//            System.out.println(fileIds.length);
//            System.out.println("组名：" + fileIds[0]);
//            System.out.println("路径: " + fileIds[1]);
            return "/" + fileIds[0] + "/" + fileIds[1];

        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    /**
     * 下载文件
     *
     * @param groupName
     * @param fileName
     * @return
     */
    public static byte[] download(String groupName, String fileName) {
        try {

            ClientGlobal.init(CONF_FILENAME);

            TrackerClient tracker = new TrackerClient();
            TrackerServer trackerServer = tracker.getConnection();
            StorageServer storageServer = null;

            StorageClient storageClient = new StorageClient(trackerServer, storageServer);
            byte[] b = storageClient.download_file(groupName, fileName);
            return b;
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }


    /**
     * 删除文件
     *
     * @param groupName
     * @param fileName
     */
    public static void delete(String groupName, String fileName) {
        try {
            ClientGlobal.init(CONF_FILENAME);

            TrackerClient tracker = new TrackerClient();
            TrackerServer trackerServer = tracker.getConnection();
            StorageServer storageServer = null;

            StorageClient storageClient = new StorageClient(trackerServer,
                    storageServer);
            int i = storageClient.delete_file(groupName, fileName);
            System.out.println(i == 0 ? "删除成功" : "删除失败:" + i);
        } catch (Exception e) {
            e.printStackTrace();
            throw new RuntimeException("删除异常," + e.getMessage());
        }
    }
}
```

浏览器访问的是:[http://122.51.119.246:8888/group1/M00/00/00/wKgZhVkMP4KAZEy-AAA-tCf93Fo973.jpg](http://192.168.25.133/group1/M00/00/00/wKgZhVkMP4KAZEy-AAA-tCf93Fo973.jpg)

>  上传用22122端口
>
>  访问用8888端口



## 2.前端服务器

我们之前的前端使用的vue脚手架搭建起来的,所以可以使用npm run dev进行启动服务,而如果是纯HTML那么我们该如何去启动呢?如何方便我们调试呢?

```properties
# 安装
npm install -g live-server
# 启动,指定端口
live-server --port=80  
```

这种呢就是把当前路径下的web资源当做一个服务的内容启动起来，并可以指定端口

![image-20211029180035016](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/imgs/image-20211029180035016.png)

## 3.三方登录

三方登录顾名思义就是使用第三方主流平台如:微信、QQ、支付宝等等;这样的好处就是免于我们繁杂的注册流程!

> 三方登录协议-OAuth2.0

`OAUTH协议为用户资源的授权提供了一个安全的、开放而又简易的标准`。与以往的授权方式不同之处是`OAUTH的授权不会使第三方触及到用户的帐号信息（如用户名与密码）`,即第三方无需使用用户的用户名与密码就可以申请获得该用户资源的授权，因此OAUTH是安全的。oAuth是Open Authorization的简写，目前的版本是2.0版。

![img](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/imgs/wpsB55A.tmp.jpg)

这是官网地址:https://oauth.net/2/

理解:使用这种协议的好处就是不会去触及第三方用户的隐私性信息,如:密码等隐私性较高的东西!只会进行授权的操作拿到一些我们能够看见的东西

> OAuth的思路

​	OAuth在"客户端"与"服务提供商"之间，设置了一个`授权层`（authorization layer）。"客户端"不能直接登录"服务提供商"，只能登录授权层，以此将用户与客户端区分开来。"客户端"登录授权层使用的是令牌（token），与用户的密码不同。用户可以在登录的时候，指定令牌的权限范围和有效期。

"客户端"登录授权层以后，"服务提供商"根据令牌的权限范围和有效期，向"客户端"开放用户储存的资料。

> 运行流程

![image-20211101154816858](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/imgs/image-20211101154816858.png)

步骤:

1. A: 用户打开客户端以后,客户端要求用户给予授权;
2. B: 用户同意给予客户端授权
3. C: 客户端使用上一步获取的授权,向认证服务器申请令牌,
4. D: 认证服务器对客户端进行认证以后,确认无误,同意发放令牌
5. E: 客户端使用令牌,向资源服务器申请获取资源
6. F: 资源服务器确认令牌无误,同意向客户端开放资源;

其实总的来说`token`是一个关键的东西,结合OAuth的思路来进行思考:客户端会首先发起一个授权界面,一旦用户同意了授权那么就可以申请获取token令牌,拿到token令牌以后就表示登录到客户端与服务提供商之间的`授权层`,而到了这一层,我们就可以根据令牌向服务提供商申请想要的资源,如:用户个人信息,服务提供商拿到这个令牌确认可以就开放对应的资源!

其实再缩减就是这三个步骤:**用户授权**、**获取令牌**、**访问受限资源**

**注意**：在上述六个步骤中，B是关键，因为用户无论怎样只要给客户端授权，客户端才能根据这个授权去获取令牌，进而凭借令牌来获取资源！



**结合自己业务中登录的流程的理解**：首先当用户点击微信登录按钮此时会发起一个链接请求到第三方服务提供商，服务提供商会根据请求过来的qppid返回一个授权二维码，然后用户扫码进行选择是否授权，而如果用户一旦授权那么第三方服务提供商进行重定向到本机项目中的回调页面然后返回一个授权码（code）；此时我们拿到授权码后发起后端请求携带授权码到后端进行进一步的操作，在后端里通过携带过来的授权码和appid和struct向服务器申请令牌(token),然后第三方提供商就会对客户端携带的数据进行认证待确认无误后就会发放令牌token,而我们拿到token此时就已经进入到OAuth中定义的客户端与服务端之间的"授权层",在授权层里我们根据收到的令牌向服务器申请相关资源,而我们在后台服务器里通过拿到token(令牌)我们就能获取到用户的个人信息!然后进行相关的业务操作!

当获取到token之后,同时拿到oppenid,我们要知道oppenid是唯一的凭证所以就可以先去微信用户表中查询是否存在该用户,存在判断是否绑定用户id,如果都满足,直接免密登录将用户个人信息放入redis缓存中,而如果获取不到数据那么就会把token令牌和oppenid携带返回给前端,前端拿到之后跳转到绑定手机号界面,通过将手机号和token令牌和oppenid一起携带到后端接口,进行对数据库表的新增!



> 客户端授权-授权码模式

客户端必须得到用户的授权，才能获取令牌，那么OAuth定义了四种授权方式：

- 授权码模式
- 简化模式
  - 拿到授权二维码就可以直接放行
- 密码模式
  - 在获取的资源那里设置密码,所以不需要拿到授权和token就可以直接进入
- 客户端模式
  - 直接进我们想要的资源,根本不需要token和授权

这里主要介绍第一种方式:`授权码模式`

​	`授权模式是功能最完整、流程最严密的授权模式`,它的特点就是通过客户端的后台服务器与"服务提供商"的认证服务器进行互动,来看下一张图:

![image-20211101162020098](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/imgs/image-20211101162020098.png)

流程:

A: 用户访问客户端,后者将前者导向认证服务器

B: 用户选择是否给予客户端授权

C: 假设用户给予授权,认证服务器将用户导向客户端实线指定的：“重定向URI”，同时附上一个授权码

D：客户端收到授权码，附上早先的"重定向URI",向认证服务器申请令牌。这一步是在客户端的后台服务器上完成的，对用户不可见。

E：认证服务器核对了授权码和重定向URI，确认无误后，向客户端发送访问令牌（access_token）和更新令牌(refresh_token)

> 网站微信登录原理

这是官方给出的文档:https://developers.weixin.qq.com/doc/oplatform/Mobile_App/WeChat_Login/Development_Guide.html

这是一个过程:

![image-20211101163030290](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/imgs/image-20211101163030290.png)

> 核心代码实现:

步骤:

1. 用户点击第三方微信登录按钮,获取code授权码

   ```html
   <li><a href="https://open.weixin.qq.com/connect/qrconnect?appid=wxd853562a0548a7d0&redirect_uri=http://bugtracker.itsource.cn/callback.html&response_type=code&scope=snsapi_login&state=3#wechat_redirect"><i class="am-icon-weixin am-icon-sm"></i><span>微信登录</span> </a></li>
   ```

   ![image-20211101163547412](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/imgs/image-20211101163547412.png)

   ​	其中`redirect_uri`表示的重定向的地址,微信第三方通过appid会返回一个授权二维码,需要用户扫码进行确认是否进行授权操作!

2. 跳转到重定向页面,此时http地址后跟着指定参数`code`,表示我们已经拿到了授权码了

   ```javascript
   mounted() {
       //注:本页面是回调页面,也就是说在login页面发起微信登录然后通过参数appid或回调重定向页面到本页面
       //回调到本页面会带1个参数: code授权码
       //解析参数上
       let url = location.href; // http://bugtracker.itsource.cn/callback.html?code=051p2m100kZ6GM1ge7100yhviD4p2m1m&state=3
   
       //  根据url生成对象
       let paramObj = parseUrlParams2Obj(url);
   
       //   let binderUrl="http://bugtracker.itsource.cn/binder.html";
       //封装请求参数
       let param = {"code": paramObj.code};
       // 发送请求
       this.$http.post("/user/wechat", param)
           .then(result => {
           //200表示免密登录成功
           if (result.data.code===200) {
               // 把用户信心保存到localStorage
               // alert("登录成功");
               //1.将token和登录信息存入localStorage
               let {token, loginfo} = result.data.data;
               localStorage.setItem("token", token);
               localStorage.setItem("loginInfo", JSON.stringify(loginfo));
               //2.跳转到首页，并显示登录信息
               location.href = "index.html";
           }else if(result.data.code===204){
               //其他信息表示是第一次登录那么应跳转到绑定页面
               //1.获取的openID和access_token放入localStorage
               let {access_token,openid} = result.data.data;
               localStorage.setItem("openid",openid );
               localStorage.setItem("access_token", access_token);
               //2.跳转到绑定界面
               location.href = "binder.html";
           }
       }) 
     }
   ```

3. 发起异步请求,将获取的授权码(code)通过后端服务器进行发起get请求获取到token令牌,登录到授权层

   ```java
   String WXCHAT_TOKEN_BY_CODE = "https://api.weixin.qq.com/sns/oauth2/access_token?appid={}&secret={}&code={}&grant_type=authorization_code";
   private String appid=wxd853562a0548a7d0;
   private String secret=4a5d5615f93f24bdba2ba8534642dbb6;
   
   @Override
   public AjaxResult loginWeChat(Map<String, String> map) {
       String response = HttpUtil.get(CharSequenceUtil.format(WXCHAT_TOKEN_BY_CODE, appid, secret, code));
   	...
        //其他业务   
   }
   
   ```

   在官方也有阐释:

   ![image-20211101164722343](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/imgs/image-20211101164722343.png)

   通过这个我们就可以获取到token,就可以进入OAuth思路中客户端和服务提供商之间的"授权层",通过这个授权层我们就可以拿到我想要的对应的资源

4. 通过token令牌我们可以获取到指定的用户信息:

   ```java
   /**
   	* 微信获取用户个人信息
   */
   String WXCHAT_ACCESS_TOKEN = "https://api.weixin.qq.com/sns/userinfo?access_token={}&openid={}";
   
   public AjaxResult binderWxChat(BinderWeChatDto dto) {
       //这里token和openid都是上面获取到的
       String response = HttpUtil.get(CharSequenceUtil.format(WXCHAT_ACCESS_TOKEN, dto.getAccessToken(), dto.getOpenId())); 
   }
   ```

   官方这里简述:

   ![image-20211101165253027](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/imgs/image-20211101165253027.png)

> 总的流程就是这样,就没有了

其实使用微信三方登录无非就三步:

1. 发起链接地址出现授权二维码让用户进行授权操作
2. 授权成功重定向指定页面拿到授权码code
3. 发起请求到后端服务器通过code获取到token
4. 通过token获取到用户个人信息!

> 注意:因为这个第三方登录需要300人民币才有资获取,所以这是使用源码的,而源码在注册的时候绑定了端口为80,所以我们必须也要启动端口为80,并且重定向是从服务器商进行重定向,所以我们的项目映射为公网才可以,因为是微信平台进行重定向所以我们需要将本地IP转为域名的方式,才能找得到!如果不改的话那么我们重定向12.0.0.1就会重定向到第三方平台的本机!

我们可以将当前ip进行封装为公网地址,在hosts文件修改:

![image-20211101171503950](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/imgs/image-20211101171503950.png)

![image-20211101171605627](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/imgs/image-20211101171605627.png)

## 4. Vue-Quill-Editor 富文本编辑器

在Vue页面中嵌套一个富文本编辑器使用:

效果图:

![image-20211104143637391](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/imgs/image-20211104143637391.png)

这是对应的CSDN详细解释:https://blog.csdn.net/senmage/article/details/82388728

安装npm依赖

```nginx
npm install vue-quill-editor --save
npm install quill --save
```

使用:

```javascript
/*引入富文本编辑器 + 它的样式*/
import {quillEditor} from "vue-quill-editor"; //调用编辑器
import 'quill/dist/quill.core.css';
import 'quill/dist/quill.snow.css';
import 'quill/dist/quill.bubble.css';
/*引入富文本编辑器集成FastDfsjs控件,不集成的话图片会使用base64进行转码,会非常庞大!*/
import quillConfig from '../../common/js/quill-config.js'


export default {
  components: {
    quillEditor
  },
    data() {
        return {
            quillOption: quillConfig  //默认为null,这是改为fastdfs控件,是方便文件的回显和上传
            ...
        }
    }
}
```

这是页面:

```javascript
<quill-editor v-model="editForm.detail.intro" :options="quillOption"></quill-editor>
```

这是quill-config.js:

```js
/*富文本编辑图片上传配置*/
const uploadConfig = {
    fastDfsUrl:'http://47.95.117.210:8888',  //  查看路径
    action:  'http://localhost:8080/fastDfs/upload',  // 必填参数 图片上传地址
    methods: 'POST',  // 必填参数 图片上传方式
    token: '',  // 可选参数 如果需要token验证，假设你的token有存放在sessionStorage
    name: 'file',  // 必填参数 文件的参数名
    size: 500,  // 可选参数   图片大小，单位为Kb, 1M = 1024Kb
    accept: 'image/png, image/gif, image/jpeg, image/bmp, image/x-icon'  // 可选 可上传的图片格式
};

// toolbar工具栏的工具选项（默认展示全部）
const toolOptions = [
    ['bold', 'italic', 'underline', 'strike'],
    ['blockquote', 'code-block'],
    [{'header': 1}, {'header': 2}],
    [{'list': 'ordered'}, {'list': 'bullet'}],
    [{'script': 'sub'}, {'script': 'super'}],
    [{'indent': '-1'}, {'indent': '+1'}],
    [{'direction': 'rtl'}],
    [{'size': ['small', false, 'large', 'huge']}],
    [{'header': [1, 2, 3, 4, 5, 6, false]}],
    [{'color': []}, {'background': []}],
    [{'font': []}],
    [{'align': []}],
    ['clean'],
    ['link', 'image', 'video']
];
const handlers = {
    image: function image() {
        var self = this;
        var fileInput = this.container.querySelector('input.ql-image[type=file]');
        if (fileInput === null) {
            fileInput = document.createElement('input');
            fileInput.setAttribute('type', 'file');
            // 设置图片参数名
            if (uploadConfig.name) {
                fileInput.setAttribute('name', uploadConfig.name);
            }
            // 可设置上传图片的格式
            fileInput.setAttribute('accept', uploadConfig.accept);
            fileInput.classList.add('ql-image');
            // 监听选择文件
            fileInput.addEventListener('change', function () {
                // 创建formData
                var formData = new FormData();
                formData.append(uploadConfig.name, fileInput.files[0]);
                formData.append('object','product');
                // 如果需要token且存在token
                if (uploadConfig.token) {
                    formData.append('token', uploadConfig.token)
                }
                // 图片上传
                var xhr = new XMLHttpRequest();
                xhr.open(uploadConfig.methods, uploadConfig.action, true);
                // 上传数据成功，会触发
                xhr.onload = function (e) {
                    if (xhr.status === 200) {
                        var res = JSON.parse(xhr.responseText);
                        let length = self.quill.getSelection(true).index;
                        //这里很重要，你图片上传成功后，img的src需要在这里添加，res.path就是你服务器返回的图片链接。
                        self.quill.insertEmbed(length, 'image', uploadConfig.fastDfsUrl+res.msg);   //这里注意要修改
                        self.quill.setSelection(length + 1)
                    }
                    fileInput.value = ''
                };
                // 开始上传数据
                xhr.upload.onloadstart = function (e) {
                    fileInput.value = ''
                };
                // 当发生网络异常的时候会触发，如果上传数据的过程还未结束
                xhr.upload.onerror = function (e) {
                };
                // 上传数据完成（成功或者失败）时会触发
                xhr.upload.onloadend = function (e) {
                    // console.log('上传结束')
                };
                xhr.send(formData)
            });
            this.container.appendChild(fileInput);
        }
        fileInput.click();
    }
};

export default {
    placeholder: '',
    theme: 'snow',  // 主题
    modules: {
        toolbar: {
            container: toolOptions,  // 工具栏选项
            handlers: handlers  // 事件重写
        }
    }
};
```

## 5. 集成百度地图

我们可以在页面上进行内嵌百度地图,这样我们可以输入关键字就可以获取地图相关信息之类的;

首先要获取百度地图第三方的key:

http://lbsyun.baidu.com/

![image-20211104144820105](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/imgs/image-20211104144820105.png)

这是DEMO:https://lbsyun.baidu.com/jsdemo.htm#a6_2,可以参考这个demo

根据这个demo我们可以直接放入到我们想要内嵌地图的页面,要记住要放入我们刚刚注册的AK;

当然我这里直接放AK的链接:https://lbsyun.baidu.com/apiconsole/key#/home

然后这里记录一个工具类:用于解析地址计算距离用户最近的商家

1. 可以根据地址获取对应的坐标
2. 根据很多地址来获取相对于自己较近的一个地址

**注**:当然我认为这个地址距离我认为是可以通过redis的geo来处理!

```java
package cn.miao.common.util;


import cn.hutool.core.collection.CollUtil;
import cn.miao.common.exception.MiaoRuntimeException;
import cn.miao.project.domain.Point;
import cn.miao.project.domain.domain.Shop;

import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;
import java.util.List;

/**
 * 位置相关工具类
 *
 * @author MiaoDaWei
 */
@SuppressWarnings("all")
public class DistanceUtil {
    /**
     * 百度程序应用程序的AK
     */
    private static final String APPLICATION_KEY = "ki7G2ODhCwdPNN1pf92rhEYQsV2Rj7CQ";
    //地球半径,进行经纬度运算需要用到的数据之一
    private static final double EARTH_RADIUS = 6378137;

    public static Point getPoint(String address) {
//        String Application_ID="PQ9FAt6qg7taDWj6LLABYO7u6bSETXhD";//配置上自己的百度地图应用的AK
        try {
            String sCurrentLine = "";
            String sTotalString = "";
            InputStream urlStream;
            //https://lbsyun.baidu.com/index.php?title=webapi/guide/webservice-geocoding 这是官方文档
            URL url = new URL("http://api.map.baidu.com/geocoding/v3/?address=" + address + "&output=json&ak=" + APPLICATION_KEY + "&callback=showLocation");
            HttpURLConnection connection = (HttpURLConnection) url.openConnection();
            connection.connect();
            urlStream = connection.getInputStream();
            BufferedReader reader = new BufferedReader(new InputStreamReader(urlStream));
            String str = reader.readLine();
//            System.out.println(str);
            //用经度分割返回的网页代码
            String s = "," + "\"" + "lat" + "\"" + ":";
            String[] strs = str.split(s, 2);
            String s1 = "\"" + "lng" + "\"" + ":";
            String[] a = strs[0].split(s1, 2);
            s1 = "}" + "," + "\"";
            String[] a1 = strs[1].split(s1, 2);

            Point point = new Point();
            point.setLng(Double.valueOf(a[1]));
            point.setLat(Double.valueOf(a1[0]));
            return point;
        } catch (Exception e) {
            e.printStackTrace();
            throw new MiaoRuntimeException("获取地址位置信息失败!请输入正确的地理位置坐标");
        }
    }

    //根据坐标点获取弧度
    private static double rad(double d) {
        return d * Math.PI / 180.0;
    }

    /**
     * 根据两点间经纬度坐标（double值），计算两点间距离，单位为米
     *
     * @param point1 A点坐标
     * @param point2 B点坐标
     * @return
     */
    public static double getDistance(Point point1, Point point2) {
        double radLat1 = rad(point1.getLat());
        double radLat2 = rad(point2.getLat());
        double a = radLat1 - radLat2;
        double b = rad(point1.getLng()) - rad(point2.getLng());
        double s = 2 * Math.asin(Math.sqrt(Math.pow(Math.sin(a / 2), 2) +
                Math.cos(radLat1) * Math.cos(radLat2) * Math.pow(Math.sin(b / 2), 2)));
        s = s * EARTH_RADIUS;
        s = Math.round(s * 10000) / 10000;
        return s;
    }

    /**
     * 根据两点间经纬度坐标（double值），计算两点间距离，单位为米
     *
     * @param point 用户指定的地址坐标
     * @param shops 商店
     * @return
     */
    public static Shop getNearestShop(Point point, List<Shop> shops) {
        if (CollUtil.isEmpty(shops)) {
            throw new MiaoRuntimeException("暂无店铺进行处理");
        }
        //如果传过来的集合只有一家店铺,那么直接将这家店铺的信息返回就是最近的店铺了
        Shop shop = shops.get(0);
        //获取集合中第一家店铺到指定地点的距离
        double distance = getDistance(point, getPoint(shops.get(0).getAddress()));
        //如果有多家店铺,那么就和第一家店铺到指定地点的距离做比较
        if (shops.size() > 1) {
            for (int i = 1; i < shops.size(); i++) {
                if (getDistance(point, getPoint(shops.get(i).getAddress())) < distance) {
                    shop = shops.get(i);
                }
            }
        }
        return shop;
    }

//    public static void main(String[] args) {
//        System.out.println(getPoint("成都市武侯区天府新谷-10号楼"));
//    }
}
```

## 6. 订单流程(三方支付-支付宝)

### 6.1 订单流程

这是一个大概的流程图:

![1620963078374](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/imgs/1620963078374.png)

业务流程:

​	首先商家上架宠物,然后用户在宠物列表进行选购,通过商品的详情页面进行一个购买下单的操作,而在后台通过下单的请求参数进行相关的保存订单信息!

### 6.2 三方支付的原理

这是一个总的支付流程:

![image-20211106163442703](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/imgs/image-20211106163442703.png)

**理解**:用户通过订单详情页点击立即购买,这时就会立即发起一个下单请求到后台去,后台接收请求参数进行下单的保存并冻结相关的相关商品。同时将需要第三方支付需要的流水参数所在的支付单的表也进行一个保存，然后操作成功后就会返回一个支付单号，前台页面返回收到操作成功的标志后就会发起一个支付的申请，后台会根据刚刚保存的支付单进行向第三方支付接口进行发起支付，等待支付成功后，就会有两个回调结果，第一个回调是异步回调，这步是将调用后台接口进行支付结果进行相关业务的处理，如：修改订单的状态和保存支付的流水等等。同时还要一个同步回调，这个同步回调是第三方支付是支付结束后重定向到我们刚刚支付的页面，用于告诉客户端用户已经支付成功了！

**注意**:

​	其实可以将保存订单放在支付业务那里去操作,但是为了一个分离服务更具有独立性的概念思想,因为支付有不同的场景,每个场景保存订单的参数都是可能不一样的,所以这里就将其抽出来,在支付业务中只需要获取订单号进行查询就可以发起第三方支付,这种要更具有健壮性!

​	支付单用于保存一些订单相关的参数,比如金额、标题、订单号,订单所属类型等等,每个业务的类型都是不一样,所以需要在后台下单那里保存支付单,不然的话如果将业务单从页面发起请求到另外一个后台接口,那么我们在那里进行保存支付单那么就要反着去推断获取业务单的参数信息,如果有各种各样的业务单们比如充值下单、购买宠物下单、其他的都要下单,那么就要反着查各种表数据，而对于支付业务来说就真的太恶心了造成耦合度太高!所以在后台下单那里进行保存支付单（因为你反正都要支付所以就在这里保存支付单，注意此时并没有支付）,然后我们只需要将支付单的单号返回给前台,由前台请求到支付业务,支付业务根据这个统一的支付单的单号查询支付单的数据然后去请求第三方支付宝!这样无论到哪个项目都可以独立的运行!其实会造成代码的关联性没有那么强！

> 要注意无论支付成功还是失败，都有两次回调，一次异步一次同步

支付场景：

- 下单支付【用户 -> 平台】：普通用户购买某产品，在线支付 ： 用户账户(银行，支付宝，微信) -> 平台账户
- 账户充值【用户 -> 平台】：普通用户在平台充值，把银行卡,支付宝，微信中的只是金额充值到平台账户中(虚拟账户，在平台只是一个数字而已)
- 账户提现【平台 -> 用户】：普通用户要把平台账户余额中的钱提取到银行卡，支付宝，微信 ，发起提现申请

支付理解：

![1620992844833](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/imgs/1620992844833.png)

**理解**：初期最早支付是银行才有的权利后面将支付的权利进行挂牌售卖，但所需金钱过于庞大所以一般很少有公司能买得起但是像支付宝微信这些有实力进行购买了这种支付牌照就可以通过支付去直接将银行用户账户的钱进行操作，但是现在是有价无市并且我们平台无法直接对接银行进行转账的操作，所以我们需要通过这些第三方支付提供的接口进行相关的支付操作，那么这第三方支付网关是如何进行转账的操作的呢？首先商家需要在第三方支付上开通一个账户，用户呢也需要登录到第三方支付的账户上，这样就同时有商家和用户的账户，当用户进行扫码付款的时候，钱就会直接转账到商家的账户上，但同时也有另外一种模式就是钱会先扫给平台，然后由平台赚差价再转商家账户上！但是要注意转账是要通过第三方支付网关对接银行进行转账的操作，通过银行的操作的回调结果是成功还是失败决定了平台用户的支付结果，并且也要记住这个转账操作是具有原子性的！

> 理解的核心点就是三方支付就是我们对接银行的中间商,我们支付需要商家和用户登录三方支付平台账户才能有权进行转账操作!

### 6.3 加密和数字签名

> 非对称加密

**对称加密**:如果数据传输方和数据接收方使用`相同的秘钥进行加密解密`，这种加密方式叫对称加密---------->传统的加密方式都是这种,用明文和一个秘钥进行加密,然后解密就是通过秘钥进行解密,也就是说加密和解密的秘钥是一样的,常用的比如MD5方式;

**非对称加密**:如果数据传输方和数据接收方使用`不同的秘钥进行加密`，这种方式叫非对称加密。这就意味这这种加密方式需要有2个秘钥，我们称之为公钥和私钥。--->一般私钥不可公开，公钥可以公开，`私钥加密，公钥解密`，反之亦然。`公钥加密只有私钥能解开`，这种加密安全性高，保证数据安全性。

```
非对称加密的理解:比如说A用一个密文进行加密,然后将密文传给B,然后B进行解密的时候所使用的秘钥跟A加密时使用的秘钥是不一样的!这种加密是一对的:公钥和私钥;两个秘钥之间其中一个加密另外一个可以对其解密,但是要注意:公钥是可以给其他人看的而私钥不可以给别人看的;也就是说公钥加密那么就只有我的私钥才可以进行解密,其他的都是不行的!而私钥加密应该谁都能解吧..
```

> 数字签名

数字签名就是在非对称加密的基础上，采用`私钥加密，公钥解密的方式`来防止数据被篡改，来实现数据的安全传输。

![image-20211108102403934-16363382502351](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/imgs/image-20211108102403934-16363382502351.png)

​	私钥保存在我们的项目中,我们传输的时候使用私钥将明文进行加密,严格意义上来讲这是签名,也就是说**用私钥中SRA2加密方式将账户信息混合生成一个密文**,这个密文就是签名,然后将数据和签名一并传输到支付宝平台去,而支付宝拿到这个数据和签名然后用存放在平台的公钥对其`解密验证`,验证这个签名是否正确,说白了就是传过来的签名使用公钥进行解密,然后就会将明文传输的数据和数字签名中的数据进行校验和验证,公钥的实质作用其实就是为了验证`数据的一致性`!

​	数字签名就是为了防止数据再传输的过程中被篡改!

​	数字签名就是将明文数据放在一起然后进行排序然后通过某种加密算法进行加密然后生成的密文就是数字签名!而接收数据那边除了用公钥进行解密之外还要对数字签名中的账户信息和明文传输的账户信息进行校验匹配!

​	当然除了应用私钥和应用公钥之外,我们还有支付宝私钥和支付宝公钥,其中呢应用的公私钥主要是为了我们的应用向支付宝发起的数据传输,而支付宝公私钥主要是**支付宝调用我们的数据用的**!当然这个传输调用也是有数字签名的!这里私钥我们是看不见的,我们只能看见公钥,这个支付宝调用我们的一般发生在支付结果的异步回调时!公钥主要是验证签名使用的!

```
数字签名通常是：
	把所有请求参数按照自然顺序排序后，拼接成一个url:如   a=x&b=x&c=x  ,然后使用非对称加密算法如：RSA2 传入私钥进行加密得到签名密文，然后请求三方接口的时候除了带上该有的参数外还需要带上签名的密文
```



### 6.4 支付宝使用

1. 支付宝开放平台创建账号：https://opendocs.alipay.com/

2. 我们需要的电脑网站支付相关文档在这里：https://opendocs.alipay.com/open/270/105898

   - 基本的功能文档，比如退款和调用等等，在这里：https://opendocs.alipay.com/open/270/105899

   注意：在接入条件中明确提出要企业或者个体工商户的营业执照，而我们并没有我们只是用于学习，那么后续的话我们将采用支付宝提供的沙箱测试

3. 文档里说明了正常使用流程：

   - 创建应用(1:网页支付,2:支付接入); 创建应用后左上角有个appid很重要,相当于能代表你的商户信息!

   - 添加能力(勾选支付中的电脑网站支付,不然你这个创建应用就不能使用电脑网站支付)

   - 设置开发信息

     - 接口加签方式:数据加密提交,也可理解为请求到支付宝的数据不安全那么就会进行加密的方式传输

       ![image-20211108205654609](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/imgs/image-20211108205654609.png)

     - ip白名单:设置哪些ip才能进行访问等信息

     - 支付宝网关、应用网关：分别是支付宝的地址和我们项目的地址

     - 接口内容加密方式：针对于某些请求信息比如身份证信息进行加密后再提交

   - 提交审核（审核通过就可以用了）

-------------------------------------------------------------------------------------------------------------------------------------------------------------

以上的接入准备必须要营业执照和提交审核才可以使用商户信息！而我们没有，所以接下来代码业务测试学习使用的`沙箱测试`

### 6.5 沙箱测试

沙箱的使用文档在这里:https://opendocs.alipay.com/open/200/105311

沙箱的具体使用:https://openhome.alipay.com/platform/appDaily.htm?tab=info

注意:

![image-20211108212755795](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/imgs/image-20211108212755795.png)

如果使用默认秘钥我们只需要启用即可,因为支付宝已经默认为我们生成了秘钥,如果选择自定义秘钥,那么就需要我们自己来进行生成,

1. 推荐线上生成秘钥的地址:https://miniu.alipay.com/keytool/create

2. 当然你也可以选择不是线上的而是选择下载第三方工具进行生成,这是文档:https://opendocs.alipay.com/open/291/106097/

**注意**:其实这里的配置秘钥就是相当于配置我们之前配置自己的应用的时候有个接口加签方式,就是加密为了保证数据的传输的安全性!

![image-20211108213501040](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/imgs/image-20211108213501040.png)

后面我们使用的话我们就通过买家账户进行登录,然后进行支付测试!

还有要说明的是:我们使用的是公钥模式,另一种是证书模式,这两者加密方式都差不多,然后后面在Java配置的时候也会有区别的!

![1621048027362](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/imgs/1621048027362.png)

【特别说明】到这里秘钥配置成功，其实这里有2对秘钥 ，我们自己生成了一对公私钥 ，把私钥自己保留，把我们的公钥配置给支付宝

还有1对秘钥就是支付宝自己生成的，我们需要把支付宝的公钥复制下来在系统中使用。也就是：

- `我们平台保留： 我们的私钥 ， 支付宝的公钥`
- `支付宝平台保留：支付宝使用，我们的公钥`

数字签名

- `我们请求支付宝：我们用我们的私钥做签名  ->   支付宝用我们的公钥做验签`
- `支付宝请求我们：支付宝用它的私钥做签名  ->   我们用支付宝的公钥做验签`

### 6.6 支付的详细流程

支付宝支付流程

![1621049372032](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/imgs/1621049372032.png)

这里我再贴我们最初对支付的流程大概思路:

![image-20211106163442703](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/imgs/image-20211106163442703.png)

平台支付详细流程:

前端通过页面点击下单然后请求到后台进行下单业务的处理(保存业务单和支付单),然后返回订单编号给前台

1. 前台向支付业务发起支付请求,请求参数:订单编号
2. 支付业务根据订单编号查询支付单,配置参数向支付宝发起支付申请
3. 支付宝会返回一个预支付申请表单(一个HTML格式的字符串),我们需要将这个结果返回给浏览器去重定向
4. 页面跳转到支付宝界面,用户进行登录支付宝然后进行支付
5. 当确认支付后支付宝就会进行同步回调和异步回调
   - 同步回调:修改地址栏定位到另一个界面,一般只做支付结果通知不做业务处理!
   - 异步回调:调用我们项目内的接口，需要验证签名、参数、金额等，根据支付成功或者失败来修改支付状态以及后续相关业务逻辑

### 6.7 实战使用

开发的话有两种方式:

- `通用版`:https://opendocs.alipay.com/open/54/103419
  - 使用文档和步骤DEMO都在这个里面!这里不做阐述
- `Easy版`:https://opendocs.alipay.com/open/54/00y8k9
  - 我们使用这个方式,具体使用接下来我们来探讨一下;
  - 我们推荐使用的Easy版,因为较为主流同时也是较为新的一种方式;

--------------------------------------------------------------------------------------------------------------------------------

SDK:开发工具包的意思

1. 导入maven依赖:

   ```xml-dtd
   <!-- https://mvnrepository.com/artifact/com.alipay.sdk/alipay-easysdk -->
   <dependency>
       <groupId>com.alipay.sdk</groupId>
       <artifactId>alipay-easysdk</artifactId>
       <version>2.2.0</version>
   </dependency>
   ```

2. 设计数据库相关表字段:

   - 业务单表:用于保存关于各种业务发生支付的订单表---这个没什么,自己根据实际业务来处理

   - 支付单表:用于保存发起支付的表

     ![image-20211109082039496](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/imgs/image-20211109082039496.png)

   - 支付配置信息表

     ![image-20211109222402899](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/imgs/image-20211109222402899.png)

   - 账单流水表:用于记录每次支付后结果的操作,这个就是异步回调会传的字段参数

     ![image-20211109222427272](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/imgs/image-20211109222427272.png)

   3. 在后台保存好支付单以后,将支付单的编号请求到前台,前台拿到又请求到支付业务中:

   4. 配置支付宝请求所需的配置信息:
   
      ```java
       /**
           * alibab支付配置
           *
           * @return {@link Config}
           */
      private Config alibabPayConfig(){
          PayAlipayInfo payAlipayInfo = payAlipayInfoMapper.selectPayAlipayInfoByState(PAY_ALIPAY_INFO_STATUS_SUCCESS);
          if (BeanUtil.isEmpty(payAlipayInfo)) {
              throw new MiaoRuntimeException("第三方支付信息配置参数无效");
          }
          Config config = new Config();
          config.protocol = payAlipayInfo.getProtocol();
          config.gatewayHost = payAlipayInfo.getGatewayhost();
          config.signType = payAlipayInfo.getSigntype();
          config.appId = payAlipayInfo.getAppid();
          // 为避免私钥随源码泄露，推荐从文件中读取私钥字符串而不是写入源码中
          config.merchantPrivateKey = payAlipayInfo.getMerchantPrivateKey();
          //如果采用的是公钥模式,执行这个,如果不是那么就是执行的证书模式
          if (payAlipayInfo.getCertificate().compareTo(PAY_ALIPAY_INFO_CERTIFICATE_PUBKEY) == 0) {
              config.alipayPublicKey =payAlipayInfo.getAlipayPublicKey() ;
          }else{
              //注：证书文件路径支持设置为文件系统中的路径或CLASS_PATH中的路径，优先从文件系统中加载，加载失败后会继续尝试从CLASS_PATH中加载
              config.merchantCertPath = payAlipayInfo.getMerchantcertpath();
              config.alipayCertPath = payAlipayInfo.getAlipaycertpath();
              config.alipayRootCertPath = payAlipayInfo.getAlipayrootcertpath();
          }
          //可设置异步通知接收服务地址（可选）
          config.notifyUrl = payAlipayInfo.getNotifyurl();
          //可设置AES密钥，调用AES加解密相关接口时需要（可选）
          config.encryptKey = payAlipayInfo.getEncryptkey();
          return config;
      }
      ```

   5. 加入支付申请逻辑
   
      ```java
      /**
           * alibab支付,根据请求过来的支付单,来进行查询相关参数向第三方支付发起请求
           *
           * @param orderNo 订单编号
           * @return {@link AjaxResult}
           */
      @Override
      public AjaxResult alibabPay(String orderNo) {
          //校验参数是否正确
          PayBill bill=payBillMapper.selectPayByOrderNo(orderNo);
          if (BeanUtil.isEmpty(bill)) {
              throw new MiaoRuntimeException("非法请求!");
          }
          //配置请求第三方支付的参数信息
          // 1. 设置参数（全局只需设置一次）
          Factory.setOptions(this.alibabPayConfig());
          try {
              // 2. 发起API调用（这里以电脑网站支付为例）
              AlipayTradePagePayResponse pay = Factory.Payment.Page()
                  .pay(bill.getDigest(), bill.getUnionpaysn(), bill.getMoney().toString(), "http://127.0.0.1:80");
              // 3. 处理响应或异常
              if (ResponseChecker.success(pay)) {
                  System.out.println("调用成功");
                  return AjaxResult.success("调用支付成功", pay.body);
              } else {
                  System.err.println("调用失败，原因：");
              }
          } catch (Exception e) {
              System.err.println("调用遭遇异常，原因：" + e.getMessage());
              throw new RuntimeException(e.getMessage(), e);
          }
      
          return AjaxResult.error("调用失败!");
      }
      ```

   6. 请求给第三方支付返回一个HTML的支付代码,我们将其返回给前端并输出到页面
   
      ```javascript
       methods: {
           submitProductOrder() {
               this.$http.post("/petAdoptOrder/submitOrder", this.order).then((res => {
                   if(res.data.success){
                       //document.getElementById("mydiv").innerHTML = res.data.result;
                       document.write(res.data.data)
                   }
               }));
           }
       },
      ```

   7. 页面就是这个样子的:

      ![image-20211109083130130](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/imgs/image-20211109083130130.png)
   
      支付业务中向支付宝发起申请,然后会返回一个页面(带有支付页面的HTML代码),这个页面就是用户登录支付宝页面-我们用沙箱账号的买家进行登录,然后进行支付-输入密码-支付成功就会进行同步回调-同时我们还有一个异步回调

   8. 登录支付成功后,支付宝就会向我们的平台发起: **同步回调和异步回调**;同步回调用于查看支付结果而异步回调用于处理支付结果
   
      - 同步回调:验证签名和参数后,根据参数中的订单号查询支付单,返回支付状态给用户展示
      - 异步回调:验证签名和参数后,根据支付结果对支付单和业务单做出相关的状态设置,并且还需要处理`幂等性`(对支付结果去重处理)!
   
   异步结果处理:
   
   异步通知API文档:https://opendocs.alipay.com/open/270/105902
   
   这是封装的对象
   
   ```java
   package cn.miao.project.domain.dto;
   
   import com.alibaba.fastjson.annotation.JSONField;
   import lombok.Data;
   
   @Data
   public class AlipayNotifyDto {
   
       /**
        * 交易状态说明
        * WAIT_BUYER_PAY: 交易创建，等待买家付款。
        * TRADE_CLOSED: 	未付款交易超时关闭，或支付完成后全额退款。
        * TRADE_SUCCESS: 	交易支付成功。
        * TRADE_FINISHED:   交易结束，不可退款。
        */
       public static final String WAIT_BUYER_PAY = "WAIT_BUYER_PAY";
       public static final String TRADE_CLOSED = "TRADE_CLOSED";
       public static final String TRADE_SUCCESS = "TRADE_SUCCESS";
       public static final String TRADE_FINISHED = "TRADE_FINISHED";
   
       /**
        * 通知的发送时间。格式为 yyyy-MM-dd HH:mm:ss
        */
       private String notify_time;
       /**
        * 编码格式。如 utf-8、gbk、gb2312 等
        */
       private String charset;
       /**
        * 交易创建时间。该笔交易创建的时间。格式为yyyy-MM-dd HH:mm:ss。
        */
       private String gmt_create;
       /**
        * 交易付款时间。该笔交易的买家付款时间。格式为yyyy-MM-dd HH:mm:ss。
        */
       private String gmt_payment;
       /**
        * 订单标题。商品的标题/交易标题/订单标题/订单关键字等，是请求时对应的参数，原样通知回来。
        */
       private String subject;
       /**
        * 签名。详情请参见 异步返回结果的验签。
        */
       private String sign;
       /**
        * 买家支付宝用户号。买家支付宝账号对应的支付宝唯一用户号。以 2088 开头的纯 16 位数字。
        */
       private String buyer_id;
       /**
        * 开票金额。用户在交易中支付的可开发票的金额，单位为元，精确到小数点后 2 位。
        */
       private String invoice_amount;
       /**
        * 调用的接口版本。固定为：1.0。
        */
       private String version;
       /**
        * 通知校验 ID。
        */
       private String notify_id;
       /**
        * 支付金额信息。支付成功的各个渠道金额信息
        */
       private String fund_bill_list;
       /**
        * 通知类型
        */
       private String notify_type;
       /**
        * 商户订单号。原支付请求的商户订单号
        */
       private String out_trade_no;
       /**
        * 订单金额。本次交易支付的订单金额，单位为人民币（元），精确到小数点后 2 位。
        */
       private String total_amount;
   
       /**
        * 交易状态。交易目前所处的状态
        */
       private String trade_status;
       /**
        * 支付宝交易号。支付宝交易凭证号。
        */
       private String trade_no;
       /**
        * 授权方的 appid。由于本接口暂不开放第三方应用授权，因此 auth_app_id=app_id。
        */
       private String auth_app_id;
       /**
        * 实收金额。商家在交易中实际收到的款项，单位为元，精确到小数点后 2 位。
        */
       private String receipt_amount;
       /**
        * 集分宝金额。使用集分宝支付的金额，单位为元，精确到小数点后 2 位。
        */
       private String point_amount;
       /**
        * 开发者的 app_id。支付宝分配给开发者的应用 ID
        */
       private String app_id;
       /**
        * 用户在交易中支付的金额，单位为元，精确到小数点付款金额。后 2 位。
        */
       private String buyer_pay_amount;
       /**
        * 签名类型。签名算法类型，目前支持 RSA2 和 RSA，推荐使用 RSA2。
        */
       private String sign_type;
       /**
        * 卖家支付宝用户号。
        */
       private String seller_id;
       private String code;
       private String msg;
   
       /**
        * 是否交易成功
        *
        * @return boolean
        */
       @JSONField(serialize = false) //不参与JSON序列化的转换
       public boolean isTradeSuccess() {
           return this.trade_status.equals(TRADE_SUCCESS) || this.trade_status.equals(TRADE_FINISHED);
       }
   
       /**
        * 是否处于支付中
        *
        * @return boolean
        */
       @JSONField(serialize = false)
       public boolean isTradeWit() {
           return this.trade_status.equals(WAIT_BUYER_PAY);
       }
   
       /**
        * 未付款交易超时关闭,或支付完成之后全额退款
        *
        * @return boolean
        */
       @JSONField(serialize = false)
       public boolean isTradeExpire() {
           return this.trade_status.equals(TRADE_CLOSED);
       }
   }
   ```
   
   实际业务代码:
   
   ```java
   /**
        * 支付宝支付的异步回调地址
        *
        * @param dto dto
        * @return {@link AjaxResult}
        */
       @PostMapping("/notifyPay")
       public String notifyPay(AlipayNotifyDto dto) {
           return orderPetService.notifyPay(dto);
       }
   /**
        * 支付宝异步支付回调地址
        *
        * @param dto dto
        * @return {@link AjaxResult}
        */
       @Override
       @Transactional(rollbackFor = Exception.class)
       public String notifyPay(AlipayNotifyDto dto) {
           log.info("支付宝Pay支付,异步回调参数:{},", dto);
           /**
            * 1.支付宝要求返回"success",才会认为支付成功否则就会不断的重复发送通知
            * 2.判断参数是否正确-
            * 2.使用公钥进行验签,保证数据传输的正确性
            * 3.根据返回过来的订单号,查询是否重复处理
            * 4.根据返回的支付状态来对订单进行处理
            */
           //获取支付单
           String orderNo = dto.getOut_trade_no();
   
           if (BeanUtil.isEmpty(dto) || CharSequenceUtil.isEmpty(dto.getSign()) || CharSequenceUtil.isEmpty(orderNo)) {
               //不用返回异常信息,返回任意不是success字符串就可!如果可以顺带记录日志信息
               log.info("订单号【{}】的异步回调参数:Sign签名:{},商户订单号:{}发生异常信息", orderNo, dto.getSign(), dto.getOut_trade_no());
               return "fail";
           }
           Map<String, String> params = JSONObject.parseObject(JSONObject.toJSONString(dto), Map.class);
   
           //验证签名
           try {
               Boolean notify = Factory.Payment.Common().verifyNotify(params);
               if (!notify) {
                   log.info("订单号【{}】验签错误!", orderNo);
                   return "fail";
               }
           } catch (Exception e) {
               e.printStackTrace();
               return "fail";
           }
   
           //查询
           PayBill bill = payBillMapper.selectPayByOrderNo(orderNo);
           if (BeanUtil.isEmpty(bill)) {
               log.error("查询支付单【{}】不存在,发生错误!", orderNo);
               return "fail";
           }
           //查询t_order_pet表
           OrderPet pet = orderPetMapper.selectPayByOrderNo(orderNo);
           if (BeanUtil.isEmpty(pet)) {
               log.error("查询业务单【{}】不存在,发生错误!", orderNo);
               return "fail";
           }
   
           //幂校验(就是你调用方法多次,和调用1次的结果一样)
           //重复处理:
           //判断支付状态是不是成功的,成功直接返回success!也就是判断会不会出现并发的情况下同时访问,然后查询数据库状态是不是成功的!
   		//当然也不会出现并发的情况下的,因为支付宝的重复调用是隔一段时间的,也就是说隔几分钟对同一订单进行访问,所以这是可以避免的!
           if (bill.getState().compareTo(PAY_STATUS_SUCCESS) == ZERO) {
               log.info("订单号【{}】重复发起支付,订单处于{}", orderNo, PAY_STATUS_SUCCESS);
               return "success";
           }
           //支付金额进行校验匹配,是否跟之前传输的是否保持一致
           if (!dto.getTotal_amount().equals(bill.getMoney().toString())) {
               log.info("订单号【{}】的原订单支付金额【{}】和接收参数金额【{}】不一致!可能已被人篡改!请注意!", orderNo, bill.getMoney(), dto.getTotal_amount());
               return "fail";
           }
           if (CharSequenceUtil.isEmpty(dto.getApp_id())) {
               log.info("订单号【{}】的商家appid参数是无效的appid", orderNo);
               return "fail";
           }
           //判断支付状态是不是处于支付中,必须要在保存支付流水之前判断,本身来讲支付中是不应该保存流水的,因为没有流水!
           if (dto.isTradeWit()) {
               log.info("订单号【{}】正在支付中状态,暂不处理!", orderNo);
               return "fail";
           }
   
           //保存支付流水.保存支付的结果的!
           PayFlow payFlow = BeanUtil.copyProperties(dto, PayFlow.class);
           payAlipayInfoMapper.insertPayFlow(payFlow);
   
           //根据返回支付状态来进行处理
           Date updateTime = new Date();
           //支付成功
           if (dto.isTradeSuccess()) {
               //修改t_pay_bill支付单的支付状态
               bill.setState(PAY_STATUS_SUCCESS);
               //修改t_order_pet表的支付状态
               pet.setState(PENDING_FINAL_INDEX);
               //未付款交易超时关闭,或支付完成之后全额退款
           } else if (dto.isTradeExpire()) {
               //修改t_pay_bill支付单状态为失败
               bill.setState(PAY_STATUS_AUTO_CHOSE);
               //修改t_order_pet表的支付状态
               pet.setState(ORDER_PAY_FAILED);
               //失败那么就要退库存
               List<OrderPetDetail> vo = orderPetDetailMapper.selectPayByOrderNo(orderNo);
               List<Integer> collect = vo.stream().map(x -> Convert.toInt(x.getId())).collect(Collectors.toList());
               List<Pet> pets = petMapper.selectPetByIds(collect);
               for (Pet x : pets) {
                   x.setNum(x.getNum() - 1);
                   petMapper.updatePet(x);
               }
           } else {
               log.error("未知的交易状态");
               return "fail";
           }
   
           bill.setLastpaytime(updateTime);
           bill.setUpdateTime(updateTime);
           payBillMapper.updatePayBill(bill);
           pet.setLastUpdateTime(updateTime);
           orderPetMapper.updateOrderPet(pet);
   
           return "success";
       }
   ```

#### 踩坑和总结

> 说几点极容易踩坑的点

异步回调:

1. 配置内网穿透,因为这是从支付宝代码里向我们请求调用接口,所以需要内网映射
2. 既然内网映射,所以跨域和登录拦截要放行
3. 接收的时候不能用@Requestbody来进行接收绑定,因为别人并不是json结构,所以直接用对象接收即可!
4. 返回的时候需要返回"success"这个字符串,否则返回其他字符串就会不断的重复调用
5. 验证签名如果出现错误记得看看在发起支付请求的时候是否配置正确!

同步回调:

- 这个没啥好说的,只是修改浏览器地址栏而已,只需要修改我们项目的地址即可!同步回调只是通过地址栏进行修改了而已!->记住只是修改了地址栏URL而已!

对支付配置信息表中的商铺的id的设计做出记录:

![image-20211109222758228](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/imgs/image-20211109222758228.png)

- ![e081a2915fda991a29126d58d1a08d6](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/imgs/e081a2915fda991a29126d58d1a08d6.png)

记录:一个平台有很多个店铺,每个店铺的appid都是不一样的,收款的时候用户转的指定的appid(店铺账户)中

第一种模式:用户支付宝支付到平台的支付宝,然后经过平台支付宝进行分账给店家的支付宝

第二种模式:用户支付宝统一支付到平台的支付宝,然后平台会在店家创建一个虚拟的店家账户,然后虚拟数字加需要分账的数字,然后店家需要提现到银行卡或者其他真实账户里的时候,那么就根据虚拟账户的数字从平台支付宝进行提现即可!

记录:

![image-20211109223702264](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/imgs/image-20211109223702264.png)

这里是表示执行的链路关系图,也就是在DEBUG的模式下,每调用执行链路调用的时候这里就有会一个链路关系,最新的在最上面!

这是总的流程:

![76c849d0f02802b466f850cf5ef1b7f](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/imgs/76c849d0f02802b466f850cf5ef1b7f.png)



## 7. Quartz定时器

### 1.概念

> 为什么需要Quartz

在项目中总会遇到这样的场景，比如：每小时定期获取天气情况 ， 每2天定期给未还款用户发送催款短信，每天定期给领导发送最新报表数据 等等。你发现这种类似的场景都有一个规律：**定期执行** 。那么如何能够让我们的一段程序定期的去执行呢？ Quartz定时器，它就可以做到。

思考：如果某个订单下单后，但是长时间没有支付，设定支付超时时间15分钟，如何在超过15分钟之后自动关单呢？？？

> 是什么

Quartz是OpenSymphony开源组织在Job scheduling领域又一个开源项目，完全由Java开发，可以用来执行定时任务，类似于java.util.Timer。但是相较于Timer， Quartz增加了很多功能：

- 持久性作业 - 就是保持调度定时的状态;
- 作业管理 - 对调度作业进行有效的管理;

> 优缺点

面试题: quizrtz有什么问题?

1. 并发多.产生的定时任务多,性能不好
   - 一个订单一个定时任务,订单多,定时任务多,性能不好
   - 理解:因为每个订单的超时时间都是不一样的,然后就会为每一个订单创建一个定时任务去执行,但是这种一旦到遇到订单的并发量很大,比如就有1万个订单,那么我们就要创建1万个定时任务,那么这个是非常影响性能问题的!
2. 用一个定时任务去周期性的扫描订单表,然后判断时间,
   - 问题是可能会有时效性问题,对数据库压力非常大,这种方式90%次扫描都是空扫描,白白浪费性能!
   - 理解:如果说我们用一个定时任务周期性去扫描订单表中的超时时间,那么就会产生时效性问题,比如设置周期时间是隔5秒扫描一次,那么就有可能是订单A在13:55过期,而定时任务刚好在54就扫描结束了,那么这种就会造成订单的超时漏掉,也是不行的!并且假如为了保证订单超时处理如果每秒去查询那么你可以试想这数据库的压力得有多大!而周期性扫描数据库,也会对数据库的压力非常大,因为假如并发量很大,订单表有1000万的订单,如果每5秒就执行扫描那么会造成查询的缓慢,效率会非常低下, 而且有些数据可能说还有20分钟后才会过期,那么现在每隔5秒扫描都是空的,也就是说无功而返, 可以这样说就是白干了, 这样也会白白浪费性能! 

好处:

- 小项目，体量不大，使用简单
- 遇到断电或者宕机那么可以持久化到数据库硬盘中! 



### 2.Quartz结构

1. `scheduler`：是一个计划调度器容器（总部），容器里面可以盛放众多的JobDetail和trigger，当容器启动后，里面的每个JobDetail都会根据trigger按部就班自动去执行。
2. `JobDetail`：是一个可执行的工作，它本身可能是有状态的。
3. `Trigger`：代表一个调度参数的配置，什么时候去调。
4. 当JobDetail和Trigger在scheduler容器上注册后，形成了装配好的作业（JobDetail和Trigger所组成的一对儿），就可以伴随容器启动而调度执行了。
5. scheduler是个容器，容器中有一个线程池，用来并行调度执行每个作业，这样可以提高容器效率。因为内部有线程池所以可以用多线程的方式去执行

![1621177327710](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/imgs/1621177327710.png)

> 具体的结构介绍

1. **JOB**

   ​	Job是一个执行任务的简单Java类。任务可以是任何java代码。只需你实现org.quartz.Job接口，并将你需要执行的任务代码写在execute（）方法中即可。当Quartz确定该是作业运行的时候，它将调用你的作业。Quartz提供了一个机制来建立具有不同粒度的、可重复的调度表，于是，你只需创建一个java类，这个类被调用而执行任务。

   ```java
   public interface Job {
         void execute(JobExecutionContext context) throws JobExecutionException;
   }
   
   Class MyJob implements Job{
   
   	@Override void execute(..) {..….}
   }
   ```

   可以理解为job是我们要做什么东西,比如:发短信

2. **JobDetail**

   ​	JobDetail对象由Quartz客户端在Job被加入到scheduler时创建。它包含了Job的各种设置属性以及一个JobDataMap对象，这个对象被用来存储给定Job类实例的状态信息。Scheduler并不保存真正的Job Class，而是通过JobDetail来保存。

   **注意**:我们给scheduler传入了一个JobDetail实例，而且这个JobDetail实例只是简单提供了类名来引用被执行的Job。每次scheduler执行这个任务时，它就创建这个类的新实例，然后调用该实例的execute(..)方法。Job不必担心线程安全性，因为同一时刻仅有一个线程去执行给定Job类的实例，甚至是并发执行同一Job也是如此。

   可以理解为要做什么事情

3. **JobFactory**

   JobFactory控制job的实例化 Job newJob(TriggerFiredBundle bundle) throws SchedulerException;默认的JobFactory是org.quartz.simpl.SimpleJobFactory，缺省JobFactory只是简单地对Job类调用newInstance()方法。
   设置JobFactory： `scheduler.setJobFactory(factory)`
   配置quartz.properties的`org.quartz.scheduler.jobFactory.class`属性设置jobFactory的类型

   可以理解就是创建job的实例工厂

4. **JobDataMap**

   JobDataMap被用来保存一系列的（序列化的）对象，这些对象在Job执行时可以得到。JobDataMap是Java Map接口的一个实现，而且还增加了一些存储和读取主类型数据的便捷方法。

   设置 `JobDetail.getJobDataMap().put("jobSays", "Hello World!"); `

   获取 `JobExecutionContext.getJobDetail().getJobDataMap();`
      ` Trigger.getJobDataMap(); `
      ` JobExecutionContext.getMergedJobDataMap(); `

   可以理解为以map的结构将数据传递给job

5. **Trigger（触发器）**

   Trigger对象被用来触发jobs的执行。你希望将任务纳入到进度，要实例化一个Trigger并且“调整”它的属性以满足你想要的进度安排。Triggers也有一个JobDataMap与之关联，这非常有利于向触发器所触发的Job传递参数。Quartz打包了很多不同类型的Trigger,最常用的Trigger类是`SimpleTrigger`和`CronTrigger`。

   1. SimpleTrigger
      - SimpleTrigger用来触发只需执行一次或者在给定时间触发并且重复N次且每次执行延迟一定时间的任务。
        如果你想让触发器在2010年1月11日，上午11：23：54秒执行，然后每个隔10秒钟重复执行一次，并且这样重复5次。那么SimpleTrigger 就可以满足你的要求。
      - 可以理解为:指定时间触发一次和在指定的时间内重复执行多少次,并且可以延迟
   2. CronTrigger
      - 如果你需要像日历那样按日程来触发任务，而不是像SimpleTrigger 那样每隔特定的间隔时间触发，CronTriggers通常比SimpleTrigger更有用。
        使用CronTrigger，你可以指定诸如“每个周五中午”，或者“每个工作日的9:30”或者“从每个周一、周三、周五的上午9：00到上午10：00之间每隔五分钟”这样日程安排来触发。甚至，象SimpleTrigger一样，CronTrigger也有一个startTime以指定日程从什么时候开始，也有一个（可选的）endTime以指定何时日程不再继续。
      - 理解为:用表达式来执行时间触发

   > Cron 表达式

   Cron表达式被用来配置CronTrigger实例。Cron表达式是一个由7个子表达式组成的字符串。每个子表达式都描述了一个单独的日程细节。这些子表达式用空格分隔，分别表示：
   Seconds 秒
   Minutes 分钟
   Hours 小时
   Day-of-Month 月中的天
   Month 月
   Day-of-Week 周中的天
   Year (optional field) 年

   | 字段                     | 允许值                                 | 允许的特殊字符               |
   | ------------------------ | -------------------------------------- | ---------------------------- |
   | 秒（Seconds）            | 0~59的整数                             | , - * /    四个字符          |
   | 分（*Minutes*）          | 0~59的整数                             | , - * /    四个字符          |
   | 小时（*Hours*）          | 0~23的整数                             | , - * /    四个字符          |
   | 日期（*DayofMonth*）     | 1~31的整数（但是你需要考虑你月的天数） | ,- * ? / L W C     八个字符  |
   | 月份（*Month*）          | 1~12的整数或者 JAN-DEC                 | , - * /    四个字符          |
   | 星期（*DayofWeek*）      | 1~7的整数或者 SUN-SAT （1=SUN）        | , - * ? / L C #     八个字符 |
   | 年(可选，留空)（*Year*） | 1970~2099                              | , - * /    四个字符          |

案例:

```
（1）0 0 2 1 * ? *   表示在每月的1日的凌晨2点调整任务

（2）0 15 10 ? * MON-FRI   表示周一到周五每天上午10:15执行作业

（3）0 15 10 ? 6L 2002-2006   表示2002-2006年的每个月的最后一个星期五上午10:15执行作

（4）0 0 10,14,16 * * ?   每天上午10点，下午2点，4点 

（5）0 0/30 9-17 * * ?   朝九晚五工作时间内每半小时 

（6）0 0 12 ? * WED    表示每个星期三中午12点 

（7）0 0 12 * * ?   每天中午12点触发 

（8）0 15 10 ? * *    每天上午10:15触发 

（9）0 15 10 * * ?     每天上午10:15触发 

（10）0 15 10 * * ? *    每天上午10:15触发 

（11）0 15 10 * * ? 2005    2005年的每天上午10:15触发 

（12）0 * 14 * * ?     在每天下午2点到下午2:59期间的每1分钟触发 

（13）0 0/5 14 * * ?    在每天下午2点到下午2:55期间的每5分钟触发 

（14）0 0/5 14,18 * * ?     在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发 

（15）0 0-5 14 * * ?    在每天下午2点到下午2:05期间的每1分钟触发 

（16）0 10,44 14 ? 3 WED    每年三月的星期三的下午2:10和2:44触发 

（17）0 15 10 ? * MON-FRI    周一至周五的上午10:15触发 

（18）0 15 10 15 * ?    每月15日上午10:15触发 

（19）0 15 10 L * ?    每月最后一日的上午10:15触发 

（20）0 15 10 ? * 6L    每月的最后一个星期五上午10:15触发 

（21）0 15 10 ? * 6L 2002-2005   2002年至2005年的每月的最后一个星期五上午10:15触发 

（22）0 15 10 ? * 6#3   每月的第三个星期五上午10:15触发
```

在线生成：https://cron.qqe2.com/

注意:

1. '*': 代表每的意思
2. ? 代表忽略、无所谓的意思
3. 比如:每秒执行 0/1 * * * * ?  --->从0秒开始每1秒开始执行

### 3.实际使用

导入依赖:

```xml-dtd
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-quartz</artifactId>
</dependency>
```

创建配置:

```java
import cn.itsource.job.PrintTimeJob;
import org.quartz.*;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

//定时任务配置
@Configuration
public class QuartzConfig {

    @Bean
    public JobDetail newJob(){
        //PrintTimeJob我们的业务类
        return JobBuilder.newJob(PrintTimeJob.class)
                //可以给该JobDetail起一个id
                .withIdentity("printJobDetail")
                //每个JobDetail内都有一个Map，包含了关联到这个Job的数据，在Job类中可以通过context获取
                .usingJobData("msg", "Hello Quartz")//关联键值对
                //即使没有Trigger关联时，也不需要删除该JobDetail
                .storeDurably()
                .build();
    }
    @Bean
    public Trigger printTimeJobTrigger() {
        //每一秒执行一次
        CronScheduleBuilder cronScheduleBuilder = CronScheduleBuilder.cronSchedule("0/1 * * * * ? ");

        return TriggerBuilder.newTrigger()
                //触发器关联JobDetail
                .forJob(newJob())
                //给Trigger起个名字
                .withIdentity("quartzTaskService")
                //关联定时规则 Schedule
                .withSchedule(cronScheduleBuilder)
                .build();
    }
}
```

创建JOB:

```java
//定时任务的具体业务逻辑
public class PrintTimeJob extends QuartzJobBean {
    @Override
    protected void executeInternal(JobExecutionContext context) throws JobExecutionException {
        //成功JobDetails中获取参数
        JobDataMap jobDataMap = context.getJobDetail().getJobDataMap();
        jobDataMap.get("msg");
        System.out.println("定时任务执行，时间："+new Date().toLocaleString());
    }
}
```

> 理解:在配置的时候,其实就跟我们上面的流程图是一样的!在创建JobDetail里面首先加载job类和jobDataMap,然后返回一个JobDetail,然后在Tigger规则里面将JobDetail进行关联,也就是说JobDetail和Trigger是一个组合,然后在Scheduler容器里面开始运行!

### 4.动态添加定时任务

上面的定时任务一旦创建就固定了，如果我需要根据业务数据动态的加或者减定时任务，那么上面的配置方式就做不到了。

相关文档博客:https://www.cnblogs.com/laoyeye/p/9352002.html

其实就是让程序动态的添加定时任务!

添加maven:

```xml-dtd
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-lang3</artifactId>
</dependency>
```

封装一个工具类:

```java
package cn.miao.common.util;

import org.apache.commons.lang3.StringUtils;
import org.quartz.*;

import java.util.Calendar;
import java.util.Date;

import static org.quartz.CronScheduleBuilder.cronSchedule;

/**
 * @program: backstageProject
 * @description: quartz定时任务工具类
 * @author: MiaoWei
 * @create: 2021-11-09 23:36
 **/
public class QuartzUtils {
    //定时任务的JOB的组名
    public static final String JOB_GROUP_NAME = "JOB_GROUP_NAME";
    //定时任务的trigger的组名
    public static final String TRIGGER_GROUP_NAME = "TRIGGER_GROUP_NAME";

    //把时间变成时间表达式，在 fireDate 时间到的时候执行
    public static String getCron(Date fireDate) {
        String[] cronArr = new String[7];
        for (int i = 0; i < cronArr.length; i++) {
            cronArr[i] = "";
        }
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(fireDate);
        int second = calendar.get(Calendar.SECOND);
        int minute = calendar.get(Calendar.MINUTE);
        int hour = calendar.get(Calendar.HOUR_OF_DAY);
        int day = calendar.get(Calendar.DAY_OF_MONTH);
        int month = calendar.get(Calendar.MONTH) + 1;
        int year = calendar.get(Calendar.YEAR);

        cronArr[0] = second + "";
        cronArr[1] = minute + "";
        cronArr[2] = hour + "";

        cronArr[3] = day + "";
        cronArr[4] = month + "";
        cronArr[5] = "?";
        cronArr[6] = year + "";
        //把数组，编程字符串，以 "2 * * * " 分割
        return StringUtils.join(cronArr, " ").trim();
    }

    /**
     * 添加定时任务
     *
     * @param sched      : 定时任务的最大的容器
     * @param jobName    ： job的名字
     * @param cls        :任务,一个实现了Job类的class
     * @param params     :JobDataMap 以map参数的形式给Job
     * @param excuteTime : Tigger时间规则,
     */
    public static void addJob(Scheduler sched, String jobName, Class<? extends Job> cls, Object params, Date excuteTime) {
        addJob(sched, jobName, cls, params, getCron(excuteTime));
    }

    /**
     * @param sched   调度器容器
     * @param jobName 任务名
     * @param cls     任务,一个实现了Job类的class
     * @param params  任务参数
     * @param time    时间表达式，时间设置，参考quartz说明文档
     * @Description: 添加一个定时任务，使用默认的任务组名，触发器名，触发器组名
     * @Title: QuartzManager.java
     */
    public static void addJob(Scheduler sched, String jobName, Class<? extends Job> cls, Object params, String time) {
        try {
            /**=====================================创建JobDetail 工作详情=====================================**/

            //JOB 的键 ，相当于是一个job的ID
            JobKey jobKey = new JobKey(jobName, JOB_GROUP_NAME);// 任务名，任务组，任务执行类
            //Job的数据map
            JobDataMap jobDataMap = new JobDataMap();
            //把数据设置到map中，后续传给job
            jobDataMap.put("params", params);
            //根据传入的job的类，创建一个JobDetail，并制定 Job key ，并把数据map设置给job
            JobDetail jobDetail = JobBuilder.newJob(cls).withIdentity(jobKey).setJobData(jobDataMap).build();

            /**=====================================创建Trigger触发器=====================================**/
            //创建触发器的key 相当于是触发器的ID
            TriggerKey triggerKey = new TriggerKey(jobName, TRIGGER_GROUP_NAME);// 触发器
            //创建触发器 ， 设置触发器的key , 并关联一个  cronSchedule(基于表达式的时间规则)
            Trigger trigger = TriggerBuilder.newTrigger().withIdentity(triggerKey).withSchedule(cronSchedule(time)).build();// 触发器时间设定
            //把工作详情和调度器设置到 Scheduler调度容器,也就是绑定在一起
            sched.scheduleJob(jobDetail, trigger);
            // 启动
            if (!sched.isShutdown()) {
                sched.start();
            }
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * @param sched            调度器
     * @param jobName          任务名
     * @param jobGroupName     任务组名
     * @param triggerName      触发器名
     * @param triggerGroupName 触发器组名
     * @param jobClass         任务
     * @param params           任务参数
     * @param time             时间设置，参考quartz说明文档
     * @Description: 添加一个定时任务
     * @Title: QuartzManager.java
     */
    public static void addJob(Scheduler sched, String jobName, String jobGroupName, String triggerName,
                              String triggerGroupName, @SuppressWarnings("rawtypes") Class jobClass, Object params, String time) {
        try {
            JobKey jobKey = new JobKey(jobName, jobGroupName);
            JobDataMap jobDataMap = new JobDataMap();
            jobDataMap.put("params", params);
            @SuppressWarnings("unchecked")
            JobDetail jobDetail = JobBuilder.newJob(jobClass).withIdentity(jobKey).setJobData(jobDataMap).build();
            // 触发器
            TriggerKey triggerKey = new TriggerKey(triggerName, triggerGroupName);
            Trigger trigger = TriggerBuilder.newTrigger().withIdentity(triggerKey).withSchedule(cronSchedule(time)).build();
            sched.scheduleJob(jobDetail, trigger);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * @param sched   调度器
     * @param jobName
     * @param time
     * @Description: 修改一个任务的触发时间(使用默认的任务组名 ， 触发器名 ， 触发器组名)
     * @Title: QuartzManager.java
     */
    @SuppressWarnings("rawtypes")
    public static void modifyJobTime(Scheduler sched, String jobName, String time) {
        try {
            TriggerKey triggerKey = new TriggerKey(jobName, TRIGGER_GROUP_NAME);
            CronTrigger trigger = (CronTrigger) sched.getTrigger(triggerKey);
            if (trigger == null) {
                return;
            }
            String oldTime = trigger.getCronExpression();
            if (!oldTime.equalsIgnoreCase(time)) {
                JobKey jobKey = new JobKey(jobName, JOB_GROUP_NAME);
                JobDetail jobDetail = sched.getJobDetail(jobKey);
                Class<? extends Job> objJobClass = jobDetail.getJobClass();
                Object params = jobDetail.getJobDataMap().get("params");
                removeJob(sched, jobName);
                System.out.println("修改任务：" + jobName);
                addJob(sched, jobName, objJobClass, params, time);
            }
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * @param sched            调度器 *
     * @param sched            调度器
     * @param triggerName
     * @param triggerGroupName
     * @param time
     * @Description: 修改一个任务的触发时间
     * @Title: QuartzManager.java
     */
    public static void modifyJobTime(Scheduler sched, String triggerName, String triggerGroupName, String time) {
        try {
            TriggerKey triggerKey = new TriggerKey(triggerName, triggerGroupName);
            CronTrigger trigger = (CronTrigger) sched.getTrigger(triggerKey);
            if (trigger == null) {
                return;
            }
            String oldTime = trigger.getCronExpression();
            if (!oldTime.equalsIgnoreCase(time)) {
                // 修改时间
                trigger.getTriggerBuilder().withSchedule(cronSchedule(time));
                // 重启触发器
                sched.resumeTrigger(triggerKey);
            }
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * @param sched   调度器
     * @param jobName
     * @Description: 移除一个任务(使用默认的任务组名 ， 触发器名 ， 触发器组名)
     * @Title: QuartzManager.java
     */
    public static void removeJob(Scheduler sched, String jobName) {
        try {
            TriggerKey triggerKey = new TriggerKey(jobName, TRIGGER_GROUP_NAME);
            sched.pauseTrigger(triggerKey);// 停止触发器
            sched.unscheduleJob(triggerKey);// 移除触发器
            JobKey jobKey = new JobKey(jobName, JOB_GROUP_NAME);
            boolean b = sched.deleteJob(jobKey);// 删除任务
            System.out.println(b);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * @param sched            调度器
     * @param jobName
     * @param jobGroupName
     * @param triggerName
     * @param triggerGroupName
     * @Description: 移除一个任务
     * @Title: QuartzManager.java
     */
    public static void removeJob(Scheduler sched, String jobName, String jobGroupName, String triggerName,
                                 String triggerGroupName) {
        try {
            TriggerKey triggerKey = new TriggerKey(triggerName, triggerGroupName);
            sched.pauseTrigger(triggerKey);// 停止触发器
            sched.unscheduleJob(triggerKey);// 移除触发器
            JobKey jobKey = new JobKey(jobName, jobGroupName);
            sched.deleteJob(jobKey);// 删除任务
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * @param sched 调度器
     * @Description:启动所有定时任务
     * @Title: QuartzManager.java
     */
    public static void startJobs(Scheduler sched) {
        try {
            sched.start();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * @param sched 调度器
     * @Description:关闭所有定时任务
     */
    public static void shutdownJobs(Scheduler sched) {
        try {
            if (!sched.isShutdown()) {
                sched.shutdown();
            }
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}
```

封装定时任务详情

为了方便数据的参数，我们需要一个类来封装定时任务相关的配置：比如定时任务的名字，时间表达式，需要的参数等等，我们需要通过该类来封装定时任务配置，然后交给 Scheduler 去添加定时任务。

```java
//一个JobInfo代表一个定时任务
@Data
public class QuartzJobInfo implements Serializable {
    //定时任务类型:是做什么业务的定时
    private Integer type;
    //定时任务名字
    private String jobName;
    //定时任务参数
    private Map<String, Object> params;
    //定时任务时间时间表达式
    private String cronj;
    //定时任务开始执行的时间，到了该时间，定时任务执行
    private Date fireDate;
    //job任务类：任务所属的类
    private Class classz;
    
    //把时间变成时间表达式，在 fireDate 时间到的时候执行
    public void setFireDate(Date fireDate) {
        this.fireDate = fireDate;
        String[] cronArr = new String[7];
        for (int i = 0; i < cronArr.length; i++) {
            cronArr[i] = "";
        }
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(fireDate);
        int second = calendar.get(Calendar.SECOND);
        int minute = calendar.get(Calendar.MINUTE);
        int hour = calendar.get(Calendar.HOUR_OF_DAY);
        int day = calendar.get(Calendar.DAY_OF_MONTH);
        int month = calendar.get(Calendar.MONTH) + 1;
        int year = calendar.get(Calendar.YEAR);

        cronArr[0] = second + "";
        cronArr[1] = minute + "";
        cronArr[2] = hour + "";

        cronArr[3] = day + "";
        cronArr[4] = month + "";
        cronArr[5] = "?";
        cronArr[6] = year + "";

        String cron = StringUtils.join(cronArr," ").trim();
        this.setCronj(cron);
    }

}
```

新建一个Service来添加定时任务

```java
@Service
public class QuartzService {

    //Scheduler的实例工厂
    @Autowired
    private SchedulerFactoryBean schedulerFactoryBean;

    public void addJob(QuartzJobInfo quartzJobInfo) throws SchedulerException {
        QuartzUtils.addJob(schedulerFactoryBean.getScheduler(),//Scheduler容器
                quartzJobInfo.getJobName()   ,//job名字
                quartzJobInfo.getClassz() ,    //Job类的字节码
                quartzJobInfo.getParams(),   //job需要的参数
                quartzJobInfo.getCronj()  //时间规则
                );
    }
}
```

> 测试

```java
@RestController
public class QuartzController {

    @Autowired
    private QuartzService quartzService;

    @RequestMapping("/add")
    public String add() throws SchedulerException {
        //封装job详情对象
        QuartzJobInfo jobInfo = new QuartzJobInfo();
        jobInfo.setJobName("orderexpirejob");
        //10分钟之后执行定时任务
        jobInfo.setFireDate(DateUtils.addSeconds(new Date(),10));
        //参数
        Map<String,Object> map = new HashMap<>();
        map.put("sn","x001");
        jobInfo.setParams(map);
        //job任务
        jobInfo.setClassz(OrderExpireJob.class);
        //添加定时任务
        quartzService.addJob(jobInfo);
        return "添加成功";
    }
}
```

测试效果:

```java
cron = 37 46 15 17 5 ? 2021  #定时任务执行时间，只执行一次
...org.quartz.core.QuartzScheduler          : Scheduler quartzScheduler_$_NON_CLUSTERED started.
OrderExpireJob定时任务执行sn：{sn=x001}
```

### 5.持久化

上面的动态定时任务是通过代码添加的，当程序故障，定时任务失效，如果我们把定时任务数据持久到数据库，当程序重新启动，读取数据库持久的数据可以实习啦定时任务重启。

> 导入Quartz定时器自带的SQL表

....

> 配置连接池

```yaml
spring:
  datasource:
    driver-class-name: com.mysql.jdbc.Driver
    username: root
    password: admin
    jdbcUrl: jdbc:mysql://localhost:3306/pethome?useUnicode=true&characterEncoding=UTF-8
  quartz:
    job-store-type: jdbc #持久化到数据库
    properties:
      org:
        quartz:
          datasource:
            driver-class-name: com.mysql.jdbc.Driver
            jdbcUrl: jdbc:mysql:///pethome-quartz?useUnicode=true&characterEncoding=UTF-8&serverTimezone=UTC
            username: root
            password: admin
          scheduler:
            instancName: clusteredScheduler
            instanceId: AUTO
          jobStore:
            class: org.quartz.impl.jdbcjobstore.JobStoreTX
            driverDelegateClass: org.quartz.impl.jdbcjobstore.StdJDBCDelegate #StdJDBCDelegate说明支持集群
            tablePrefix: QRTZ_
            isClustered: true
            clusterCheckinInterval: 1000
            useProperties: false
          threadPool:
            class: org.quartz.simpl.SimpleThreadPool
            threadCount: 20
            threadPriority: 5
```

> 因为这里指定了数据源,所以我们需要配置了一下数据源

现在有两个数据源，需要在代码中进行DataSource配置

```java
@Configuration
public class QuartzDataSourceConfig {

    //主数据源
    @Bean
    @Primary //主数据库，
    @ConfigurationProperties(prefix = "spring.datasource")
    DataSource dataSource(){
        return DataSourceBuilder.create().build();
    }
    //为quartz创建一个自己数据源
    @Bean
    @QuartzDataSource //quartz数据源
    @ConfigurationProperties(prefix = "spring.quartz.properties.org.quartz.datasource")
    DataSource quartzDataSource(){
        return  DataSourceBuilder.create().build();
    }
}
```

**注意**:如果这个Quartz的数据源库表在其他数据库里面,所以需要单独配置一下数据源,如果本身的数据库配置和Quartz表所在的数据库是在一起的话那么就可以不用分别指定数据源!

如果配置了持久化连接池,那么就要修改原来的URL改为JdbcUrl,否则要报错,要注意!

### 6.订单超时处理逻辑

1. 加入到定时器上:

   ```java
   //添加订单超时
   QuartzJobInfo info = new QuartzJobInfo();
   info.setClassz(OrderPetExpireTimeJob.class);
   info.setFireDate(orderPet.getPayExpireTime());
   String jobName = JOB_NAME_PET_ADOPT_ORDER_EXPIRE+":"+paySn+DateUtil.currentSeconds();
   info.setJobName(jobName);
   Map<String,Object> data = new HashMap<>();
   data.put("orderNo",paySn);
   data.put("jobName",jobName);
   info.setParams(data);
   //        info.setType(TYPE_PET_ADOPT_ORDER_EXPIRE);
   quartzUtils.addJob(info);
   ```

2. 定时任务的逻辑

   ```java
   package cn.miao.common.quartz;
   
   import cn.hutool.core.bean.BeanUtil;
   import cn.hutool.core.convert.Convert;
   import cn.hutool.core.map.MapUtil;
   import cn.miao.common.exception.MiaoRuntimeException;
   import cn.miao.common.util.QuartzUtils;
   import cn.miao.project.domain.pojo.OrderPet;
   import cn.miao.project.domain.pojo.OrderPetDetail;
   import cn.miao.project.domain.pojo.PayBill;
   import cn.miao.project.domain.pojo.Pet;
   import cn.miao.project.mapper.OrderPetDetailMapper;
   import cn.miao.project.mapper.OrderPetMapper;
   import cn.miao.project.mapper.PayBillMapper;
   import cn.miao.project.mapper.PetMapper;
   import com.alipay.easysdk.factory.Factory;
   import com.alipay.easysdk.payment.common.models.AlipayTradeCloseResponse;
   import lombok.SneakyThrows;
   import lombok.extern.slf4j.Slf4j;
   import org.quartz.JobDataMap;
   import org.quartz.JobExecutionContext;
   import org.springframework.beans.factory.annotation.Autowired;
   import org.springframework.scheduling.quartz.QuartzJobBean;
   import org.springframework.scheduling.quartz.SchedulerFactoryBean;
   import org.springframework.stereotype.Component;
   
   import java.util.Date;
   import java.util.List;
   import java.util.Map;
   
   import static cn.miao.common.constant.BaseConst.*;
   
   /**
    * @program: backstageProject
    * @description: 宠物订单超时处理
    * @author: MiaoWei
    * @create: 2021-11-10 20:57
    **/
   @Component
   @Slf4j
   public class OrderPetExpireTimeJob extends QuartzJobBean {
       @Autowired
       private PayBillMapper payBillMapper;
       @Autowired
       private OrderPetMapper orderPetMapper;
       @Autowired
       private SchedulerFactoryBean schedulerFactoryBean;
       @Autowired
       private OrderPetDetailMapper orderPetDetailMapper;
       @Autowired
       private PetMapper petMapper;
   
       @SneakyThrows
       @Override
       protected void executeInternal(JobExecutionContext context) {
           //成功JobDetails中获取参数
           JobDataMap jobDataMap = context.getJobDetail().getJobDataMap();
           Map<String, Object> data = (Map<String, Object>) jobDataMap.get("params");
           if (MapUtil.isEmpty(data) || data.get("orderNo") == null) {
               throw new MiaoRuntimeException("参数异常!");
           }
           /**
            * 参数:订单号
            * 1.查询支付单的支付状态
            *  1.1 除了待支付-删除定时任务
            *  1.2 待支付-修改支付单支付状态为支付取消,修改业务订单表状态为订单超时自动取消, 修改宠物表将库存进行退回,关闭支付宝关单接口
            */
           String orderNo = data.get("orderNo").toString();
           String jobName = data.get("jobName").toString();
           //查询支付单
           PayBill payBill = payBillMapper.selectPayByOrderNo(orderNo);
           OrderPet orderPet = orderPetMapper.selectPayByOrderNo(orderNo);
           if (BeanUtil.isEmpty(payBill) || BeanUtil.isEmpty(orderPet)) {
               throw new MiaoRuntimeException("订单号出现异常信息!");
           }
   
           //查询状态
           //只要不是待支付状态
           if (payBill.getState().compareTo(PAY_STATUS_NOT) != ZERO) {
               //删除定时任务
               QuartzUtils.removeJob(schedulerFactoryBean.getScheduler(), jobName);
               return;
           }
           if (orderPet.getState().compareTo(USER_WAS_SUCC_CREATED) != ZERO) {
               //删除定时任务
               QuartzUtils.removeJob(schedulerFactoryBean.getScheduler(), jobName);
               return;
           }
   
           Date date = new Date();
   
           //下面就是处于待支付的状态了!
           //------------------------------
           //修改支付单支付状态为取消
           payBill.setState(PAY_STATUS_CANCEL);
           payBill.setUpdateTime(date);
           payBill.setLastpaytime(date);
           payBillMapper.updatePayBill(payBill);
   
           //修改订单表支付状态为订单超时自动取消订单
           orderPet.setState(ORDER_AUTO_CANCEL);
           orderPet.setLastUpdateTime(date);
           orderPetMapper.updateOrderPet(orderPet);
   
           //修改宠物pet表,退回库存
           List<OrderPetDetail> details = orderPetDetailMapper.selectPayByOrderNo(orderPet.getOrderSn());
           for (OrderPetDetail item : details) {
               Pet pet = petMapper.selectPetById(item.getPetId());
               pet.setNum(pet.getNum() + Convert.toInt(item.getCount()));
               petMapper.updatePet(pet);
           }
   
           //*
           // 问？如果用户进入了支付页面，还没输入支付密码，正好订单自动超时，这时候
           //订单状态超时，用户又去输入了密码支付，怎么处理？
           //答:可以在订单超时的时候进行手动关闭支付宝订单,这样客户在超时之后输入密码也是不行的!
   
           AlipayTradeCloseResponse response = Factory.Payment.Common().close(orderNo);
           log.info("支付宝关单：{}", response);
   
           //超时之后也要记得删除定时任务
           QuartzUtils.removeJob(schedulerFactoryBean.getScheduler(), jobName);
       }
   }
   ```

   
