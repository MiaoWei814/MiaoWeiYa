# 使用到的技术

## 1. 图片上传-fastdfs

首先这是一个分布式文件系统

![image-20211027225924233](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211027225924233.png)

```
为什么需要分布式文件系统:

在使用Fastdfs之前的单体上传文件缺点:
	1. 图片上传和其他crud请求都在一个服务器进行处理,这样服务器压力会比较大
	2. 不能在集群环境中使用,每一个服务器磁盘都是独立的!
使用fastdfs的优点:
	1.存储量大,因为使用的是分布式集群服务器
	2.单点故障,因为在集群中任何一台服务器出现故障都不会影响整体的运行,效率得到提升

理解:因为在这之前我们服务器使用的是一种单体架构方式,所有请求都是一个服务器处理,图片上传也是上传到本地硬盘中进行存储!而随着项目的不断发展和推进,项目分裂出分布式服务器,那么这个时候文件如果还是用之前的文件上传,那么在集群环境中是不可行的,因为每一个服务器所在的磁盘都是独立的!所以我们需要使用一种分布式文件管理系统进行单独管理上传服务器!

为什么选择fastdfs:
	我们之所以选择它是因为首先它是一种开源的分布式文件系统,它具有高可用、高可靠、负载均衡、冗余备份、线性扩容等特点，它给我的使用感受呢就是存储量大，因为使用单独的服务器集群去管理存储，并且它还是单点故障，也就是说在集群中如果有一台服务器出现了故障那么文件管理系统依然还能运行！那么这就是高可用和高可靠！并且既然是集群那么肯定就是主从复制，主节点负责上传文件而从节点负责文件的读，如果并发量很大的情况下，我们还可以进行线性扩容从节点，这样达到了一个均衡的一个目的！
```

解释:

​	FastDFS 是用 c 语言编写的一款开源的分布式文件系统。FastDFS 为互联网量身定制，充分考虑了`冗余备份`、`负载均衡`、`线性扩容`等机制，并注重高可用、高性能等指标，使用 FastDFS很容易搭建一套`高性能的文件服务器集群`提供文件上传、下载等服务。

​	FastDFS 架构包括 **Tracker server** 和 **Storage server**。客户端请求 Tracker server 进行文件上传、下载，通过 Tracker server 调度最终由 Storage server 完成文件上传和下载。

每个部分的作用:

1. **Tracker server**
   - 作用是`负载均衡和任务调度`，通过 Tracker server 在文件上传时可以根据一些策略找到 Storage server 提供文件上传服务。可以将 tracker 称为追踪服务器或调度服务器。
2. **Storage server**
   - 作用是`文件存储`，客户端上传的文件最终存储在 Storage 服务器上，Storage server 没有实现自己的文件系统而是利用操作系统 的文件系统来管理文件。可以将storage称为存储服务器。

**理解**:Fastdfs是一个分布式文件管理系统,是一种以负载均衡、冗余备份、线性扩容等机制的服务器集群,既然是集群那么也意味着是一种主从复制的结构,主机负责上传从机负责读这样极大的提高了程序的性能问题,因为一般读的时间大于写的时间,Fastdfs主要以`Trackert server`和`Storage server`,前者主要来接收文件上传根据相关策略来决定使用哪一个服务器进行存储,这也是一种负载均衡的机制!而Storage Server主要以存储为主,简单的可以理解为:前者来决定上传到哪一个服务器是一个决定者,而后者是负责存储的,

### 1.1 架构

![image-20211029155647214](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211029155647214.png)

服务端两个角色:

- Tracker：`管理集群`，tracker 也可以实现集群。每个 tracker 节点地位平等。收集 Storage 集群的状态。
- Storage：`实际保存文件`  Storage 分为多个组，每个组之间保存的文件是不同的。每个组内部可以有多个成员，组成员内部保存的内容是一样的，组成员的地位是一致的，没有主从的概念

相关地址:

- 官方网站：https://github.com/happyfish100/
- 配置文档：https://github.com/happyfish100/fastdfs/wiki/
- 参考资料：https://www.oschina.net/question/tag/fastdfs
- Java客户端：https://github.com/happyfish100/fastdfs-client-java

### 1.2 上传流程

![image-20211029155832268](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211029155832268.png)

客户端上传文件后存储服务器将文件 ID 返回给客户端，此文件 ID 用于以后访问该文件的索引信息。文件索引信息包括：组名，虚拟磁盘路径，数据两级目录，文件名。

![image-20211029160000116](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211029160000116.png)

其中：

- 组名（卷）：文件上传后所在的 storage 组名称，在文件上传成功后有 storage 服务器返回，需要客户端自行保存。
- 虚拟磁盘路径：storage 配置的虚拟路径，与磁盘选项 store_path*对应。如果配置了 store_path0 则是 M00，如果配置了 store_path1 则是 M01，以此类推
- 数据两极目录：storage 服务器在每个虚拟磁盘路径下创建的两级目录，用于存储数据文件。
- 文件名：与文件上传时不同。是由存储服务器根据特定信息生成，文件名包含：源存储服务器 IP 地址、文件创建时间戳、文件大小、随机数和文件拓展名等信息。

### 1.3 使用：

这是maven：

```xml
<!--fastdfs分布式文件管理系统-->
        <dependency>
            <groupId>cn.bestwu</groupId>
            <artifactId>fastdfs-client-java</artifactId>
            <version>1.27</version>
        </dependency>
```

添加配置文件fdfs_client.conf ，将其中的服务器地址设置为192.168.25.133

```c#
tracker_server=47.95.117.210:22122
```

这是封装的工具类:

```java
package cn.miao.basic.util;

import org.csource.common.NameValuePair;
import org.csource.fastdfs.*;

import java.net.URL;

/**
 * @program: backstageProject
 * @description: fastDfs工具类
 * @author: MiaoWei
 * @create: 2021-10-27 20:16
 **/
public class FastDfsUtil {
    private static final String CONF_FILENAME = "F:\\源码时代\\学习项目\\twoPoject\\backstageProject\\src\\main\\resources\\fdfs_client.conf";
    //从classpath
//    public static String CONF_FILENAME = FastDfsUtil.class.getClassLoader()
//            .getResource("fdfs_client.conf").getFile();


    public static void main(String[] args) {
        URL resource = FastDfsUtil.class.getClassLoader()
                .getResource("fdfs_client.conf");
        String resourceFile = resource.getFile();
        System.out.println("resourceFile = " + resourceFile);
    }
    /**
     * 上传文件
     *
     * @param file
     * @param extName
     * @return
     */
    public static String upload(byte[] file, String extName) {

        try {

            ClientGlobal.init(CONF_FILENAME);

            TrackerClient tracker = new TrackerClient();
            TrackerServer trackerServer = tracker.getConnection();
            StorageServer storageServer = null;

            StorageClient storageClient = new StorageClient(trackerServer, storageServer);
            NameValuePair[] nvp = new NameValuePair[]{
                    new NameValuePair("age", "18"),
                    new NameValuePair("sex", "male")
            };
            String[] fileIds = storageClient.upload_file(file, extName, nvp);

//            System.out.println(fileIds.length);
//            System.out.println("组名：" + fileIds[0]); // group1
//            System.out.println("路径: " + fileIds[1]); // saldfj/sdfas/sdaf.jpg
            return "/" + fileIds[0] + "/" + fileIds[1];

        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    /**
     * 上传文件
     *
     * @param extName
     * @return
     */
    public static String upload(String path, String extName) {

        try {
            ClientGlobal.init(CONF_FILENAME);

            TrackerClient tracker = new TrackerClient();
            TrackerServer trackerServer = tracker.getConnection();
            StorageServer storageServer = null;
            StorageClient storageClient = new StorageClient(trackerServer, storageServer);
            String fileIds[] = storageClient.upload_file(path, extName, null);

//            System.out.println(fileIds.length);
//            System.out.println("组名：" + fileIds[0]);
//            System.out.println("路径: " + fileIds[1]);
            return "/" + fileIds[0] + "/" + fileIds[1];

        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    /**
     * 下载文件
     *
     * @param groupName
     * @param fileName
     * @return
     */
    public static byte[] download(String groupName, String fileName) {
        try {

            ClientGlobal.init(CONF_FILENAME);

            TrackerClient tracker = new TrackerClient();
            TrackerServer trackerServer = tracker.getConnection();
            StorageServer storageServer = null;

            StorageClient storageClient = new StorageClient(trackerServer, storageServer);
            byte[] b = storageClient.download_file(groupName, fileName);
            return b;
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }


    /**
     * 删除文件
     *
     * @param groupName
     * @param fileName
     */
    public static void delete(String groupName, String fileName) {
        try {
            ClientGlobal.init(CONF_FILENAME);

            TrackerClient tracker = new TrackerClient();
            TrackerServer trackerServer = tracker.getConnection();
            StorageServer storageServer = null;

            StorageClient storageClient = new StorageClient(trackerServer,
                    storageServer);
            int i = storageClient.delete_file(groupName, fileName);
            System.out.println(i == 0 ? "删除成功" : "删除失败:" + i);
        } catch (Exception e) {
            e.printStackTrace();
            throw new RuntimeException("删除异常," + e.getMessage());
        }
    }
}
```

浏览器访问的是:[http://122.51.119.246:8888/group1/M00/00/00/wKgZhVkMP4KAZEy-AAA-tCf93Fo973.jpg](http://192.168.25.133/group1/M00/00/00/wKgZhVkMP4KAZEy-AAA-tCf93Fo973.jpg)

>  上传用22122端口
>
>  访问用8888端口



## 2.前端服务器

我们之前的前端使用的vue脚手架搭建起来的,所以可以使用npm run dev进行启动服务,而如果是纯HTML那么我们该如何去启动呢?如何方便我们调试呢?

```properties
# 安装
npm install -g live-server
# 启动,指定端口
live-server --port=80  
```

这种呢就是把当前路径下的web资源当做一个服务的内容启动起来，并可以指定端口

![image-20211029180035016](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211029180035016.png)

