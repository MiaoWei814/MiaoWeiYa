## 1.SSM上传文件为null

我在项目1的时候上传文件困扰我一个晚上这是前端上传文件,每个参数值都是正确的,甚至我直接拷贝老师的但依然没正确上传到后端,经过我不懈的论证和测试,经过发现,哪怕我新建一个简单的html的form表单进行上传也依然是不可行的,那么此刻我把目光望向了配置文件;结果是可以的,

```xml-dtd
在springMVC配置文件里:
<!--5.文件上传解析器-->
    <bean id="multipartResolver"
           class="org.springframework.web.multipart.commons.CommonsMultipartResolver">
    <!-- 设置上传文件的最大尺寸为 5MB -->
    <property name="maxUploadSize">
        <value>5242880</value>
    </property>
```

完美解决,应该是设置上传文件大小,导致被拦截上传不上去;

**注**:其他代码较多就不添加,其上传文件要素:前端:form添加`enctype="multipart/form-data"`表示这是一个混合表单,上传文件的type为file,name值为后端接收要对应,后端:MultipartFile name来接收,

导入依赖:

```xml-dtd
<!-- 文件上传 -->
<dependency>
	<groupId>commons-fileupload</groupId>
    <artifactId>commons-fileupload</artifactId>
    <version>1.2.2</version>
</dependency>
<dependency>
	<groupId>commons-io</groupId>
    <artifactId>commons-io</artifactId>
    <version>2.4</version>
</dependency>
```

## 2.同时上传文件和数据

今天我尝试使用Postman模拟文件跟参数一起上传的时候,尝试很多种只有这几种才可以:

后端:

```java
    @PostMapping("/test")
    public Department test(@RequestParam("file") MultipartFile file,@RequestParam String name){
        System.out.println(file);
        System.out.println(name);
         return DepartmentService.selectDepartmentById(1L);
    }
```

postman:

![image-20211020140033428](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/imgs/image-20211020140033428.png)

输出:
![image-20211020140054785](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/imgs/image-20211020140054785.png)	

> 还有一种方法就是将文件和参数一起放在一个对象里面去:

后端:

```java
@PostMapping("/test")
    public Department test(test test){
        System.out.println(test);
         return DepartmentService.selectDepartmentById(1L);
    }
@Data
public class test {
    private MultipartFile file;
    private String name;
}
```

postman:

![image-20211020140402594](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/imgs/image-20211020140402594.png)

输出:

![image-20211020140428452](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/imgs/image-20211020140428452.png)

> 总结:

一旦文件和参数一起放在对象里面,那么我们使用注解`@RequestBody`就无法获取注入!只能将一个对象不加任何注解放在那里就可以接收!

其他就不加解释了,多种方法我都尝试了!只有上述两种能够同时带上参数,并且也只有这个地方能够选择文件上传,其他碧如json是无法的!

> 注意我们上传文件还可以加上注解@RequestPart表示上传文件!

-----

这里附成功案例：

Controller:

```java
/**
     * 新增更新设备
     */
    @PostMapping("/add")
    @ApiOperation(value = "增加或者修改设备", notes = "增加或者修改设备")
    public DataResult<ResultExitDeviceVo> add(MultipartFile file, @Validated UpDeviceAddDto dto) {
        return deviceService.addDevice(dto, file);
    }
```

注意: 这里文件的话可以放在外面,当然也可以写在对象里面;

1. 可以用@Validated来进行对象验证 是可以的 ,但不能加`@RequestBody`来进行接收,否则就会失败! 因为会序列化为JSON

```java
	@NotEmpty(message = "请输入设备型号")
    @ApiModelProperty(value = "设备型号")
    private String deviceModel;

 	@ApiModelProperty(value = "文件")
    private MultipartFile file;
```

2. 这里文件的验证不能用JSR303来进行处理, 已经尝试是没有效果的!

Apifox:

![image-20220312150832125](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/imgs/202203121508261.png)

可以看出:

1. 数据和文件`必须`在body中以form-data方式来传递

## 3.maven打包

这里展示项目如何进行打包:

比如我这里是个微服务，A服务依赖于B服务，那么我们首先就得先打包B服务之后再去打包A服务，因为A服务依赖的嘛！

![15610948d6eb6d5d.png](https://s3.bmp.ovh/imgs/2022/03/15610948d6eb6d5d.png)

然后在对应我们需要打包的服务中，在pom.xml文件中写入:

```xml
<build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <jvmArguments>-Dfile.encoding=UTF-8</jvmArguments>
                </configuration>
                <executions>
                    <execution>
                        <goals>
                            <goal>repackage</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>
```

这个是很重要的, 不然你打包的话可以明显发现`jar`包大小很小的! 没有引入成功的!

然后继续执行`install`就可以啦!

## 4. 加锁

踩坑的场景: 自己在开发过程中遇到一个场景，在一张表中一个userid和日期yyyy-mm-dd进行绑定，也就是说一个用户一天只能存在一条记录，但是这个接口的有可能出现瞬间并发的情况就会导致出现两条一模一样的！

这是之前的代码：

```java
@Override
    public DataResult<String> setUserHealth(UserHealthDto dto, HttpServletRequest request) {
        Integer userId = LoginContext.getLoginInfoByToken().getUserId();
        String source = request.getHeader("source");
        Date date = new Date();

        UserHealth health = new UserHealth();
        //.....

        //这里查询指定日期(yyyy-MM-dd)和userid是否存在
        UserHealth dateHealth= userHealthMapper.dateHealth(userId, DateUtil.format(date, DatePattern.NORM_DATE_PATTERN), STATUS_VALID);
        //不存在就覆盖
        //因为并发导致有两条线程都查询为空,然后堵在这里,然后第一条新增然后第二条也新增成功,导致数据库出现两条一模一样的
        if (BeanUtil.isEmpty(dateHealth)) {
            userHealthMapper.insert(health);
        }else{
            health.setUserHealthId(dateHealth.getUserHealthId());
            if (Convert.toInt(source) == 1) {
                health.setStepNum(Convert.toInt(dateHealth.getStepNum(), 0) + Convert.toInt(dto.getStepNum()));
            }
                userHealthMapper.updateById(health);
            }
        return DataResult.success();
    }
```

解读: 不管是因为网络的原因还是并发多线程的原因，也就是说现在有两条线程瞬间都通过数据库查询，此时都是为空的，然后走判断就直接`insert`了，那么如何避免这种情况呢？

解决办法：

1. 数据库加索引

   答：对userId和日期加一个唯一索引，这样就会第一个插入成功第二个就会报异常，但是我们有的时候并不希望将数据库的异常返回给客户，所以我们就要对其try-catch捕获。----不推荐

2. 加锁

   答：加锁顾名思义就是要这段代码上一个锁，让同时只有一个线程才能进来，这样下一个线程就不会走插入的操作--推荐

改造后的代码：

```java
        synchronized (UserHealthServiceImpl.class) {
            //这里查询指定日期(yyyy-MM-dd)和userid是否存在
            UserHealth dateHealth= userHealthMapper.dateHealth(userId, DateUtil.format(date, DatePattern.NORM_DATE_PATTERN), STATUS_VALID);
            //不存在就覆盖
            if (BeanUtil.isEmpty(dateHealth)) {//因为并发导致有两条线程都查询为空,然后堵在这里,然后第一条新增然后第二条也新增成功,导致数据库出现两条一模一样的
                userHealthMapper.insert(health);
            }else{
                health.setUserHealthId(dateHealth.getUserHealthId());
                if (Convert.toInt(source) == 1) {
                    health.setStepNum(Convert.toInt(dateHealth.getStepNum(), 0) + Convert.toInt(dto.getStepNum()));
                }
                userHealthMapper.updateById(health);
            }
        }
```

其实跟简单,就直接在外面套个关键字锁住，就可以了！

> 常见加锁：
>
> 1. 单机，就Java中的同步关键字就好
> 2. 分布式部署，就MySQL悲观锁，redis分布式锁

## 5. 在事务下调用private是生效的

之前很好奇，在一个代码里加了事务然后去调用private，如果在private里发生异常那么此时事务会不会生效，结果是可以的，经测试是不会修改数据库的，事务会发生回滚！

```java
@Override
@Transactional(rollbackFor = Exception.class)
public DataResult<HashMap<String, Object>> exit(ExitChartAndVideoDto dto) {
    //...
	this.checkCataloguePicture(...)
}

private void checkCataloguePicture(VideoPicture picture) {
        int i = 1 / 0;
       //...
}
```

这是之前的：

![image-20220609092120362](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/202206090921460.png)

![image-20220609092138749](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/202206090921792.png)

请求结果还是没发生变化！

## 6.方法内部使用事务不生效解决办法：

**关于事务在同一个类中，一个方法调用另一个方法 事务不回滚问题**

起因：

我需要在一个方法去循环调用一组操作数据库的数据，但是每一次循环我需要保证事务，那么我就想把这组循环中的东西抽出来然后在方法上加事务，我发现是不会生效的！

修改后：

```xml
<dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-aop</artifactId>
        </dependency>
        <dependency>
            <groupId>org.aspectj</groupId>
            <artifactId>aspectjweaver</artifactId>
            <version>1.9.5</version>
        </dependency>
```

在springboot启动类上，添加注解，如下：

```java
package com.szl;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
import org.springframework.context.annotation.EnableAspectJAutoProxy;

// 表示通过aop框架暴露该代理对象,AopContext能够访问
@EnableAspectJAutoProxy(exposeProxy = true)
@SpringBootApplication
public class DemoSzlApplication {

    public static void main(String[] args) {
        SpringApplication.run(DemoSzlApplication.class, args);
    }
}
```

实现类：

```java
package com.szl.service.impl;

import com.szl.mapper.DemoSzlMapper;
import com.szl.mapper.entity.DemoSzl;
import com.szl.service.DemoSzlService;
import org.springframework.aop.framework.AopContext;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;
import java.beans.Transient;
import java.util.Date;

@Service("demoSzlService")
public class DemoSzlServiceImpl implements DemoSzlService {
    @Autowired
    private DemoSzlMapper demoSzlMapper;

    @Override
    @Transactional
    public void saveTest1() {
        DemoSzl ds1 = new DemoSzl("szl001", new Date());
        demoSzlMapper.insert(ds1);
        try {
            // 此处如果方法执行失败，就可以回滚成功。
            ((DemoSzlServiceImpl) AopContext.currentProxy()).saveTest2();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @Override
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void saveTest2() {
        try {
            DemoSzl ds2 = new DemoSzl("szl002", new Date());
            demoSzlMapper.insert(ds2);
            int t = 1 / 0;
        } catch (Exception e) {
            e.printStackTrace();
            throw new RuntimeException("错误");
        }
    }
}
```

这里我自己个人想法：

通过`AopContext.currentProxy()`获取到当前类的代理，然后通代理去调用当前类的方法，然后调用的方法被事务给代理，那么才会生效，如果说直接在事务体内进行获取当前代理，也可以获取到但当前就不是代理了，那么相应的mapper这里代理就是null！
