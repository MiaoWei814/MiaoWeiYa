## 1.SSM上传文件为null

我在项目1的时候上传文件困扰我一个晚上这是前端上传文件,每个参数值都是正确的,甚至我直接拷贝老师的但依然没正确上传到后端,经过我不懈的论证和测试,经过发现,哪怕我新建一个简单的html的form表单进行上传也依然是不可行的,那么此刻我把目光望向了配置文件;结果是可以的,

```xml-dtd
在springMVC配置文件里:
<!--5.文件上传解析器-->
    <bean id="multipartResolver"
           class="org.springframework.web.multipart.commons.CommonsMultipartResolver">
    <!-- 设置上传文件的最大尺寸为 5MB -->
    <property name="maxUploadSize">
        <value>5242880</value>
    </property>
```

完美解决,应该是设置上传文件大小,导致被拦截上传不上去;

**注**:其他代码较多就不添加,其上传文件要素:前端:form添加`enctype="multipart/form-data"`表示这是一个混合表单,上传文件的type为file,name值为后端接收要对应,后端:MultipartFile name来接收,

导入依赖:

```xml-dtd
<!-- 文件上传 -->
<dependency>
	<groupId>commons-fileupload</groupId>
    <artifactId>commons-fileupload</artifactId>
    <version>1.2.2</version>
</dependency>
<dependency>
	<groupId>commons-io</groupId>
    <artifactId>commons-io</artifactId>
    <version>2.4</version>
</dependency>
```

## 2.同时上传文件和数据

今天我尝试使用Postman模拟文件跟参数一起上传的时候,尝试很多种只有这几种才可以:

后端:

```java
    @PostMapping("/test")
    public Department test(@RequestParam("file") MultipartFile file,@RequestParam String name){
        System.out.println(file);
        System.out.println(name);
         return DepartmentService.selectDepartmentById(1L);
    }
```

postman:

![image-20211020140033428](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211020140033428.png)

输出:
![image-20211020140054785](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211020140054785.png)	

> 还有一种方法就是将文件和参数一起放在一个对象里面去:

后端:

```java
@PostMapping("/test")
    public Department test(test test){
        System.out.println(test);
         return DepartmentService.selectDepartmentById(1L);
    }
@Data
public class test {
    private MultipartFile file;
    private String name;
}
```

postman:

![image-20211020140402594](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211020140402594.png)

输出:

![image-20211020140428452](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211020140428452.png)

> 总结:

一旦文件和参数一起放在对象里面,那么我们使用注解`@RequestBody`就无法获取注入!只能将一个对象不加任何注解放在那里就可以接收!

其他就不加解释了,多种方法我都尝试了!只有上述两种能够同时带上参数,并且也只有这个地方能够选择文件上传,其他碧如json是无法的!

> 注意我们上传文件还可以加上注解@RequestPart表示上传文件!

-----

这里附成功案例：

Controller:

```java
/**
     * 新增更新设备
     */
    @PostMapping("/add")
    @ApiOperation(value = "增加或者修改设备", notes = "增加或者修改设备")
    public DataResult<ResultExitDeviceVo> add(MultipartFile file, @Validated UpDeviceAddDto dto) {
        return deviceService.addDevice(dto, file);
    }
```

注意: 这里文件的话可以放在外面,当然也可以写在对象里面;

1. 可以用@Validated来进行对象验证 是可以的 ,但不能加`@RequestBody`来进行接收,否则就会失败! 因为会序列化为JSON

```java
	@NotEmpty(message = "请输入设备型号")
    @ApiModelProperty(value = "设备型号")
    private String deviceModel;

 	@ApiModelProperty(value = "文件")
    private MultipartFile file;
```

2. 这里文件的验证不能用JSR303来进行处理, 已经尝试是没有效果的!

Apifox:

![image-20220312150832125](https://gitee.com/miawei/pic-go-img/raw/master/imgs/202203121508261.png)

可以看出:

1. 数据和文件`必须`在body中以form-data方式来传递

## 3.maven打包

这里展示项目如何进行打包:

比如我这里是个微服务，A服务依赖于B服务，那么我们首先就得先打包B服务之后再去打包A服务，因为A服务依赖的嘛！

![15610948d6eb6d5d.png](https://s3.bmp.ovh/imgs/2022/03/15610948d6eb6d5d.png)

然后在对应我们需要打包的服务中，在pom.xml文件中写入:

```xml
<build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <jvmArguments>-Dfile.encoding=UTF-8</jvmArguments>
                </configuration>
                <executions>
                    <execution>
                        <goals>
                            <goal>repackage</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>
```

这个是很重要的, 不然你打包的话可以明显发现`jar`包大小很小的! 没有引入成功的!

然后继续执行`install`就可以啦!

## 4. 加锁

踩坑的场景: 自己在开发过程中遇到一个场景，在一张表中一个userid和日期yyyy-mm-dd进行绑定，也就是说一个用户一天只能存在一条记录，但是这个接口的有可能出现瞬间并发的情况就会导致出现两条一模一样的！

这是之前的代码：

```java
@Override
    public DataResult<String> setUserHealth(UserHealthDto dto, HttpServletRequest request) {
        Integer userId = LoginContext.getLoginInfoByToken().getUserId();
        String source = request.getHeader("source");
        Date date = new Date();

        UserHealth health = new UserHealth();
        //.....

        //这里查询指定日期(yyyy-MM-dd)和userid是否存在
        UserHealth dateHealth= userHealthMapper.dateHealth(userId, DateUtil.format(date, DatePattern.NORM_DATE_PATTERN), STATUS_VALID);
        //不存在就覆盖
        //因为并发导致有两条线程都查询为空,然后堵在这里,然后第一条新增然后第二条也新增成功,导致数据库出现两条一模一样的
        if (BeanUtil.isEmpty(dateHealth)) {
            userHealthMapper.insert(health);
        }else{
            health.setUserHealthId(dateHealth.getUserHealthId());
            if (Convert.toInt(source) == 1) {
                health.setStepNum(Convert.toInt(dateHealth.getStepNum(), 0) + Convert.toInt(dto.getStepNum()));
            }
                userHealthMapper.updateById(health);
            }
        return DataResult.success();
    }
```

解读: 不管是因为网络的原因还是并发多线程的原因，也就是说现在有两条线程瞬间都通过数据库查询，此时都是为空的，然后走判断就直接`insert`了，那么如何避免这种情况呢？

解决办法：

1. 数据库加索引

   答：对userId和日期加一个唯一索引，这样就会第一个插入成功第二个就会报异常，但是我们有的时候并不希望将数据库的异常返回给客户，所以我们就要对其try-catch捕获。----不推荐

2. 加锁

   答：加锁顾名思义就是要这段代码上一个锁，让同时只有一个线程才能进来，这样下一个线程就不会走插入的操作--推荐

改造后的代码：

```java
        synchronized (UserHealthServiceImpl.class) {
            //这里查询指定日期(yyyy-MM-dd)和userid是否存在
            UserHealth dateHealth= userHealthMapper.dateHealth(userId, DateUtil.format(date, DatePattern.NORM_DATE_PATTERN), STATUS_VALID);
            //不存在就覆盖
            if (BeanUtil.isEmpty(dateHealth)) {//因为并发导致有两条线程都查询为空,然后堵在这里,然后第一条新增然后第二条也新增成功,导致数据库出现两条一模一样的
                userHealthMapper.insert(health);
            }else{
                health.setUserHealthId(dateHealth.getUserHealthId());
                if (Convert.toInt(source) == 1) {
                    health.setStepNum(Convert.toInt(dateHealth.getStepNum(), 0) + Convert.toInt(dto.getStepNum()));
                }
                userHealthMapper.updateById(health);
            }
        }
```

其实跟简单,就直接在外面套个关键字锁住，就可以了！

> 常见加锁：
>
> 1. 单机，就Java中的同步关键字就好
> 2. 分布式部署，就MySQL悲观锁，redis分布式锁

