# 记录

## 1.mybatis-plus 2.2分页

```java
前端请求:
Page<ReviewArticleVo> page = new Page<>(pageIndex, pageSize);
业务类(将page传递进来):
List<ReviewArticleVo> list=articleCommentMapper.selectCommentList(page, 参数, 参数);
mapper:
List<ReviewArticleVo> selectCommentList(@Param("page") Pagination page, @Param("id") Integer id, @Param("type") Integer type);
```

注意:这里在mapper中page必须位于第一个,并且要指定参数名为page!

配置类:

```java
@Configuration
@MapperScan("com.beoka.iot.mapper") //mapper接口扫描
@EnableTransactionManagement  //事务管理
public class MybatisPlusConfig {

    /**
     * 分页插件
     */
    @Bean
    public PaginationInterceptor paginationInterceptor() {
        return new PaginationInterceptor();
    }
}
```

## 2. mybatis使用resultMap采用select单独获取SQL

首先这是博客链接:https://blog.csdn.net/cczakai/article/details/7023069

业务场景: 在业务中我需要拿到SQL中的某条数据的值去获取另外一张表的数据,通常这种情况是可以关联来获取的，但存储的是以逗号分隔id，如果用Java那么就要循环去发送SQL语句，那么这里就用mybatis的动态标签让代码显得更优雅吧！

mybatis：

```mysql
<!--这是正常的获取SQL-->
<select id="queryCatalogueList" resultMap="selectCatalogueListMap">
        select
           ......
</select>

<!--这是映射标签-->
<resultMap id="selectCatalogueListMap" type="com.beoka.iot.project.catalogue.domain.vo.QueryCatalogueList">
        <association property="usePositionTextList" column="usePositionMap" select="joinPosition"/>
</resultMap>

<!--这是单独获取的SQL-->
<select id="joinPosition" resultType="java.lang.String">
        select position_name from c_position where position_id in (${usePosition}) and deleted=1
</select>
```

解释:

1.`column`:获取SQL的字段作为参数传递 

2.`select`:调用动态SQL执行SQL语句

3.`property`:执行完毕将结果映射到这个对象属性中!

注意:如果这里执行SQL返回也是需要用resultMap那样去映射,那么我们也可以在`<association>`中增加`resultMap`来达到目的!

## 3.评论场景下上传表情

前提：有一些业务场景下比如社区，就有发布文章然后有一些用户对其评论，那么势必少不了带有表情的上传！

maven：

```xml-dtd
<dependency>
  <groupId>com.vdurmont</groupId>
  <artifactId>emoji-java</artifactId>
  <version>5.1.1</version>
</dependency>
```

demo:

```java
@GetMapping("test")
public String test(@RequestParam String str){
    System.out.println(str.length()); //打印可以看出表情是占2个char字符的位置
    //转HTML
    String s = EmojiParser.parseToHtmlDecimal(str);
    System.out.println(s);
    //还原
    String toUnicode = EmojiParser.parseToUnicode(s);
    System.out.println(toUnicode);
    //去除表情
    System.out.println(EmojiParser.removeAllEmojis(str));//把表情去除
    return toUnicode;
}
```

> 相关链接地址:
>
> GitHub:https://github.com/vdurmont/emoji-java
>
> CSDN:https://blog.csdn.net/a1359029494/article/details/89814546

**注意:**APP端的话就不需要转义了,也就是说输入什么内容就直接请求到后端去，然后后端接收到之后就转义为HTML然后去存储到数据库中去，然后在查询返回的地方就还原表情，这样的话既不动数据库也不改前端，真好！

我认为这个基本上已经够用了,当然我也得附上我的结果截图，不然又是无图无真香

这是控制台打印：

![image-20220319100553359](https://gitee.com/miawei/pic-go-img/raw/master/imgs/202203191006490.png)

apifox:

![image-20220319100952824](https://gitee.com/miawei/pic-go-img/raw/master/imgs/202203191009877.png)

## 4.feigin的异步调用

业务场景：比如点赞这种需要通过openFigin去调用另外发消息的服务，但我又不需要返回值只需要发送一个请求就行了，所以就需要这种异步请求的方式！

feiginClient:

```java
import com.beoka.iot.domain.message.to.InMessageSend;
import com.beoka.iot.feigin.back.SendMessageFallBack;
import com.beoka.iot.result.DataResult;
import com.netflix.hystrix.HystrixCommand;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;

/**
 * 发送消息
 *
 * @author MiaoDaWei
 * @date 2022/03/01
 */
@FeignClient(value = "beokaIot-common",fallback  = SendMessageFallBack.class)
public interface SendMessage {

    /**
     * 发送消息-异步调用
     *
     * @return {@link String}
     */
    @PostMapping("/message/sendMessages")
    HystrixCommand<DataResult> sendMessages(@RequestBody InMessageSend in);
}
```

**注意**：这里feigin的基本使用我就无需多讲,只需要记住`HystrixCommand`的泛型就是该feigin返回的结果

降级类:

```java
/**
 *
 *发消息降级类
 * @author MiaoDaWei
 * @date 2022/02/26
 */
@Component
public class SendMessageFallBack implements SendMessage {
    private static final Setter hystrixCommandGroupKey =
            Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey("SendMessage"));

    @Override
    public HystrixCommand<DataResult> sendMessages(InMessageSend in) {
        return new HystrixCommand<DataResult>(hystrixCommandGroupKey) {
            @Override
            protected DataResult run() throws Exception {
                return DataResult.success();
            }
        };
    }
}
```

**注意**：`asKey`的参数名跟feiginClient的类名保持一致即可!

然后在调用的一方:

```java
//这里我就直接copy的大致就是这个意思,核心就是通过后面 .queue()来调用,然后如果要获取值就通过返回值的get()来获取
Future<User> future = userApi.getByTokenUser(token).queue();
return future.get();
```

这是yml:

```yaml
feign:
  sentinel:
    enabled: true #开启sentinel
```

-----

在调用的时候如果背调方需要token等header里的内容来进行验证,那么此时就会发生一个问题：

报：`java.io.IOException: too many bytes written`

经检查应该在传递的时候造成header的写入的头数据过大造成的!

修改:

```java
@Component
public class TokenFeignClientInterceptor implements RequestInterceptor {

  /**
   * 通过feign调用微服务之前都先检查下头文件，将请求头文件中的令牌数据再放入到header中，再调用其他微服务
   */
  @Override
  public void apply(RequestTemplate requestTemplate) {
    try {
      ServletRequestAttributes servletRequestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
      if (null != servletRequestAttributes) {
        HttpServletRequest request = servletRequestAttributes.getRequest();
        // 获取所有头文件信息的key
        Enumeration<String> headerNames = request.getHeaderNames();
        if (null != headerNames) {
          while (headerNames.hasMoreElements()) {
            // 获取头文件的key和value
            String headerName = headerNames.nextElement();
            String headerValue = request.getHeader(headerName);
            // 跳过content-length，不然可能会报too many bites written问题
            if ("content-length".equalsIgnoreCase(headerName)) {
              continue;
            }
            // 将令牌数据添加到头文件中，当用feign调用的时候，会传递给下一个微服务
            requestTemplate.header(headerName, headerValue);
          }
        }
      }
    } catch (Exception e) {
      e.printStackTrace();
    }
  }
}
```

这个拦截器大致的意思就是将请求拦截到，然后循环获取请求中的header的东西，然后判断是否包含`content-length`如果包含就过滤掉，然后将其他header内的东西添加到新的请求中去！

yaml：

```yaml
feign:
  sentinel:
    enabled: true #开启sentinel
  client:
    config:
      default:
        connectTimeout: 5000
        readTimeout: 5000
        loggerLevel: basic
        requestInterceptors: com.beoka.iot.interceptor.TokenFeignClientInterceptor
```

**注意**：

记住：这里类上我加了注解`@Component`，从相关博客上来说这里我是不确定的！总之，现在都加上是可以正常调用的，但我没测试过我觉得应该两者弃一个应该是，要么放弃`@Component`要么就不需要在yaml指定requestInterceptors的具体路径!

> 这是相关csdn链接:https://blog.csdn.net/qq_36737803/article/details/123259702

