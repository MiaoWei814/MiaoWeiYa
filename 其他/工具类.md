

# 工具类

## 1. 获取IP(若依的)

AddressUtils：

```java
package com.beoka.iot.util.ip;

import com.alibaba.fastjson.JSONObject;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * 获取地址类
 * 
 * @author beoka
 */
public class AddressUtils
{
    private static final Logger log = LoggerFactory.getLogger(AddressUtils.class);

    // IP地址查询
    public static final String IP_URL = "http://whois.pconline.com.cn/ipJson.jsp";

    // 未知地址
    public static final String UNKNOWN = "XX XX";

    public static String getRealAddressByIP(String ip)
    {
        String address = UNKNOWN;
        // 内网不查询
        if (IpUtils.internalIp(ip))
        {
            return "内网IP";
        }
        if (true)
        {
            try
            {
                String rspStr = HttpUtils.sendGet(IP_URL, "ip=" + ip + "&json=true", "GBK");
                if (StringUtils.isEmpty(rspStr))
                {
                    log.error("获取地理位置异常 {}", ip);
                    return UNKNOWN;
                }
                JSONObject obj = JSONObject.parseObject(rspStr);
                String region = obj.getString("pro");
                String city = obj.getString("city");
                return String.format("%s %s", region, city);
            }
            catch (Exception e)
            {
                log.error("获取地理位置异常 {}", ip);
            }
        }
        return address;
    }
}
```

EscapeUtil:

```java
package com.beoka.iot.util.ip;

import cn.hutool.http.HTMLFilter;
import org.apache.commons.lang3.StringUtils;

/**
 * 转义和反转义工具类
 * 
 * @author beoka
 */
public class EscapeUtil
{
    public static final String RE_HTML_MARK = "(<[^<]*?>)|(<[\\s]*?/[^<]*?>)|(<[^<]*?/[\\s]*?>)";

    private static final char[][] TEXT = new char[64][];

    static
    {
        for (int i = 0; i < 64; i++)
        {
            TEXT[i] = new char[] { (char) i };
        }

        // special HTML characters
        TEXT['\''] = "&#039;".toCharArray(); // 单引号
        TEXT['"'] = "&#34;".toCharArray(); // 单引号
        TEXT['&'] = "&#38;".toCharArray(); // &符
        TEXT['<'] = "&#60;".toCharArray(); // 小于号
        TEXT['>'] = "&#62;".toCharArray(); // 大于号
    }

    /**
     * 转义文本中的HTML字符为安全的字符
     * 
     * @param text 被转义的文本
     * @return 转义后的文本
     */
    public static String escape(String text)
    {
        return encode(text);
    }

    /**
     * 还原被转义的HTML特殊字符
     * 
     * @param content 包含转义符的HTML内容
     * @return 转换后的字符串
     */
    public static String unescape(String content)
    {
        return decode(content);
    }

    /**
     * 清除所有HTML标签，但是不删除标签内的内容
     * 
     * @param content 文本
     * @return 清除标签后的文本
     */
    public static String clean(String content)
    {
        return new HTMLFilter().filter(content);
    }


    /**
     * Escape编码
     * 
     * @param text 被编码的文本
     * @return 编码后的字符
     */
    private static String encode(String text)
    {
        int len;
        if ((text == null) || ((len = text.length()) == 0))
        {
            return StringUtils.EMPTY;
        }
        StringBuilder buffer = new StringBuilder(len + (len >> 2));
        char c;
        for (int i = 0; i < len; i++)
        {
            c = text.charAt(i);
            if (c < 64)
            {
                buffer.append(TEXT[c]);
            }
            else
            {
                buffer.append(c);
            }
        }
        return buffer.toString();
    }

    /**
     * Escape解码
     * 
     * @param content 被转义的内容
     * @return 解码后的字符串
     */
    public static String decode(String content)
    {
        if (StringUtils.isEmpty(content))
        {
            return content;
        }

        StringBuilder tmp = new StringBuilder(content.length());
        int lastPos = 0, pos = 0;
        char ch;
        while (lastPos < content.length())
        {
            pos = content.indexOf("%", lastPos);
            if (pos == lastPos)
            {
                if (content.charAt(pos + 1) == 'u')
                {
                    ch = (char) Integer.parseInt(content.substring(pos + 2, pos + 6), 16);
                    tmp.append(ch);
                    lastPos = pos + 6;
                }
                else
                {
                    ch = (char) Integer.parseInt(content.substring(pos + 1, pos + 3), 16);
                    tmp.append(ch);
                    lastPos = pos + 3;
                }
            }
            else
            {
                if (pos == -1)
                {
                    tmp.append(content.substring(lastPos));
                    lastPos = content.length();
                }
                else
                {
                    tmp.append(content.substring(lastPos, pos));
                    lastPos = pos;
                }
            }
        }
        return tmp.toString();
    }

    public static void main(String[] args)
    {
        String html = "<script>alert(1);</script>";
        // String html = "<scr<script>ipt>alert(\"XSS\")</scr<script>ipt>";
        // String html = "<123";
        // String html = "123>";
        System.out.println(EscapeUtil.clean(html));
        System.out.println(EscapeUtil.escape(html));
        System.out.println(EscapeUtil.unescape(html));
    }
}
```
HttpUtils:
```java
/**
 * 通用http发送方法
 * 
 * @author beoka
 */
public class HttpUtils
{
    private static final Logger log = LoggerFactory.getLogger(HttpUtils.class);

    /**
     * 向指定 URL 发送GET方法的请求
     *
     * @param url 发送请求的 URL
     * @param param 请求参数，请求参数应该是 name1=value1&name2=value2 的形式。
     * @return 所代表远程资源的响应结果
     */
    public static String sendGet(String url, String param)
    {
        return sendGet(url, param, "utf-8");
    }

    /**
     * 向指定 URL 发送GET方法的请求
     *
     * @param url 发送请求的 URL
     * @param param 请求参数，请求参数应该是 name1=value1&name2=value2 的形式。
     * @param contentType 编码类型
     * @return 所代表远程资源的响应结果
     */
    public static String sendGet(String url, String param, String contentType)
    {
        StringBuilder result = new StringBuilder();
        BufferedReader in = null;
        try
        {
            String urlNameString = url + "?" + param;
            log.info("sendGet - {}", urlNameString);
            URL realUrl = new URL(urlNameString);
            URLConnection connection = realUrl.openConnection();
            connection.setRequestProperty("accept", "*/*");
            connection.setRequestProperty("connection", "Keep-Alive");
            connection.setRequestProperty("user-agent", "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1;SV1)");
            connection.connect();
            in = new BufferedReader(new InputStreamReader(connection.getInputStream(), contentType));
            String line;
            while ((line = in.readLine()) != null)
            {
                result.append(line);
            }
            log.info("recv - {}", result);
        }
        catch (ConnectException e)
        {
            log.error("调用HttpUtils.sendGet ConnectException, url=" + url + ",param=" + param, e);
        }
        catch (SocketTimeoutException e)
        {
            log.error("调用HttpUtils.sendGet SocketTimeoutException, url=" + url + ",param=" + param, e);
        }
        catch (IOException e)
        {
            log.error("调用HttpUtils.sendGet IOException, url=" + url + ",param=" + param, e);
        }
        catch (Exception e)
        {
            log.error("调用HttpsUtil.sendGet Exception, url=" + url + ",param=" + param, e);
        }
        finally
        {
            try
            {
                if (in != null)
                {
                    in.close();
                }
            }
            catch (Exception ex)
            {
                log.error("调用in.close Exception, url=" + url + ",param=" + param, ex);
            }
        }
        return result.toString();
    }

    /**
     * 向指定 URL 发送POST方法的请求
     *
     * @param url 发送请求的 URL
     * @param param 请求参数，请求参数应该是 name1=value1&name2=value2 的形式。
     * @return 所代表远程资源的响应结果
     */
    public static String sendPost(String url, String param)
    {
        PrintWriter out = null;
        BufferedReader in = null;
        StringBuilder result = new StringBuilder();
        try
        {
            String urlNameString = url;
            log.info("sendPost - {}", urlNameString);
            URL realUrl = new URL(urlNameString);
            URLConnection conn = realUrl.openConnection();
            conn.setRequestProperty("accept", "*/*");
            conn.setRequestProperty("connection", "Keep-Alive");
            conn.setRequestProperty("user-agent", "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1;SV1)");
            conn.setRequestProperty("Accept-Charset", "utf-8");
            conn.setRequestProperty("contentType", "utf-8");
            conn.setDoOutput(true);
            conn.setDoInput(true);
            out = new PrintWriter(conn.getOutputStream());
            out.print(param);
            out.flush();
            in = new BufferedReader(new InputStreamReader(conn.getInputStream(), "utf-8"));
            String line;
            while ((line = in.readLine()) != null)
            {
                result.append(line);
            }
            log.info("recv - {}", result);
        }
        catch (ConnectException e)
        {
            log.error("调用HttpUtils.sendPost ConnectException, url=" + url + ",param=" + param, e);
        }
        catch (SocketTimeoutException e)
        {
            log.error("调用HttpUtils.sendPost SocketTimeoutException, url=" + url + ",param=" + param, e);
        }
        catch (IOException e)
        {
            log.error("调用HttpUtils.sendPost IOException, url=" + url + ",param=" + param, e);
        }
        catch (Exception e)
        {
            log.error("调用HttpsUtil.sendPost Exception, url=" + url + ",param=" + param, e);
        }
        finally
        {
            try
            {
                if (out != null)
                {
                    out.close();
                }
                if (in != null)
                {
                    in.close();
                }
            }
            catch (IOException ex)
            {
                log.error("调用in.close Exception, url=" + url + ",param=" + param, ex);
            }
        }
        return result.toString();
    }

    public static String sendSSLPost(String url, String param)
    {
        StringBuilder result = new StringBuilder();
        String urlNameString = url + "?" + param;
        try
        {
            log.info("sendSSLPost - {}", urlNameString);
            SSLContext sc = SSLContext.getInstance("SSL");
            sc.init(null, new TrustManager[] { new TrustAnyTrustManager() }, new java.security.SecureRandom());
            URL console = new URL(urlNameString);
            HttpsURLConnection conn = (HttpsURLConnection) console.openConnection();
            conn.setRequestProperty("accept", "*/*");
            conn.setRequestProperty("connection", "Keep-Alive");
            conn.setRequestProperty("user-agent", "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1;SV1)");
            conn.setRequestProperty("Accept-Charset", "utf-8");
            conn.setRequestProperty("contentType", "utf-8");
            conn.setDoOutput(true);
            conn.setDoInput(true);

            conn.setSSLSocketFactory(sc.getSocketFactory());
            conn.setHostnameVerifier(new TrustAnyHostnameVerifier());
            conn.connect();
            InputStream is = conn.getInputStream();
            BufferedReader br = new BufferedReader(new InputStreamReader(is));
            String ret = "";
            while ((ret = br.readLine()) != null)
            {
                if (ret != null && !"".equals(ret.trim()))
                {
                    result.append(new String(ret.getBytes("ISO-8859-1"), "utf-8"));
                }
            }
            log.info("recv - {}", result);
            conn.disconnect();
            br.close();
        }
        catch (ConnectException e)
        {
            log.error("调用HttpUtils.sendSSLPost ConnectException, url=" + url + ",param=" + param, e);
        }
        catch (SocketTimeoutException e)
        {
            log.error("调用HttpUtils.sendSSLPost SocketTimeoutException, url=" + url + ",param=" + param, e);
        }
        catch (IOException e)
        {
            log.error("调用HttpUtils.sendSSLPost IOException, url=" + url + ",param=" + param, e);
        }
        catch (Exception e)
        {
            log.error("调用HttpsUtil.sendSSLPost Exception, url=" + url + ",param=" + param, e);
        }
        return result.toString();
    }

    private static class TrustAnyTrustManager implements X509TrustManager
    {
        @Override
        public void checkClientTrusted(X509Certificate[] chain, String authType)
        {
        }

        @Override
        public void checkServerTrusted(X509Certificate[] chain, String authType)
        {
        }

        @Override
        public X509Certificate[] getAcceptedIssuers()
        {
            return new X509Certificate[] {};
        }
    }

    private static class TrustAnyHostnameVerifier implements HostnameVerifier
    {
        @Override
        public boolean verify(String hostname, SSLSession session)
        {
            return true;
        }
    }
}
```

IpUtil:

```java
package com.beoka.iot.util.ip;

import org.apache.commons.lang3.StringUtils;

import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.Objects;
import javax.servlet.http.HttpServletRequest;



/**
 * 获取IP方法
 * 
 * @author beoka
 */
public class IpUtils
{
    public static String getIpAddr(HttpServletRequest request)
    {
        if (request == null)
        {
            return "unknown";
        }
        String ip = request.getHeader("x-forwarded-for");
        if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip))
        {
            ip = request.getHeader("Proxy-Client-IP");
        }
        if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip))
        {
            ip = request.getHeader("X-Forwarded-For");
        }
        if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip))
        {
            ip = request.getHeader("WL-Proxy-Client-IP");
        }
        if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip))
        {
            ip = request.getHeader("X-Real-IP");
        }

        if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip))
        {
            ip = request.getRemoteAddr();
        }
        return "0:0:0:0:0:0:0:1".equals(ip) ? "127.0.0.1" : EscapeUtil.clean(ip);
    }

    public static boolean internalIp(String ip)
    {
        byte[] addr = textToNumericFormatV4(ip);
        return internalIp(addr) || "127.0.0.1".equals(ip);
    }

    private static boolean internalIp(byte[] addr)
    {
        if (Objects.isNull(addr) || addr.length < 2)
        {
            return true;
        }
        final byte b0 = addr[0];
        final byte b1 = addr[1];
        // 10.x.x.x/8
        final byte SECTION_1 = 0x0A;
        // 172.16.x.x/12
        final byte SECTION_2 = (byte) 0xAC;
        final byte SECTION_3 = (byte) 0x10;
        final byte SECTION_4 = (byte) 0x1F;
        // 192.168.x.x/16
        final byte SECTION_5 = (byte) 0xC0;
        final byte SECTION_6 = (byte) 0xA8;
        switch (b0)
        {
            case SECTION_1:
                return true;
            case SECTION_2:
                if (b1 >= SECTION_3 && b1 <= SECTION_4)
                {
                    return true;
                }
            case SECTION_5:
                switch (b1)
                {
                    case SECTION_6:
                        return true;
                }
            default:
                return false;
        }
    }

    /**
     * 将IPv4地址转换成字节
     * 
     * @param text IPv4地址
     * @return byte 字节
     */
    public static byte[] textToNumericFormatV4(String text)
    {
        if (text.length() == 0)
        {
            return null;
        }

        byte[] bytes = new byte[4];
        String[] elements = text.split("\\.", -1);
        try
        {
            long l;
            int i;
            switch (elements.length)
            {
                case 1:
                    l = Long.parseLong(elements[0]);
                    if ((l < 0L) || (l > 4294967295L)) {
                        return null;
                    }
                    bytes[0] = (byte) (int) (l >> 24 & 0xFF);
                    bytes[1] = (byte) (int) ((l & 0xFFFFFF) >> 16 & 0xFF);
                    bytes[2] = (byte) (int) ((l & 0xFFFF) >> 8 & 0xFF);
                    bytes[3] = (byte) (int) (l & 0xFF);
                    break;
                case 2:
                    l = Integer.parseInt(elements[0]);
                    if ((l < 0L) || (l > 255L)) {
                        return null;
                    }
                    bytes[0] = (byte) (int) (l & 0xFF);
                    l = Integer.parseInt(elements[1]);
                    if ((l < 0L) || (l > 16777215L)) {
                        return null;
                    }
                    bytes[1] = (byte) (int) (l >> 16 & 0xFF);
                    bytes[2] = (byte) (int) ((l & 0xFFFF) >> 8 & 0xFF);
                    bytes[3] = (byte) (int) (l & 0xFF);
                    break;
                case 3:
                    for (i = 0; i < 2; ++i)
                    {
                        l = Integer.parseInt(elements[i]);
                        if ((l < 0L) || (l > 255L)) {
                            return null;
                        }
                        bytes[i] = (byte) (int) (l & 0xFF);
                    }
                    l = Integer.parseInt(elements[2]);
                    if ((l < 0L) || (l > 65535L)) {
                        return null;
                    }
                    bytes[2] = (byte) (int) (l >> 8 & 0xFF);
                    bytes[3] = (byte) (int) (l & 0xFF);
                    break;
                case 4:
                    for (i = 0; i < 4; ++i)
                    {
                        l = Integer.parseInt(elements[i]);
                        if ((l < 0L) || (l > 255L)) {
                            return null;
                        }
                        bytes[i] = (byte) (int) (l & 0xFF);
                    }
                    break;
                default:
                    return null;
            }
        }
        catch (NumberFormatException e)
        {
            return null;
        }
        return bytes;
    }

    public static String getHostIp()
    {
        try
        {
            return InetAddress.getLocalHost().getHostAddress();
        }
        catch (UnknownHostException e)
        {
        }
        return "127.0.0.1";
    }

    public static String getHostName()
    {
        try
        {
            return InetAddress.getLocalHost().getHostName();
        }
        catch (UnknownHostException e)
        {
        }
        return "未知";
    }
}
```

## 2. 距离位置计算(km)

```java
public final class DistanceUtils {
 
    /**
     * 地球半径,单位 km
     */
    private static final double EARTH_RADIUS = 6378.137;
 
    /**
     * 根据经纬度，计算两点间的距离
     *
     * @param longitude1 第一个点的经度
     * @param latitude1  第一个点的纬度
     * @param longitude2 第二个点的经度
     * @param latitude2  第二个点的纬度
     * @return 返回距离 单位千米
     */
    public static double getDistance(double longitude1, double latitude1, double longitude2, double latitude2) {
        // 纬度
        double lat1 = Math.toRadians(latitude1);
        double lat2 = Math.toRadians(latitude2);
        // 经度
        double lng1 = Math.toRadians(longitude1);
        double lng2 = Math.toRadians(longitude2);
        // 纬度之差
        double a = lat1 - lat2;
        // 经度之差
        double b = lng1 - lng2;
        // 计算两点距离的公式
        double s = 2 * Math.asin(Math.sqrt(Math.pow(Math.sin(a / 2), 2) +
                Math.cos(lat1) * Math.cos(lat2) * Math.pow(Math.sin(b / 2), 2)));
        // 弧长乘地球半径, 返回单位: 千米
        s =  s * EARTH_RADIUS;
        return s;
    }
}
```

## 3.手动分页(新-旧)

在一些查询数据中我们需要对查询的数据进行分页，如果是数据库那么可以用limit来进行分页，可是如果是从其他地方获取到的数据那么就不能方便的进行分页，如：Redis等;

旧:

```java
 Long pageCount = Convert.toLong(collect.size());
//手动分页
if (pageIndex.compareTo(ZERO) > ZERO) {
    pageIndex -= 1;
}
int end = PageUtil.getEnd(pageIndex, pageSize);
//判断
if (end >= pageCount) {
    end = Convert.toInt(pageCount);
}
collect=collect.subList(pageIndex, end);
```

新:

```java
public class PageUtil<T> {
    public PageUtil() {
    }

    private static final Integer pageIndex = 1;
    private static final Integer pageSize = 10;

    public static<T> List<T> startPage(List<T> collect) {
        return startPage(collect,pageIndex, pageSize);
    }


    public static<T> List<T> startPage(List<T> collect, Integer pageIndex, Integer pageSize) {
        try {
            if (CollUtil.isEmpty(collect)) {
                return collect;
            }
            //手动分页
            int totalcount = collect.size();
            int pagecount = 0;
            int m = totalcount % pageSize;
            if (m > 0) {
                pagecount = totalcount / pageSize + 1;
            } else {
                pagecount = totalcount / pageSize;
            }
            if (m == 0) {
                collect = collect.subList((pageIndex - 1) * pageSize, pageSize * (pageIndex));
            } else {
                if (pageIndex == pagecount) {
                    collect = collect.subList((pageIndex - 1) * pageSize, totalcount);
                } else {
                    collect = collect.subList((pageIndex - 1) * pageSize, pageSize * (pageIndex));
                }
            }
        } catch (Exception e) {
            throw new BeokaRuntimeException("分页出现异常");
        }
        return collect;
    }
}
```

## 4.敏感词检测

检测敏感词(采用DFA算法):

```java
package com.beoka.iot.util;

import cn.hutool.core.date.DateUtil;
import lombok.extern.slf4j.Slf4j;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.*;

/**
 * 敏感词处理工具 - DFA算法实现
 *
 * @author MiaoDaWei
 */
@Slf4j
public class SensitiveWordUtil {

    /**
     * 敏感词匹配规则
     */
    public static final int MinMatchTYpe = 1;      //最小匹配规则，如：敏感词库["中国","中国人"]，语句："我是中国人"，匹配结果：我是[中国]人
    public static final int MaxMatchType = 2;      //最大匹配规则，如：敏感词库["中国","中国人"]，语句："我是中国人"，匹配结果：我是[中国人]
    static {
        //初始化敏感词库
        final Set<String> sensitiveWordSet = new HashSet<>((readWordFile("/敏感词.txt")));
        //初始化
        init(sensitiveWordSet);
    }
    /**
     * 敏感词集合
     */
    public static HashMap sensitiveWordMap;

    /**
     * 初始化敏感词库，构建DFA算法模型
     *
     * @param sensitiveWordSet 敏感词库
     */
    public static synchronized void init(Set<String> sensitiveWordSet) {
        initSensitiveWordMap(sensitiveWordSet);
    }

    /**
     * 初始化敏感词库，构建DFA算法模型
     *
     * @param sensitiveWordSet 敏感词库
     */
    private static void initSensitiveWordMap(Set<String> sensitiveWordSet) {
        //初始化敏感词容器，减少扩容操作
        sensitiveWordMap = new HashMap(sensitiveWordSet.size());
        String key;
        Map nowMap;
        Map<String, String> newWorMap;
        //迭代sensitiveWordSet
        Iterator<String> iterator = sensitiveWordSet.iterator();
        while (iterator.hasNext()) {
            //关键字
            key = iterator.next();
            nowMap = sensitiveWordMap;
            for (int i = 0; i < key.length(); i++) {
                //转换成char型
                char keyChar = key.charAt(i);
                //库中获取关键字
                Object wordMap = nowMap.get(keyChar);
                //如果存在该key，直接赋值，用于下一个循环获取
                if (wordMap != null) {
                    nowMap = (Map) wordMap;
                } else {
                    //不存在则，则构建一个map，同时将isEnd设置为0，因为他不是最后一个
                    newWorMap = new HashMap<>();
                    //不是最后一个
                    newWorMap.put("isEnd", "0");
                    nowMap.put(keyChar, newWorMap);
                    nowMap = newWorMap;
                }

                if (i == key.length() - 1) {
                    //最后一个
                    nowMap.put("isEnd", "1");
                }
            }
        }
    }

    /**
     * 判断文字是否包含敏感字符
     *
     * @param txt       文字
     * @param matchType 匹配规则 1：最小匹配规则，2：最大匹配规则
     * @return 若包含返回true，否则返回false
     */
    public static boolean contains(String txt, int matchType) {
        boolean flag = false;
        for (int i = 0; i < txt.length(); i++) {
            int matchFlag = checkSensitiveWord(txt, i, matchType); //判断是否包含敏感字符
            if (matchFlag > 0) {    //大于0存在，返回true
                flag = true;
            }
        }
        return flag;
    }

    /**
     * 判断文字是否包含敏感字符
     *
     * @param txt 文字
     * @return 若包含返回true，否则返回false
     */
    public static boolean contains(String txt) {
        return contains(txt, MaxMatchType);
    }

    /**
     * 获取文字中的敏感词
     *
     * @param txt       文字
     * @param matchType 匹配规则 1：最小匹配规则，2：最大匹配规则
     * @return
     */
    public static Set<String> getSensitiveWord(String txt, int matchType) {
        Set<String> sensitiveWordList = new HashSet<>();

        for (int i = 0; i < txt.length(); i++) {
            //判断是否包含敏感字符
            int length = checkSensitiveWord(txt, i, matchType);
            if (length > 0) {//存在,加入list中
                sensitiveWordList.add(txt.substring(i, i + length));
                i = i + length - 1;//减1的原因，是因为for会自增
            }
        }

        return sensitiveWordList;
    }

    /**
     * 获取文字中的敏感词
     *
     * @param txt 文字
     * @return
     */
    public static Set<String> getSensitiveWord(String txt) {
        return getSensitiveWord(txt, MaxMatchType);
    }

    /**
     * 替换敏感字字符
     *
     * @param txt         文本
     * @param replaceChar 替换的字符，匹配的敏感词以字符逐个替换，如 语句：我爱中国人 敏感词：中国人，替换字符：*， 替换结果：我爱***
     * @param matchType   敏感词匹配规则
     * @return
     */
    public static String replaceSensitiveWord(String txt, char replaceChar, int matchType) {
        String resultTxt = txt;
        //获取所有的敏感词
        Set<String> set = getSensitiveWord(txt, matchType);
        Iterator<String> iterator = set.iterator();
        String word;
        String replaceString;
        while (iterator.hasNext()) {
            word = iterator.next();
            replaceString = getReplaceChars(replaceChar, word.length());
            resultTxt = resultTxt.replaceAll(word, replaceString);
        }

        return resultTxt;
    }

    /**
     * 替换敏感字字符
     *
     * @param txt         文本
     * @param replaceChar 替换的字符，匹配的敏感词以字符逐个替换，如 语句：我爱中国人 敏感词：中国人，替换字符：*， 替换结果：我爱***
     * @return
     */
    public static String replaceSensitiveWord(String txt, char replaceChar) {
        return replaceSensitiveWord(txt, replaceChar, MaxMatchType);
    }

    /**
     * 替换敏感字字符
     *
     * @param txt        文本
     * @param replaceStr 替换的字符串，匹配的敏感词以字符逐个替换，如 语句：我爱中国人 敏感词：中国人，替换字符串：[屏蔽]，替换结果：我爱[屏蔽]
     * @param matchType  敏感词匹配规则
     * @return
     */
    public static String replaceSensitiveWord(String txt, String replaceStr, int matchType) {
        String resultTxt = txt;
        //获取所有的敏感词
        Set<String> set = getSensitiveWord(txt, matchType);
        Iterator<String> iterator = set.iterator();
        String word;
        while (iterator.hasNext()) {
            word = iterator.next();
            resultTxt = resultTxt.replaceAll(word, replaceStr);
        }

        return resultTxt;
    }

    /**
     * 替换敏感字字符
     *
     * @param txt        文本
     * @param replaceStr 替换的字符串，匹配的敏感词以字符逐个替换，如 语句：我爱中国人 敏感词：中国人，替换字符串：[屏蔽]，替换结果：我爱[屏蔽]
     * @return
     */
    public static String replaceSensitiveWord(String txt, String replaceStr) {
        return replaceSensitiveWord(txt, replaceStr, MaxMatchType);
    }

    /**
     * 获取替换字符串
     *
     * @param replaceChar
     * @param length
     * @return
     */
    private static String getReplaceChars(char replaceChar, int length) {
        String resultReplace = String.valueOf(replaceChar);
        for (int i = 1; i < length; i++) {
            resultReplace += replaceChar;
        }

        return resultReplace;
    }

    /**
     * 检查文字中是否包含敏感字符，检查规则如下：<br>
     *
     * @param txt
     * @param beginIndex
     * @param matchType
     * @return 如果存在，则返回敏感词字符的长度，不存在返回0
     */
    private static int checkSensitiveWord(String txt, int beginIndex, int matchType) {
        //敏感词结束标识位：用于敏感词只有1位的情况
        boolean flag = false;
        //匹配标识数默认为0
        int matchFlag = 0;
        char word;
        Map nowMap = sensitiveWordMap;
        for (int i = beginIndex; i < txt.length(); i++) {
            word = txt.charAt(i);
            //获取指定key
            nowMap = (Map) nowMap.get(word);
            if (nowMap != null) {//存在，则判断是否为最后一个
                //找到相应key，匹配标识+1
                matchFlag++;
                //如果为最后一个匹配规则,结束循环，返回匹配标识数
                if ("1".equals(nowMap.get("isEnd"))) {
                    //结束标志位为true
                    flag = true;
                    //最小规则，直接返回,最大规则还需继续查找
                    if (MinMatchTYpe == matchType) {
                        break;
                    }
                }
            } else {//不存在，直接返回
                break;
            }
        }
        if (matchFlag < 2 || !flag) {//长度必须大于等于1，为词
            matchFlag = 0;
        }
        return matchFlag;
    }
    /**
     * 读取敏感词库中的内容，将内容添加到set集合中
     */
    private static Set<String> readWordFile(String file) {
        Set<String> set;
        // 字符编码
        String encoding = "UTF-8";
        try (InputStreamReader read = new InputStreamReader(
                SensitiveWordUtil.class.getResourceAsStream(file), encoding)) {
            set = new HashSet<>();
            BufferedReader bufferedReader = new BufferedReader(read);
            String txt;
            // 读取文件，将文件内容放入到set中
            while ((txt = bufferedReader.readLine()) != null) {
                set.add(txt);
            }
        } catch (Exception e) {
            return new HashSet<>();
        }
        // 关闭文件流
        return set;
    }

    /**
     * 是否包含敏感词
     *
     * @param str str
     * @return boolean
     */
    public static boolean include(String str) {
        log.info("【{}】-【{}】待检测语句：【{}】", DateUtil.now(), "敏感词检测", str);
        //是否含有关键字
        boolean result = SensitiveWordUtil.contains(str);
        //获取语句中的敏感词
        Set<String> set = SensitiveWordUtil.getSensitiveWord(str);
        log.info("【{}】-【{}】语句中包含敏感词的个数为：【{}】。包含【{}】", DateUtil.now(), "敏感词检测", set.size(), set);
        return result;
    }


    public static void main(String[] args) throws Exception {
        Set<String> sensitiveWordSet = new HashSet<>((readWordFile("/色情词库.txt")));
        //初始化敏感词库
        SensitiveWordUtil.init(sensitiveWordSet);

        System.out.println("敏感词的数量：" + SensitiveWordUtil.sensitiveWordMap.size());
//        String string = "太多的伤感情怀也许只局限于饲养基地 荧幕中的情节。"
//                + "然后我们的扮演的角色就是跟随着主人公的喜红客联盟 怒哀乐而过于牵强的把自己的情感也附加于银幕情节中，然后感动就流泪，"
//                + "难过就躺在某一个人的怀里尽情的阐述心扉或者手机卡复制器一个贱人一杯红酒一部电影在夜 深人静的晚上，关上电话静静的发呆着。";
        String string = "便携式深沉肌肉按摩仪";
        System.out.println("待检测语句字数：" + string.length());

        //是否含有关键字
        boolean result = SensitiveWordUtil.contains(string);
        System.out.println(result);
        result = SensitiveWordUtil.contains(string, SensitiveWordUtil.MinMatchTYpe);
        System.out.println(result);

        //获取语句中的敏感词
        Set<String> set = SensitiveWordUtil.getSensitiveWord(string);
        System.out.println("语句中包含敏感词的个数为：" + set.size() + "。包含：" + set);
        set = SensitiveWordUtil.getSensitiveWord(string, SensitiveWordUtil.MinMatchTYpe);
        System.out.println("语句中包含敏感词的个数为：" + set.size() + "。包含：" + set);

        //替换语句中的敏感词
        String filterStr = SensitiveWordUtil.replaceSensitiveWord(string, '*');
        System.out.println(filterStr);
        filterStr = SensitiveWordUtil.replaceSensitiveWord(string, '*', SensitiveWordUtil.MinMatchTYpe);
        System.out.println(filterStr);

        String filterStr2 = SensitiveWordUtil.replaceSensitiveWord(string, "[*敏感词*]");
        System.out.println(filterStr2);
        filterStr2 = SensitiveWordUtil.replaceSensitiveWord(string, "[*敏感词*]", SensitiveWordUtil.MinMatchTYpe);
        System.out.println(filterStr2);
    }
}
```

这是其他链接:https://blog.csdn.net/sinat_14982831/article/details/77836034?fps=1&locationNum=2

相关敏感词库我已放在gitee上:https://gitee.com/miawei/resource/tree/master/%E6%95%8F%E6%84%9F%E8%AF%8D

## 5.log4j2日志配置及踩坑

这是日志配置:

添加依赖:

```xml-dtd
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-log4j2</artifactId>
</dependency>
```

然后在resource/log4j2.xml

```xml-dtd
<?xml version="1.0" encoding="UTF-8"?>
<!--日志级别以及优先级排序: OFF > FATAL > ERROR > WARN > INFO > DEBUG > TRACE > ALL -->
<!--Configuration后面的status，这个用于设置log4j2自身内部的信息输出，可以不设置，当设置成trace时，你会看到log4j2内部各种详细输出-->
<!--monitorInterval：Log4j能够自动检测修改配置 文件和重新配置本身，设置间隔秒数-->
<configuration status="WARN" monitorInterval="30">
    <!--先定义所有的appender-->
    <appenders>
        <!--这个输出控制台的配置-->
        <console name="Console" target="SYSTEM_OUT">
            <!--输出日志的格式-->
            <PatternLayout pattern="[%d{HH:mm:ss:SSS}] [%p] - %l - %m%n"/>
        </console>
        <!--文件会打印出所有信息，这个log每次运行程序会自动清空，由append属性决定，这个也挺有用的，适合临时测试用-->
        <File name="log" fileName="log/test.log" append="false">
            <PatternLayout pattern="%d{HH:mm:ss.SSS} %-5level %class{36} %L %M - %msg%xEx%n"/>
        </File>
        <!-- 这个会打印出所有的info及以下级别的信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档-->
        <RollingFile name="RollingFileInfo" fileName="${sys:user.home}/logs/iot/auth/info.log"
                     filePattern="${sys:user.home}/logs/iot/auth/$${date:yyyy-MM}/info-%d{yyyy-MM-dd}-%i.log">
            <!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）-->
            <ThresholdFilter level="info" onMatch="ACCEPT" onMismatch="DENY"/>
            <PatternLayout pattern="[%d{HH:mm:ss:SSS}] [%p] - %l - %m%n"/>
            <Policies>
                <TimeBasedTriggeringPolicy/>
                <SizeBasedTriggeringPolicy size="100 MB"/>
            </Policies>
        </RollingFile>
        <RollingFile name="RollingFileWarn" fileName="${sys:user.home}/logs/iot/auth/warn.log"
                     filePattern="${sys:user.home}/logs/iot/auth/$${date:yyyy-MM}/warn-%d{yyyy-MM-dd}-%i.log">
            <ThresholdFilter level="warn" onMatch="ACCEPT" onMismatch="DENY"/>
            <PatternLayout pattern="[%d{HH:mm:ss:SSS}] [%p] - %l - %m%n"/>
            <Policies>
                <TimeBasedTriggeringPolicy/>
                <SizeBasedTriggeringPolicy size="100 MB"/>
            </Policies>
            <!-- DefaultRolloverStrategy属性如不设置，则默认为最多同一文件夹下7个文件，这里设置了20 -->
            <DefaultRolloverStrategy max="20"/>
        </RollingFile>
        <RollingFile name="RollingFileError" fileName="${sys:user.home}/logs/iot/auth/error.log"
                     filePattern="${sys:user.home}/logs/iot/auth/$${date:yyyy-MM}/error-%d{yyyy-MM-dd}-%i.log">
            <ThresholdFilter level="error" onMatch="ACCEPT" onMismatch="DENY"/>
            <PatternLayout pattern="[%d{HH:mm:ss:SSS}] [%p] - %l - %m%n"/>
            <Policies>
                <TimeBasedTriggeringPolicy/>
                <SizeBasedTriggeringPolicy size="100 MB"/>
            </Policies>
        </RollingFile>
    </appenders>
    <!--然后定义logger，只有定义了logger并引入的appender，appender才会生效-->
    <loggers>
        <!--过滤掉spring和mybatis的一些无用的DEBUG信息-->
        <logger name="org.springframework" level="INFO"></logger>
        <logger name="org.mybatis" level="INFO"></logger>
        <root level="all">
            <appender-ref ref="Console"/>
            <appender-ref ref="RollingFileInfo"/>
            <appender-ref ref="RollingFileWarn"/>
            <appender-ref ref="RollingFileError"/>
        </root>
    </loggers>
</configuration>
```

在yml中:

```yaml
logging:
  config: classpath:log4j2/log4j2-dev.xml #指定日志配置路径
```

基本上以上配置日志就算结束了，但是由于springBoot自身自带了logback日志（默认），所以我们需要手动排除他！

这是我目前知道含有默认的依赖里面含有logback：

```xml-dtd
<!--quartz定时任务-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-quartz</artifactId>
            <exclusions> <!-- 去除springboot默认的logback配置-->
                <exclusion>
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot-starter-logging</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
<!--操作Redis-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
            <exclusions>
                <exclusion>
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot-starter-logging</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
<!--web包-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
            <exclusions> <!-- 去除springboot默认的logback配置-->
                <exclusion>
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot-starter-logging</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
<!--thymeleaf-->
		<dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-thymeleaf</artifactId>
            <exclusions> <!-- 去除springboot默认的logback配置-->
                <exclusion>
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot-starter-logging</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
```

**踩坑：**

项目使用log4j2然后需要排除项目本身自带的logback ,在这过程中漏掉了一个地方就是spring-boot-redis中的logback导致了这个问题，因为这个问题就会导致我在项目启动的时候由于使用`@slf4j`与logging与冲突了, 还有即使打包成功了但是一旦运行就报异常!

这是我解决的博客: https://blog.csdn.net/tangyajun_168/article/details/105607499

然后以上配置了之后就项目启动了之后就去:`C:\Users\MiaoDaWei\logs    `下面去找就能找到对应的日志

> 这是配置log4j2的日志的博客: https://www.cnblogs.com/keeya/p/10101547.html

## 6.大文件（秒传、断点续传、分片上传）

这个了解一点点概念，加深印象需要具体的业务场景并且也需要前端和后端协同才可以完成，所以到时候需要的时候就来边写边看

https://blog.csdn.net/Qingai521/article/details/119882230?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-8.pc_relevant_paycolumn_v3&spm=1001.2101.3001.4242.5&utm_relevant_index=9



这是最初看的：

https://mp.weixin.qq.com/s/sbw5RSOVtTXKce67reZPDA



## 7. 雪花算法

```java
package com.beoka.iot.common.utils.code;

import java.net.Inet4Address;
import java.net.UnknownHostException;
import java.util.HashSet;
import java.util.Random;
import java.util.Set;

/**
 * 雪花算法生成
 *
 * @author MiaoWei
 * @date 2022/07/01
 */
public class SnowflakeUtils {

    /**
     * 时间部分所占长度
     */
    private static final int TIME_LEN = 41;
    /**
     * 数据中心id所占长度
     */
    private static final int DATA_LEN = 5;
    /**
     * 机器id所占长度
     */
    private static final int WORK_LEN = 5;
    /**
     * 毫秒内序列所占长度
     */
    private static final int SEQ_LEN = 12;

    /**
     * 1609430400000定义起始时间 2022-01-01 00:00:00 1420041600000L
     */
    private static final long START_TIME = 1609430400000L;
    /**
     * 上次生成ID的时间截
     */
    private static long LAST_TIME_STAMP = -1L;
    /**
     * 时间部分向左移动的位数 22
     */
    private static final int TIME_LEFT_BIT = 64 - 1 - TIME_LEN;

    /**
     * 自动获取数据中心id（可以手动定义 0-31之间的数）
     */
    private static final long DATA_ID = getDataId();
    /**
     * 自动机器id（可以手动定义 0-31之间的数）
     */
    private static final long WORK_ID = getWorkId();
    /**
     * 数据中心id最大值 31
     */
    private static final int DATA_MAX_NUM = ~(-1 << DATA_LEN);
    /**
     * 机器id最大值 31
     */
    private static final int WORK_MAX_NUM = ~(-1 << WORK_LEN);
    /**
     * 随机获取数据中心id的参数 32
     */
    private static final int DATA_RANDOM = DATA_MAX_NUM + 1;
    /**
     * 随机获取机器id的参数 32
     */
    private static final int WORK_RANDOM = WORK_MAX_NUM + 1;
    /**
     * 数据中心id左移位数 17
     */
    private static final int DATA_LEFT_BIT = TIME_LEFT_BIT - DATA_LEN;
    /**
     * 机器id左移位数 12
     */
    private static final int WORK_LEFT_BIT = DATA_LEFT_BIT - WORK_LEN;

    /**
     * 上一次的毫秒内序列值
     */
    private static long LAST_SEQ = 0L;
    /**
     * 毫秒内序列的最大值 4095
     */
    private static final long SEQ_MAX_NUM = ~(-1 << SEQ_LEN);


    public synchronized static long genId() {
        long now = System.currentTimeMillis();

        //如果当前时间小于上一次ID生成的时间戳，说明系统时钟回退过这个时候应当抛出异常
        if (now < LAST_TIME_STAMP) {
            throw new RuntimeException(String.format("系统时间错误！ %d 毫秒内拒绝生成雪花ID！", START_TIME - now));
        }

        if (now == LAST_TIME_STAMP) {
            LAST_SEQ = (LAST_SEQ + 1) & SEQ_MAX_NUM;
            if (LAST_SEQ == 0) {
                now = nextMillis(LAST_TIME_STAMP);
            }
        } else {
            LAST_SEQ = 0;
        }

        //上次生成ID的时间截
        LAST_TIME_STAMP = now;

        return ((now - START_TIME) << TIME_LEFT_BIT) | (DATA_ID << DATA_LEFT_BIT) | (WORK_ID << WORK_LEFT_BIT) | LAST_SEQ;
    }


    /**
     * 获取下一不同毫秒的时间戳，不能与最后的时间戳一样
     */
    public static long nextMillis(long lastMillis) {
        long now = System.currentTimeMillis();
        while (now <= lastMillis) {
            now = System.currentTimeMillis();
        }
        return now;
    }

    /**
     * 获取字符串s的字节数组，然后将数组的元素相加，对（max+1）取余
     */
    private static int getHostId(String s, int max) {
        byte[] bytes = s.getBytes();
        int sums = 0;
        for (int b : bytes) {
            sums += b;
        }
        return sums % (max + 1);
    }

    /**
     * 根据 host address 取余，发生异常就获取 0到31之间的随机数
     */
    public static int getWorkId() {
        try {
            return getHostId(Inet4Address.getLocalHost().getHostAddress(), WORK_MAX_NUM);
        } catch (UnknownHostException e) {
            return new Random().nextInt(WORK_RANDOM);
        }
    }

    /**
     * 根据 host name 取余，发生异常就获取 0到31之间的随机数
     */
    public static int getDataId() {
        try {
            return getHostId(Inet4Address.getLocalHost().getHostName(), DATA_MAX_NUM);
        } catch (UnknownHostException e) {
            return new Random().nextInt(DATA_RANDOM);
        }
    }


    public static void main(String[] args) {
        Set ids = new HashSet();
        long start = System.currentTimeMillis();
        for (int i = 0; i < 10; i++) {
            ids.add(genId());
        }
        long end = System.currentTimeMillis();
        System.out.println(ids);
        System.out.println("共生成id[" + ids.size() + "]个，花费时间[" + (end - start) + "]毫秒");
    }
}
```

这是网上的学雪花：https://blog.csdn.net/jiaomubai/article/details/124385324

## 8.万能转（适配任何属性）

1. 统一的MQ消息体

   ```java
   public class RebateInfo {
   
       private String userId;  // 用户ID
       private String bizId;   // 业务ID
       private Date bizTime;   // 业务时间
       private String desc;    // 业务描述
       // ... get/set
   }
   ```

2. MQ消息适配类

   ```java
   public class MQAdapter {
   
       public static RebateInfo filter(String strJson, Map<String, String> link) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {
           return filter(JSON.parseObject(strJson, Map.class), link);
       }
   
       public static RebateInfo filter(Map obj, Map<String, String> link) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {
           RebateInfo rebateInfo = new RebateInfo();
           for (String key : link.keySet()) {
               Object val = obj.get(link.get(key));
               //使用反射调用的方式给我们的类型赋值
               RebateInfo.class.getMethod("set" + key.substring(0, 1).toUpperCase() + key.substring(1), String.class).invoke(rebateInfo, val.toString());
           }
           return rebateInfo;
       }
   }
   ```

3. 测试

   ```java
   create_account create_account = new create_account();
       create_account.setNumber("100001");
       create_account.setAddress("河北省.廊坊市.广阳区.大学里职业技术学院");
       create_account.setAccountDate(new Date());
       create_account.setDesc("在校开户");          
   
       HashMap<String, String> link01 = new HashMap<String, String>();
       link01.put("userId", "number");
       link01.put("bizId", "number");
       link01.put("bizTime", "accountDate");
       link01.put("desc", "desc");
       RebateInfo rebateInfo01 = MQAdapter.filter(create_account.toString(), link01);
   ```

   

## 9. 实现白名单拦截功能

```java
itstack-demo-design-10-02
└── src
    ├── main
    │   ├── java
    │   │   └── org.itstack.demo.design.door
    │   │       ├── annotation
    │   │       │	└── DoDoor.java	
    │   │       ├── config
    │   │       │	├── StarterAutoConfigure.java
    │   │       │	├── StarterService.java
    │   │       │	└── StarterServiceProperties.java
    │   │       └── DoJoinPoint.java
    │   └── resources	
    │       └── META_INF
    │           └── spring.factories
    └── test
        └── java
            └── org.itstack.demo.test
                └── ApiTest.java
```

![image-20221230143534703](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/202212301435767.png)

右侧是为了获取配置文件，左侧是对于切面的处理

代码：

1. 配置服务类

   ```java
   //获取配置信息
   public class StarterService {
   
       private String userStr;
   
       public StarterService(String userStr) {
           this.userStr = userStr;
       }
   
       public String[] split(String separatorChar) {
           return StringUtils.split(this.userStr, separatorChar);
       }
   }
   ```

2. 配置类注解定义

   ```java
   @ConfigurationProperties("itstack.door")
   public class StarterServiceProperties {
   
       private String userStr;
   
       public String getUserStr() {
           return userStr;
       }
   
       public void setUserStr(String userStr) {
           this.userStr = userStr;
       }
   }
   ```

3. 自定义配置类信息获取

   ```java
   @Configuration
   @ConditionalOnClass(StarterService.class)
   @EnableConfigurationProperties(StarterServiceProperties.class)
   public class StarterAutoConfigure {
   
       @Autowired
       private StarterServiceProperties properties;
   
       @Bean
       @ConditionalOnMissingBean
       @ConditionalOnProperty(prefix = "itstack.door", value = "enabled", havingValue = "true")
       StarterService starterService() {
           return new StarterService(properties.getUserStr());
       }
   }
   ```

4. 切面注解定义

   ```java
   @Retention(RetentionPolicy.RUNTIME)
   @Target(ElementType.METHOD)
   //此注解添加到需要扩展白名单的方法上。
   //这里提供了两个入参，key：获取某个字段例如用户ID、returnJson：确定白名单拦截后返回的具体内容。
   public @interface DoDoor {
   
       String key() default "";
   
       String returnJson() default "";
   
   }
   ```

5. 白名单切面逻辑

   ```java
   @Aspect
   @Component
   public class DoJoinPoint {
   
       private Logger logger = LoggerFactory.getLogger(DoJoinPoint.class);
   
       @Autowired
       private StarterService starterService;
   
       @Pointcut("@annotation(org.itstack.demo.design.door.annotation.DoDoor)")
       //获取指定key也就是获取入参中的某个属性，这里主要是获取用户ID，通过ID进行拦截校验。
       public void aopPoint() {
       }
   
       @Around("aopPoint()")
       //切面核心逻辑，这一部分主要是判断当前访问的用户ID是否白名单用户，如果是则放行jp.proceed();，否则返回自定义的拦截提示信息
       public Object doRouter(ProceedingJoinPoint jp) throws Throwable {
           //获取内容
           Method method = getMethod(jp);
           DoDoor door = method.getAnnotation(DoDoor.class);
           //获取字段值
           String keyValue = getFiledValue(door.key(), jp.getArgs());
           logger.info("itstack door handler method：{} value：{}", method.getName(), keyValue);
           if (null == keyValue || "".equals(keyValue)) return jp.proceed();
           //配置内容
           String[] split = starterService.split(",");
           //白名单过滤
           for (String str : split) {
               if (keyValue.equals(str)) {
                   return jp.proceed();
               }
           }
           //拦截
           return returnObject(door, method);
       }
   
       private Method getMethod(JoinPoint jp) throws NoSuchMethodException {
           Signature sig = jp.getSignature();
           MethodSignature methodSignature = (MethodSignature) sig;
           return getClass(jp).getMethod(methodSignature.getName(), methodSignature.getParameterTypes());
       }
   
       private Class<? extends Object> getClass(JoinPoint jp) throws NoSuchMethodException {
           return jp.getTarget().getClass();
       }
   
       //返回对象
       //返回拦截后的转换对象，也就是说当非白名单用户访问时则返回一些提示信息。
       private Object returnObject(DoDoor doGate, Method method) throws IllegalAccessException, InstantiationException {
           Class<?> returnType = method.getReturnType();
           String returnJson = doGate.returnJson();
           if ("".equals(returnJson)) {
               return returnType.newInstance();
           }
           return JSON.parseObject(returnJson, returnType);
       }
   
       //获取属性值
       private String getFiledValue(String filed, Object[] args) {
           String filedValue = null;
           for (Object arg : args) {
               try {
                   if (null == filedValue || "".equals(filedValue)) {
                       filedValue = BeanUtils.getProperty(arg, filed);
                   } else {
                       break;
                   }
               } catch (Exception e) {
                   if (args.length == 1) {
                       return args[0].toString();
                   }
               }
           }
           return filedValue;
       }
   
   }
   ```

6. 配置yaml

   ```yaml
   # 自定义中间件配置
   itstack:
     door:
       enabled: true
       userStr: 1001,aaaa,ccc #白名单用户ID，多个逗号隔开
   ```

7. 在Controller中添加自定义注解

   ```java
   /**
    * http://localhost:8080/api/queryUserInfo?userId=1001
    * http://localhost:8080/api/queryUserInfo?userId=小团团
    */
   @DoDoor(key = "userId", returnJson = "{\"code\":\"1111\",\"info\":\"非白名单可访问用户拦截！\"}")
   @RequestMapping(path = "/api/queryUserInfo", method = RequestMethod.GET)
   public UserInfo queryUserInfo(@RequestParam String userId) {
       return new UserInfo("虫虫:" + userId, 19, "天津市南开区旮旯胡同100号");
   }
   ```

## 手写一个万能迭代器

结构：

![image-20230103155828569](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/202301031558601.png)

模型结构：

![迭代器模式模型结构](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/202301031603116.png)

1. 雇员实体类

   ```java
   /**
    * 雇员
    */
   public class Employee {
   
       private String uId;   // ID
       private String name;  // 姓名
       private String desc;  // 备注
       
       // ...get/set
   }
   ```

2. 数节点链路

   ```java
   /**
    * 树节点链路，如：A to B 描述出一套完整的树组织结构
    */
   public class Link {
   
       private String fromId; // 雇员ID
       private String toId;   // 雇员ID    
       
       // ...get/set
   }
   ```

3. 迭代器定义

   ```java
   public interface Iterator<E> {
       boolean hasNext();
       E next();
   }
   ```

4. 可迭代接口定义

   ```java
   //提供了上面迭代器的实现Iterator的获取，也就是后续在自己的数据结构中需要实现迭代器的功能并交给Iterable，由此让外部调用方进行获取使用
   public interface Iterable<E> {
       Iterator<E> iterator();
   }
   ```

5. 集合功能接口定义

   ```java
   //定义了两个泛型<E, L>，因为我们的数据结构一个是用于添加元素，另外一个是用于添加树节点的链路关系
   public interface Collection<E, L> extends Iterable<E> {
       boolean add(E e);
       boolean remove(E e);
       boolean addLink(String key, L l);
       boolean removeLink(String key);
       Iterator<E> iterator();
   }
   ```

6. (核心)迭代器功能的实现

   ```java
   public class GroupStructure implements Collection<Employee, Link> {
   
       private String groupId;                                                 // 组织ID，也是一个组织链的头部ID
       private String groupName;                                               // 组织名称
       private Map<String, Employee> employeeMap = new ConcurrentHashMap<String, Employee>();  // 雇员列表
       private Map<String, List<Link>> linkMap = new ConcurrentHashMap<String, List<Link>>();  // 组织架构关系；id->list
       private Map<String, String> invertedMap = new ConcurrentHashMap<String, String>();       // 反向关系链
   
       public GroupStructure(String groupId, String groupName) {
           this.groupId = groupId;
           this.groupName = groupName;
       }
   
       public boolean add(Employee employee) {
           return null != employeeMap.put(employee.getuId(), employee);
       }
   
       public boolean remove(Employee o) {
           return null != employeeMap.remove(o.getuId());
       }
   
       public boolean addLink(String key, Link link) {
           invertedMap.put(link.getToId(), link.getFromId());
           if (linkMap.containsKey(key)) {
               return linkMap.get(key).add(link);
           } else {
               List<Link> links = new LinkedList<Link>();
               links.add(link);
               linkMap.put(key, links);
               return true;
           }
       }
   
       public boolean removeLink(String key) {
           return null != linkMap.remove(key);
       }
   
       public Iterator<Employee> iterator() {
   
           return new Iterator<Employee>() {
   
               HashMap<String, Integer> keyMap = new HashMap<String, Integer>();
   
               int totalIdx = 0;
               private String fromId = groupId;  // 雇员ID，From
               private String toId = groupId;   // 雇员ID，To
   
               public boolean hasNext() {
                   return totalIdx < employeeMap.size();
               }
   
               public Employee next() {
                   List<Link> links = linkMap.get(toId);
                   int cursorIdx = getCursorIdx(toId);
   
                   // 同级节点扫描
                   if (null == links) {
                       cursorIdx = getCursorIdx(fromId);
                       links = linkMap.get(fromId);
                   }
   
                   // 上级节点扫描
                   while (cursorIdx > links.size() - 1) {
                       fromId = invertedMap.get(fromId);
                       cursorIdx = getCursorIdx(fromId);
                       links = linkMap.get(fromId);
                   }
   
                   // 获取节点
                   Link link = links.get(cursorIdx);
                   toId = link.getToId();
                   fromId = link.getFromId();
                   totalIdx++;
   
                   // 返回结果
                   return employeeMap.get(link.getToId());
               }
                
               // 给每个层级定义宽度遍历进度
               public int getCursorIdx(String key) {
                   int idx = 0;
                   if (keyMap.containsKey(key)) {
                       idx = keyMap.get(key);
                       keyMap.put(key, ++idx);
                   } else {
                       keyMap.put(key, idx);
                   }
                   return idx;
               }
           };
       }
   }
   ```

   - 以上的这部分代码稍微有点长，主要包括了对元素的添加和删除。另外最重要的是对遍历的实现`new Iterator<Employee>`。
   - 添加和删除元素相对来说比较简单，使用了两个map数组结构进行定义；`雇员列表`、`组织架构关系；id->list`。当元素添加元素的时候，会分别在不同的方法中向`map`结构中进行填充**指向关系(A->B)**，也就构建出了我们的树形组织关系。

7. 测试类

   ```java
   @Test
   public void test_iterator() { 
       // 数据填充
       GroupStructure groupStructure = new GroupStructure("1", "小傅哥");  
       
       // 雇员信息
       groupStructure.add(new Employee("2", "花花", "二级部门"));
       groupStructure.add(new Employee("3", "豆包", "二级部门"));
       groupStructure.add(new Employee("4", "蹦蹦", "三级部门"));
       groupStructure.add(new Employee("5", "大烧", "三级部门"));
       groupStructure.add(new Employee("6", "虎哥", "四级部门"));
       groupStructure.add(new Employee("7", "玲姐", "四级部门"));
       groupStructure.add(new Employee("8", "秋雅", "四级部门"));   
       
       // 节点关系 1->(1,2) 2->(4,5)
       groupStructure.addLink("1", new Link("1", "2"));
       groupStructure.addLink("1", new Link("1", "3"));
       groupStructure.addLink("2", new Link("2", "4"));
       groupStructure.addLink("2", new Link("2", "5"));
       groupStructure.addLink("5", new Link("5", "6"));
       groupStructure.addLink("5", new Link("5", "7"));
       groupStructure.addLink("5", new Link("5", "8"));       
   
       Iterator<Employee> iterator = groupStructure.iterator();
       while (iterator.hasNext()) {
           Employee employee = iterator.next();
           logger.info("{}，雇员 Id：{} Name：{}", employee.getDesc(), employee.getuId(), employee.getName());
       }
   }
   ```

8. 测试结果：

   ![image-20230103161320226](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/202301031613281.png)

---

迭代器实现思路：

1. 这里的树形结构我们需要做的是深度遍历，也就是左侧的一直遍历到最深节点。
2. 当遍历到最深节点后，开始遍历最深节点的横向节点。
3. 当横向节点遍历完成后则向上寻找横向节点，直至树结构全部遍历完成。

## 获取ip的同时获取城市

csdn连接：https://blog.csdn.net/jcc4261/article/details/128368544

https://www.jianshu.com/p/95ba828d9a8c

```java
package com.acecool.common.utils.ip;

import com.acecool.common.utils.StringUtils;
import lombok.SneakyThrows;
import lombok.extern.slf4j.Slf4j;
import org.lionsoul.ip2region.DataBlock;
import org.lionsoul.ip2region.DbConfig;
import org.lionsoul.ip2region.DbSearcher;
import org.lionsoul.ip2region.Util;

import java.io.File;

/**
 * ip查询处理
 *
 * @author videomonster
 */
@Slf4j
public final class IpAddressUtils {

    private static final String UNKOWN_ADDRESS = "未知位置";

    /**
     * 根据IP获取地址
     *
     * @return 国家|区域|省份|城市|ISP
     */
    public static String getAddress(String ip) {
        return getAddress(ip, DbSearcher.BTREE_ALGORITHM);
    }

    /**
     * 根据IP获取地址
     *
     * @param ip
     * @param algorithm 查询算法
     * @return 国家|区域|省份|城市|ISP
     * @see DbSearcher
     * DbSearcher.BTREE_ALGORITHM; //B-tree
     * DbSearcher.BINARY_ALGORITHM //Binary
     * DbSearcher.MEMORY_ALGORITYM //Memory
     */
    @SneakyThrows
    public static String getAddress(String ip, int algorithm) {
        if (!Util.isIpAddress(ip)) {
            log.error("错误格式的ip地址: {}", ip);
            return UNKOWN_ADDRESS;
        }
        String dbPath = IpAddressUtils.class.getResource("/ip2region.db").getPath();
        File file = new File(dbPath);
        if (!file.exists()) {
            log.error("地址库文件不存在");
            return UNKOWN_ADDRESS;
        }
        DbSearcher searcher = new DbSearcher(new DbConfig(), dbPath);
        DataBlock dataBlock;
        switch (algorithm) {
            case DbSearcher.BTREE_ALGORITHM:
                dataBlock = searcher.btreeSearch(ip);
                break;
            case DbSearcher.BINARY_ALGORITHM:
                dataBlock = searcher.binarySearch(ip);
                break;
            case DbSearcher.MEMORY_ALGORITYM:
                dataBlock = searcher.memorySearch(ip);
                break;
            default:
                log.error("未传入正确的查询算法");
                return UNKOWN_ADDRESS;
        }
        return dataBlock.getRegion();
    }

    public static String getIpPossession(String ip)  {
        String cityInfo = getAddress(ip);
        if (!StringUtils.isEmpty(cityInfo)) {
            cityInfo = cityInfo.replace("|", " ");
            String[] cityList = cityInfo.split(" ");
            if (cityList.length > 0) {
                // 国内的显示到具体的省
                if ("中国".equals(cityList[0])) {
                    if (cityList.length > 1) {
                        return cityList[3];
                    }
                }
                // 国外显示到国家
                return cityList[0];
            }
        }
        return "未知";
    }
}
```

## 比较器自定义排序按照返回

```java
list = list.stream().sorted((x,y) -> {
                if (x.getStoreAddress().contains(requestCity) && !y.getStoreAddress().contains(requestCity)) {
                    return -1;
                } else if (!x.getStoreAddress().contains(requestCity) && y.getStoreAddress().contains(requestCity)) {
                    return 1;
                }else{
                    return 0;
                }
            }).collect(Collectors.toList());

业务场景：在门店列表中让包含当前城市的排到前面去，
```

## 对指定时间范围内随机生成一个时间

```java
/**
 * 生成随机指定时间范围内的时间
 *
 * @author MiaoWei
 * @date 2023/04/04
 */
public class GenRandomTimeUtil {
    /**
     * 生成随机时间
     *
     * @param beginDate
     * @param endDate
     * @return
     */
    public static Date randomDate(String beginDate, String endDate) {
        try {
            SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd");
            Date start = format.parse(beginDate);// 构造开始日期
            Date end = format.parse(endDate);// 构造结束日期
            // getTime()表示返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。
            if (start.getTime() >= end.getTime()) {
                return null;
            }
            long date = random(start.getTime(), end.getTime());
            return new Date(date);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    public static long random(long begin, long end) {
        long rtn = begin + (long) (Math.random() * (end - begin));
        // 如果返回的是开始时间和结束时间，则递归调用本函数查找随机值
        if (rtn == begin || rtn == end) {
            return random(begin, end);
        }
        return rtn;
    }

    public static void main(String[] args) {
        Date randomDate = randomDate("2023-04-01", "2023-04-04");
        SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");
        String result = format.format(randomDate);
        System.out.println(result);
    }
}
```

## 数据库模拟百万级数据

1. 创建数据库

   ```sql
   CREATE DATABASE `test_bai` -- 创建数据库
   USE `test_bai` -- 切换对应的数据库
   ```

2. 创建表

   ```sql
   CREATE TABLE `app_user`(
   	`id` INT  NOT NULL AUTO_INCREMENT COMMENT '主键',
   	`name` VARCHAR(50) DEFAULT '' COMMENT '用户名称',
   	`email` VARCHAR(50) NOT NULL COMMENT '邮箱',
   	`phone` VARCHAR(20) DEFAULT '' COMMENT '手机号',
   	`gender` TINYINT DEFAULT '0' COMMENT '性别（0-男  ： 1-女）',
   	`password` VARCHAR(100) NOT NULL COMMENT '密码',
   	`age` TINYINT DEFAULT '0' COMMENT '年龄',
   	`create_time` DATETIME DEFAULT NOW(),
   	`update_time` DATETIME DEFAULT NOW(),
   	PRIMARY KEY (`id`) 
   )ENGINE = INNODB DEFAULT CHARSET = utf8 COMMENT='app用户表'
   ```

3. 书写新增100万条数据的函数

   ```sql
   SET GLOBAL log_bin_trust_function_creators=TRUE; -- 创建函数一定要写这个
   DELIMITER $$   -- 写函数之前必须要写，该标志
   
   CREATE FUNCTION mock_data()		-- 创建函数（方法）
   RETURNS INT 						-- 返回类型
   BEGIN								-- 函数方法体开始
   	DECLARE num INT DEFAULT 2000000; 		-- 定义一个变量num为int类型。默认值为100 0000
   	DECLARE i INT DEFAULT 0; 
   	
   	WHILE i < num DO 				-- 循环条件
   		 INSERT INTO app_user(`name`,`email`,`phone`,`gender`,`password`,`age`) 
   		 VALUES(CONCAT('用户',i),'2548928007qq.com',CONCAT('18',FLOOR(RAND() * ((999999999 - 100000000) + 1000000000))),FLOOR(RAND()  *  2),UUID(),FLOOR(RAND()  *  100));
   		SET i =  i + 1;	-- i自增	
   	END WHILE;		-- 循环结束
   	RETURN i;
   END; 								-- 函数方法体结束
   ```

4. 调用函数

   ```sql
   SELECT mock_data(); -- 调用函数
   ```

5. 这个时候数据库就有了200万条数据了！！！

   ![image-20230420145041983](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/202304201450108.png)



 

## 导出百万级数据优化内存占比

​	从MySQL查询出数据加载到内存中，在内存创建excel或者csv，以流的形式响应给前端。（之前的方式全部加载到内存中会引起OOM）。



流式查询：

```
Mysql本身支持Stream查询，我们可以通过Stream流获取数据，然后将数据逐条刷入到文件中，每次刷入文件后再从内存中移除这条数据，从而避免OOM。

由于采用了数据逐条刷入文件，而且数据量达到百万级，所以文件格式就不要采用excel了，excel2007最大才支持104万行的数据。这里推荐：csv替代excel
```

1. 定义一个工具类`DownloadProcessor`

   ```java
   /**
    * 下载处理器
    *
    * @author MiaoWei
    * @date 2023/04/20
    */
   public class DownloadProcessor {
       private final HttpServletResponse response;
        
       public DownloadProcessor(HttpServletResponse response) {
           this.response = response;
           String fileName = System.currentTimeMillis() + ".csv";
           this.response.addHeader("Content-Type", "application/csv");
           this.response.addHeader("Content-Disposition", "attachment; filename="+fileName);
           this.response.setCharacterEncoding("UTF-8");
       }
        
       public <E> void processData(E record) {
           try {
               response.getWriter().write(record.toString()); //如果是要写入csv,需要重写toString,属性通过","分割
               response.getWriter().write("\n");
           }catch (IOException e){
               e.printStackTrace();
           }
       }
   }
   ```

2. 然后通过实现`org.apache.ibatis.session.ResultHandler`，自定义我们的`ResultHandler`，它用于获取java对象，然后传递给上面的`DownloadProcessor`处理类进行写文件操作：

   ```java
   /**
    * 自定义返回处理程序
    *
    * @author MiaoWei
    * @date 2023/04/20
    */
   public class CustomResultHandler implements ResultHandler {
   
       private final DownloadProcessor downloadProcessor;
        
       public CustomResultHandler(
               DownloadProcessor downloadProcessor) {
           super();
           this.downloadProcessor = downloadProcessor;
       }
        
       @Override
       public void handleResult(ResultContext resultContext) {
           Authors authors = (Authors)resultContext.getResultObject();
           downloadProcessor.processData(authors);
       }
   ```

3. mapper:

   ```java
   public interface AuthorsMapper {
      List<Authors> selectByExample(AuthorsExample example);
       
      List<Authors> streamByExample(AuthorsExample example); //以stream形式从mysql获取数据
   }
   ```

4. mapper.xml

   ```xml
   <select id="selectByExample" resultType="com.ruoyi.project.system.domain.Authors">
           select
               id,
               first_name as 'firstName',
               last_name as 'lastName',
               email,
               birthdate,
               added
           from
               authors
       </select>
       <!--fetchSize="-2147483648"-->
       <select id="streamByExample"  fetchSize="-2147483648" resultType="com.ruoyi.project.system.domain.Authors">
           select
               id,
               first_name as 'firstName',
               last_name as 'lastName',
               email,
               birthdate,
               added
           from
               authors
       </select>
   ```

5. 获取数据的核心service如下，由于只做个简单演示，就懒得写成接口了。其中 `streamDownload` 方法即为stream取数据写文件的实现，它将以很低的内存占用从MySQL获取数据；此外还提供`traditionDownload`方法，它是一种传统的下载方式，批量获取全部数据，然后将每个对象写入文件。

   ```java
   @Service
   public class AuthorsService {
       private final SqlSessionTemplate sqlSessionTemplate;
       private final AuthorsMapper authorsMapper;
   
       public AuthorsService(SqlSessionTemplate sqlSessionTemplate, AuthorsMapper authorsMapper) {
           this.sqlSessionTemplate = sqlSessionTemplate;
           this.authorsMapper = authorsMapper;
       }
   
       /**
        * stream读数据写文件方式
        * @param httpServletResponse
        * @throws IOException
        */
       public void streamDownload(HttpServletResponse httpServletResponse)
               throws IOException {
           CustomResultHandler customResultHandler = new CustomResultHandler(new DownloadProcessor(httpServletResponse));
           sqlSessionTemplate.select(
                   "com.ruoyi.project.system.mapper.AuthorsMapper.streamByExample", customResultHandler);
           httpServletResponse.getWriter().flush();
           httpServletResponse.getWriter().close();
       }
   
       /**
        * 传统下载方式
        * @param httpServletResponse
        * @throws IOException
        */
       public void traditionDownload(HttpServletResponse httpServletResponse)
               throws IOException {
           List<Authors> authors = authorsMapper.selectByExample ();
           DownloadProcessor downloadProcessor = new DownloadProcessor (httpServletResponse);
           authors.forEach (downloadProcessor::processData);
           httpServletResponse.getWriter().flush();
           httpServletResponse.getWriter().close();
       }
   }
   ```

6. 入口：

   ```java
   @RestController
   @RequestMapping("/test/download")
   public class HelloController {
       @Autowired
       private SysUserMapper sysUserMapper;
   
   
       private final AuthorsService authorsService;
   
       public HelloController(AuthorsService authorsService) {
           this.authorsService = authorsService;
       }
   
       @GetMapping("streamDownload")
       public void streamDownload(HttpServletResponse response)throws IOException {
           authorsService.streamDownload(response);
       }
   
       @GetMapping("traditionDownload")
       public void traditionDownload(HttpServletResponse response)
               throws IOException {
           authorsService.traditionDownload (response);
       }
   }
   ```

7. 启动项目，打开jdk/bin/jconsole.exe查看内存占比情况：

   这里我数据库模拟了200w条数据

   - 先看正常查询导出的效率：内存峰值直达2.5g，这个内存占用太高了

     ![image-20230420163648772](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/202304201636860.png)

- 再看流式查询导出：峰值不超过1G，优化过后的效率可不是一点两点

  ![image-20230420164036516](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/202304201640592.png)

总结：

1. 流式查询的好处就在于传统方式是查询全部后返回封装一个list在内存中，而流式查询是逐条存入到文件中，刷完就移除这条就不会存在缓存OOM。
2. 整个关键就在于在xml文件中 **fetchSize="-2147483648"**。*Integer.MIN_VALUE*。一开始我希望或许fetchSize能够自己指定一次从服务器端获取的数据量；发现修改fetchSize的值并没有差别；结果是MYSQL并不支持自定义fetchSize 看网上说其他大型数据库（oracl db2）是支持的；mysql使用服务器端游标只能一条一条取数据。
3. 相同的 SQL 调整下接口方法。这样由于是逐条处理,所以在 JDBC 取到数据后会立即回调 `ResultHandler`处理数据,在数据处理完成后重复上述逻辑，已经处理过的数据就可以被GC掉，避免占用大量内存。

注：

其他链接：

1. https://www.jianshu.com/p/7b1c333719d7
2. https://mp.weixin.qq.com/s/QdUvVw8EExceLal5LosD6g



# 根据文件获取视频时长、等信息

pom文件：

```xml-dtd
<!-- 获取视频时长 -->
        <dependency>
            <groupId>it.sauronsoftware</groupId>
            <artifactId>jave</artifactId>
            <version>1.0.2</version>
            <scope>system</scope>
            <systemPath>${project.basedir}/src/main/resources/lib/jave-1.0.2.jar</systemPath>
        </dependency>

        <!-- https://mvnrepository.com/artifact/commons-codec/commons-codec -->
        <dependency>
            <groupId>commons-codec</groupId>
            <artifactId>commons-codec</artifactId>
            <version>1.10</version>
        </dependency>

<build>
        <finalName>${project.artifactId}</finalName>
        <!-- SpringBoot 项目打jar包的Maven插件 -->
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <version>2.5.2</version>
                <configuration>
                    <fork>true</fork> <!-- 如果没有该配置，devtools不会生效 -->
                    <!-- 当scope为system的时候打包不会自动打包进去的，所以要添加一个参数才能打包进去的 -->
                    <includeSystemScope>true</includeSystemScope>
                </configuration>
            </plugin>
        </plugins>
    </build>
```

![image-20230424094424393](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/202304240944578.png)

工具类：

```java
/**
* @Description:获取视频宽高大小时间工具类
*/

import com.beoka.iot.common.core.lang.UUID;
import it.sauronsoftware.jave.Encoder;
import it.sauronsoftware.jave.MultimediaInfo;
import org.springframework.web.multipart.MultipartFile;

import java.io.*;
import java.net.HttpURLConnection;
import java.net.URL;

public class VoidUtils {
	/**
	 * 通过MultipartFile 的文件类型获取视频时长
	 *
	 * @param file 文件
	 * @return {@link Integer} 视频 秒
	 */
	public Integer readVideoTimeMs(MultipartFile file) {
		Encoder encoder = new Encoder();
		long ms = 0;
		try {
			// 获取文件类型
			String fileName = file.getContentType();
			// 获取文件后缀
			String pref = fileName.indexOf("/") != -1 ? fileName.substring(fileName.lastIndexOf("/") + 1, fileName.length()) : null;
			String prefix = "." + pref;
			// 用uuid作为文件名，防止生成的临时文件重复
			final File excelFile = File.createTempFile(UUID.randomUUID().toString().replace("-", ""), prefix);
			// MultipartFile to File
			file.transferTo(excelFile);
			MultimediaInfo m = encoder.getInfo(excelFile);
			ms = m.getDuration();
			//程序结束时，删除临时文件
			deleteFile(excelFile);
		} catch (Exception e) {
			e.printStackTrace();
		}
		int ss = 1000;
		int mi = ss * 60;
		int hh = mi * 60;
		int dd = hh * 24;
		long day = ms / dd;
		long hour = (ms - day * dd) / hh;
		long minute = (ms - day * dd - hour * hh) / mi;
		long second = (ms - day * dd - hour * hh - minute * mi) / ss;
		return Math.toIntExact(hour * 3600 + minute * 60 + second);
	}

	/**
	 * 通过url地址获取视频时长
	 *
	 * @param fileName 文件名称
	 * @return {@link Integer}
	 */
	public Integer fileVideoTimeMs(String fileName){
		Encoder encoder = new Encoder();
		long ms = 0;
		try {
			//url地址来获取的时长需要做一定的转换，要先获取文件
			File file = getFileByUrl(fileName);
			MultimediaInfo m = encoder.getInfo(file);
			ms = m.getDuration();
			deleteFile(file);
		}catch (Exception e){
			e.printStackTrace();
		}
		int ss = 1000;
		int mi = ss * 60;
		int hh = mi * 60;
		int dd = hh * 24;
		long day = ms / dd;
		long hour = (ms - day * dd) / hh;
		long minute = (ms - day * dd - hour * hh) / mi;
		long second = (ms - day * dd - hour * hh - minute * mi) / ss;
		return Math.toIntExact(hour * 3600 + minute * 60 + second);
	}

	/**
	 * 获取文件通过url
	 *
	 * @param url url
	 * @return {@link File}
	 * @throws IOException ioexception
	 */
	public  File getFileByUrl(String url) throws  IOException {
		File tmpFile = File.createTempFile("temp", ".tmp");//创建临时文件
		toBdFile(url, tmpFile.getCanonicalPath());
		return tmpFile;
	}

	/**
	 * 转文件
	 *
	 * @param urlStr url str
	 * @param bdUrl  bd url
	 * @throws IOException          ioexception
	 */
	public  void toBdFile(String urlStr, String bdUrl) throws IOException {
		URL url = new URL(urlStr);
		HttpURLConnection conn = (HttpURLConnection) url.openConnection();
		DataInputStream in = new DataInputStream(conn.getInputStream());
		byte[] data = toByteArray(in);
		in.close();
		FileOutputStream out = new FileOutputStream(bdUrl);
		out.write(data);
		out.close();
	}

	/**
	 * 将字节数组
	 *
	 * @param in 在
	 * @return {@link byte[]}
	 * @throws IOException ioexception
	 */
	public  byte[] toByteArray(InputStream in) throws IOException {
		ByteArrayOutputStream out = new ByteArrayOutputStream();
		byte[] buffer = new byte[1024 * 4];
		int n = 0;
		while ((n = in.read(buffer)) != -1) {
			out.write(buffer, 0, n);
		}
		return out.toByteArray();
	}

	/**
	 * 删除临时文件
	 * @param files
	 */
	private  void deleteFile(File... files) {
		for (File file : files) {
			if (file.exists()) {
				file.delete();
			}
		}
	}
}
```

下载jar包链接：http://www.sauronsoftware.it/projects/jave/download.php

文章的相关链接：

1. https://blog.csdn.net/Mrs_chens/article/details/103843953
2. https://www.how234.com/eamyrzfjb.html
