# 工具类

## 1. 获取IP(若依的)

AddressUtils：

```java
package com.beoka.iot.util.ip;

import com.alibaba.fastjson.JSONObject;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * 获取地址类
 * 
 * @author beoka
 */
public class AddressUtils
{
    private static final Logger log = LoggerFactory.getLogger(AddressUtils.class);

    // IP地址查询
    public static final String IP_URL = "http://whois.pconline.com.cn/ipJson.jsp";

    // 未知地址
    public static final String UNKNOWN = "XX XX";

    public static String getRealAddressByIP(String ip)
    {
        String address = UNKNOWN;
        // 内网不查询
        if (IpUtils.internalIp(ip))
        {
            return "内网IP";
        }
        if (true)
        {
            try
            {
                String rspStr = HttpUtils.sendGet(IP_URL, "ip=" + ip + "&json=true", "GBK");
                if (StringUtils.isEmpty(rspStr))
                {
                    log.error("获取地理位置异常 {}", ip);
                    return UNKNOWN;
                }
                JSONObject obj = JSONObject.parseObject(rspStr);
                String region = obj.getString("pro");
                String city = obj.getString("city");
                return String.format("%s %s", region, city);
            }
            catch (Exception e)
            {
                log.error("获取地理位置异常 {}", ip);
            }
        }
        return address;
    }
}
```

EscapeUtil:

```java
package com.beoka.iot.util.ip;

import cn.hutool.http.HTMLFilter;
import org.apache.commons.lang3.StringUtils;

/**
 * 转义和反转义工具类
 * 
 * @author beoka
 */
public class EscapeUtil
{
    public static final String RE_HTML_MARK = "(<[^<]*?>)|(<[\\s]*?/[^<]*?>)|(<[^<]*?/[\\s]*?>)";

    private static final char[][] TEXT = new char[64][];

    static
    {
        for (int i = 0; i < 64; i++)
        {
            TEXT[i] = new char[] { (char) i };
        }

        // special HTML characters
        TEXT['\''] = "&#039;".toCharArray(); // 单引号
        TEXT['"'] = "&#34;".toCharArray(); // 单引号
        TEXT['&'] = "&#38;".toCharArray(); // &符
        TEXT['<'] = "&#60;".toCharArray(); // 小于号
        TEXT['>'] = "&#62;".toCharArray(); // 大于号
    }

    /**
     * 转义文本中的HTML字符为安全的字符
     * 
     * @param text 被转义的文本
     * @return 转义后的文本
     */
    public static String escape(String text)
    {
        return encode(text);
    }

    /**
     * 还原被转义的HTML特殊字符
     * 
     * @param content 包含转义符的HTML内容
     * @return 转换后的字符串
     */
    public static String unescape(String content)
    {
        return decode(content);
    }

    /**
     * 清除所有HTML标签，但是不删除标签内的内容
     * 
     * @param content 文本
     * @return 清除标签后的文本
     */
    public static String clean(String content)
    {
        return new HTMLFilter().filter(content);
    }


    /**
     * Escape编码
     * 
     * @param text 被编码的文本
     * @return 编码后的字符
     */
    private static String encode(String text)
    {
        int len;
        if ((text == null) || ((len = text.length()) == 0))
        {
            return StringUtils.EMPTY;
        }
        StringBuilder buffer = new StringBuilder(len + (len >> 2));
        char c;
        for (int i = 0; i < len; i++)
        {
            c = text.charAt(i);
            if (c < 64)
            {
                buffer.append(TEXT[c]);
            }
            else
            {
                buffer.append(c);
            }
        }
        return buffer.toString();
    }

    /**
     * Escape解码
     * 
     * @param content 被转义的内容
     * @return 解码后的字符串
     */
    public static String decode(String content)
    {
        if (StringUtils.isEmpty(content))
        {
            return content;
        }

        StringBuilder tmp = new StringBuilder(content.length());
        int lastPos = 0, pos = 0;
        char ch;
        while (lastPos < content.length())
        {
            pos = content.indexOf("%", lastPos);
            if (pos == lastPos)
            {
                if (content.charAt(pos + 1) == 'u')
                {
                    ch = (char) Integer.parseInt(content.substring(pos + 2, pos + 6), 16);
                    tmp.append(ch);
                    lastPos = pos + 6;
                }
                else
                {
                    ch = (char) Integer.parseInt(content.substring(pos + 1, pos + 3), 16);
                    tmp.append(ch);
                    lastPos = pos + 3;
                }
            }
            else
            {
                if (pos == -1)
                {
                    tmp.append(content.substring(lastPos));
                    lastPos = content.length();
                }
                else
                {
                    tmp.append(content.substring(lastPos, pos));
                    lastPos = pos;
                }
            }
        }
        return tmp.toString();
    }

    public static void main(String[] args)
    {
        String html = "<script>alert(1);</script>";
        // String html = "<scr<script>ipt>alert(\"XSS\")</scr<script>ipt>";
        // String html = "<123";
        // String html = "123>";
        System.out.println(EscapeUtil.clean(html));
        System.out.println(EscapeUtil.escape(html));
        System.out.println(EscapeUtil.unescape(html));
    }
}
```
HttpUtils:
```java
/**
 * 通用http发送方法
 * 
 * @author beoka
 */
public class HttpUtils
{
    private static final Logger log = LoggerFactory.getLogger(HttpUtils.class);

    /**
     * 向指定 URL 发送GET方法的请求
     *
     * @param url 发送请求的 URL
     * @param param 请求参数，请求参数应该是 name1=value1&name2=value2 的形式。
     * @return 所代表远程资源的响应结果
     */
    public static String sendGet(String url, String param)
    {
        return sendGet(url, param, "utf-8");
    }

    /**
     * 向指定 URL 发送GET方法的请求
     *
     * @param url 发送请求的 URL
     * @param param 请求参数，请求参数应该是 name1=value1&name2=value2 的形式。
     * @param contentType 编码类型
     * @return 所代表远程资源的响应结果
     */
    public static String sendGet(String url, String param, String contentType)
    {
        StringBuilder result = new StringBuilder();
        BufferedReader in = null;
        try
        {
            String urlNameString = url + "?" + param;
            log.info("sendGet - {}", urlNameString);
            URL realUrl = new URL(urlNameString);
            URLConnection connection = realUrl.openConnection();
            connection.setRequestProperty("accept", "*/*");
            connection.setRequestProperty("connection", "Keep-Alive");
            connection.setRequestProperty("user-agent", "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1;SV1)");
            connection.connect();
            in = new BufferedReader(new InputStreamReader(connection.getInputStream(), contentType));
            String line;
            while ((line = in.readLine()) != null)
            {
                result.append(line);
            }
            log.info("recv - {}", result);
        }
        catch (ConnectException e)
        {
            log.error("调用HttpUtils.sendGet ConnectException, url=" + url + ",param=" + param, e);
        }
        catch (SocketTimeoutException e)
        {
            log.error("调用HttpUtils.sendGet SocketTimeoutException, url=" + url + ",param=" + param, e);
        }
        catch (IOException e)
        {
            log.error("调用HttpUtils.sendGet IOException, url=" + url + ",param=" + param, e);
        }
        catch (Exception e)
        {
            log.error("调用HttpsUtil.sendGet Exception, url=" + url + ",param=" + param, e);
        }
        finally
        {
            try
            {
                if (in != null)
                {
                    in.close();
                }
            }
            catch (Exception ex)
            {
                log.error("调用in.close Exception, url=" + url + ",param=" + param, ex);
            }
        }
        return result.toString();
    }

    /**
     * 向指定 URL 发送POST方法的请求
     *
     * @param url 发送请求的 URL
     * @param param 请求参数，请求参数应该是 name1=value1&name2=value2 的形式。
     * @return 所代表远程资源的响应结果
     */
    public static String sendPost(String url, String param)
    {
        PrintWriter out = null;
        BufferedReader in = null;
        StringBuilder result = new StringBuilder();
        try
        {
            String urlNameString = url;
            log.info("sendPost - {}", urlNameString);
            URL realUrl = new URL(urlNameString);
            URLConnection conn = realUrl.openConnection();
            conn.setRequestProperty("accept", "*/*");
            conn.setRequestProperty("connection", "Keep-Alive");
            conn.setRequestProperty("user-agent", "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1;SV1)");
            conn.setRequestProperty("Accept-Charset", "utf-8");
            conn.setRequestProperty("contentType", "utf-8");
            conn.setDoOutput(true);
            conn.setDoInput(true);
            out = new PrintWriter(conn.getOutputStream());
            out.print(param);
            out.flush();
            in = new BufferedReader(new InputStreamReader(conn.getInputStream(), "utf-8"));
            String line;
            while ((line = in.readLine()) != null)
            {
                result.append(line);
            }
            log.info("recv - {}", result);
        }
        catch (ConnectException e)
        {
            log.error("调用HttpUtils.sendPost ConnectException, url=" + url + ",param=" + param, e);
        }
        catch (SocketTimeoutException e)
        {
            log.error("调用HttpUtils.sendPost SocketTimeoutException, url=" + url + ",param=" + param, e);
        }
        catch (IOException e)
        {
            log.error("调用HttpUtils.sendPost IOException, url=" + url + ",param=" + param, e);
        }
        catch (Exception e)
        {
            log.error("调用HttpsUtil.sendPost Exception, url=" + url + ",param=" + param, e);
        }
        finally
        {
            try
            {
                if (out != null)
                {
                    out.close();
                }
                if (in != null)
                {
                    in.close();
                }
            }
            catch (IOException ex)
            {
                log.error("调用in.close Exception, url=" + url + ",param=" + param, ex);
            }
        }
        return result.toString();
    }

    public static String sendSSLPost(String url, String param)
    {
        StringBuilder result = new StringBuilder();
        String urlNameString = url + "?" + param;
        try
        {
            log.info("sendSSLPost - {}", urlNameString);
            SSLContext sc = SSLContext.getInstance("SSL");
            sc.init(null, new TrustManager[] { new TrustAnyTrustManager() }, new java.security.SecureRandom());
            URL console = new URL(urlNameString);
            HttpsURLConnection conn = (HttpsURLConnection) console.openConnection();
            conn.setRequestProperty("accept", "*/*");
            conn.setRequestProperty("connection", "Keep-Alive");
            conn.setRequestProperty("user-agent", "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1;SV1)");
            conn.setRequestProperty("Accept-Charset", "utf-8");
            conn.setRequestProperty("contentType", "utf-8");
            conn.setDoOutput(true);
            conn.setDoInput(true);

            conn.setSSLSocketFactory(sc.getSocketFactory());
            conn.setHostnameVerifier(new TrustAnyHostnameVerifier());
            conn.connect();
            InputStream is = conn.getInputStream();
            BufferedReader br = new BufferedReader(new InputStreamReader(is));
            String ret = "";
            while ((ret = br.readLine()) != null)
            {
                if (ret != null && !"".equals(ret.trim()))
                {
                    result.append(new String(ret.getBytes("ISO-8859-1"), "utf-8"));
                }
            }
            log.info("recv - {}", result);
            conn.disconnect();
            br.close();
        }
        catch (ConnectException e)
        {
            log.error("调用HttpUtils.sendSSLPost ConnectException, url=" + url + ",param=" + param, e);
        }
        catch (SocketTimeoutException e)
        {
            log.error("调用HttpUtils.sendSSLPost SocketTimeoutException, url=" + url + ",param=" + param, e);
        }
        catch (IOException e)
        {
            log.error("调用HttpUtils.sendSSLPost IOException, url=" + url + ",param=" + param, e);
        }
        catch (Exception e)
        {
            log.error("调用HttpsUtil.sendSSLPost Exception, url=" + url + ",param=" + param, e);
        }
        return result.toString();
    }

    private static class TrustAnyTrustManager implements X509TrustManager
    {
        @Override
        public void checkClientTrusted(X509Certificate[] chain, String authType)
        {
        }

        @Override
        public void checkServerTrusted(X509Certificate[] chain, String authType)
        {
        }

        @Override
        public X509Certificate[] getAcceptedIssuers()
        {
            return new X509Certificate[] {};
        }
    }

    private static class TrustAnyHostnameVerifier implements HostnameVerifier
    {
        @Override
        public boolean verify(String hostname, SSLSession session)
        {
            return true;
        }
    }
}
```

IpUtil:

```java
package com.beoka.iot.util.ip;

import org.apache.commons.lang3.StringUtils;

import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.Objects;
import javax.servlet.http.HttpServletRequest;



/**
 * 获取IP方法
 * 
 * @author beoka
 */
public class IpUtils
{
    public static String getIpAddr(HttpServletRequest request)
    {
        if (request == null)
        {
            return "unknown";
        }
        String ip = request.getHeader("x-forwarded-for");
        if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip))
        {
            ip = request.getHeader("Proxy-Client-IP");
        }
        if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip))
        {
            ip = request.getHeader("X-Forwarded-For");
        }
        if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip))
        {
            ip = request.getHeader("WL-Proxy-Client-IP");
        }
        if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip))
        {
            ip = request.getHeader("X-Real-IP");
        }

        if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip))
        {
            ip = request.getRemoteAddr();
        }
        return "0:0:0:0:0:0:0:1".equals(ip) ? "127.0.0.1" : EscapeUtil.clean(ip);
    }

    public static boolean internalIp(String ip)
    {
        byte[] addr = textToNumericFormatV4(ip);
        return internalIp(addr) || "127.0.0.1".equals(ip);
    }

    private static boolean internalIp(byte[] addr)
    {
        if (Objects.isNull(addr) || addr.length < 2)
        {
            return true;
        }
        final byte b0 = addr[0];
        final byte b1 = addr[1];
        // 10.x.x.x/8
        final byte SECTION_1 = 0x0A;
        // 172.16.x.x/12
        final byte SECTION_2 = (byte) 0xAC;
        final byte SECTION_3 = (byte) 0x10;
        final byte SECTION_4 = (byte) 0x1F;
        // 192.168.x.x/16
        final byte SECTION_5 = (byte) 0xC0;
        final byte SECTION_6 = (byte) 0xA8;
        switch (b0)
        {
            case SECTION_1:
                return true;
            case SECTION_2:
                if (b1 >= SECTION_3 && b1 <= SECTION_4)
                {
                    return true;
                }
            case SECTION_5:
                switch (b1)
                {
                    case SECTION_6:
                        return true;
                }
            default:
                return false;
        }
    }

    /**
     * 将IPv4地址转换成字节
     * 
     * @param text IPv4地址
     * @return byte 字节
     */
    public static byte[] textToNumericFormatV4(String text)
    {
        if (text.length() == 0)
        {
            return null;
        }

        byte[] bytes = new byte[4];
        String[] elements = text.split("\\.", -1);
        try
        {
            long l;
            int i;
            switch (elements.length)
            {
                case 1:
                    l = Long.parseLong(elements[0]);
                    if ((l < 0L) || (l > 4294967295L)) {
                        return null;
                    }
                    bytes[0] = (byte) (int) (l >> 24 & 0xFF);
                    bytes[1] = (byte) (int) ((l & 0xFFFFFF) >> 16 & 0xFF);
                    bytes[2] = (byte) (int) ((l & 0xFFFF) >> 8 & 0xFF);
                    bytes[3] = (byte) (int) (l & 0xFF);
                    break;
                case 2:
                    l = Integer.parseInt(elements[0]);
                    if ((l < 0L) || (l > 255L)) {
                        return null;
                    }
                    bytes[0] = (byte) (int) (l & 0xFF);
                    l = Integer.parseInt(elements[1]);
                    if ((l < 0L) || (l > 16777215L)) {
                        return null;
                    }
                    bytes[1] = (byte) (int) (l >> 16 & 0xFF);
                    bytes[2] = (byte) (int) ((l & 0xFFFF) >> 8 & 0xFF);
                    bytes[3] = (byte) (int) (l & 0xFF);
                    break;
                case 3:
                    for (i = 0; i < 2; ++i)
                    {
                        l = Integer.parseInt(elements[i]);
                        if ((l < 0L) || (l > 255L)) {
                            return null;
                        }
                        bytes[i] = (byte) (int) (l & 0xFF);
                    }
                    l = Integer.parseInt(elements[2]);
                    if ((l < 0L) || (l > 65535L)) {
                        return null;
                    }
                    bytes[2] = (byte) (int) (l >> 8 & 0xFF);
                    bytes[3] = (byte) (int) (l & 0xFF);
                    break;
                case 4:
                    for (i = 0; i < 4; ++i)
                    {
                        l = Integer.parseInt(elements[i]);
                        if ((l < 0L) || (l > 255L)) {
                            return null;
                        }
                        bytes[i] = (byte) (int) (l & 0xFF);
                    }
                    break;
                default:
                    return null;
            }
        }
        catch (NumberFormatException e)
        {
            return null;
        }
        return bytes;
    }

    public static String getHostIp()
    {
        try
        {
            return InetAddress.getLocalHost().getHostAddress();
        }
        catch (UnknownHostException e)
        {
        }
        return "127.0.0.1";
    }

    public static String getHostName()
    {
        try
        {
            return InetAddress.getLocalHost().getHostName();
        }
        catch (UnknownHostException e)
        {
        }
        return "未知";
    }
}
```

## 2. 距离位置计算(km)

```java
public final class DistanceUtils {
 
    /**
     * 地球半径,单位 km
     */
    private static final double EARTH_RADIUS = 6378.137;
 
    /**
     * 根据经纬度，计算两点间的距离
     *
     * @param longitude1 第一个点的经度
     * @param latitude1  第一个点的纬度
     * @param longitude2 第二个点的经度
     * @param latitude2  第二个点的纬度
     * @return 返回距离 单位千米
     */
    public static double getDistance(double longitude1, double latitude1, double longitude2, double latitude2) {
        // 纬度
        double lat1 = Math.toRadians(latitude1);
        double lat2 = Math.toRadians(latitude2);
        // 经度
        double lng1 = Math.toRadians(longitude1);
        double lng2 = Math.toRadians(longitude2);
        // 纬度之差
        double a = lat1 - lat2;
        // 经度之差
        double b = lng1 - lng2;
        // 计算两点距离的公式
        double s = 2 * Math.asin(Math.sqrt(Math.pow(Math.sin(a / 2), 2) +
                Math.cos(lat1) * Math.cos(lat2) * Math.pow(Math.sin(b / 2), 2)));
        // 弧长乘地球半径, 返回单位: 千米
        s =  s * EARTH_RADIUS;
        return s;
    }
}
```

## 3.手动分页(新-旧)

在一些查询数据中我们需要对查询的数据进行分页，如果是数据库那么可以用limit来进行分页，可是如果是从其他地方获取到的数据那么就不能方便的进行分页，如：Redis等;

旧:

```java
 Long pageCount = Convert.toLong(collect.size());
//手动分页
if (pageIndex.compareTo(ZERO) > ZERO) {
    pageIndex -= 1;
}
int end = PageUtil.getEnd(pageIndex, pageSize);
//判断
if (end >= pageCount) {
    end = Convert.toInt(pageCount);
}
collect=collect.subList(pageIndex, end);
```

新:

```java
public class PageUtil<T> {
    public PageUtil() {
    }

    private static final Integer pageIndex = 1;
    private static final Integer pageSize = 10;

    public static<T> List<T> startPage(List<T> collect) {
        return startPage(collect,pageIndex, pageSize);
    }


    public static<T> List<T> startPage(List<T> collect, Integer pageIndex, Integer pageSize) {
        try {
            if (CollUtil.isEmpty(collect)) {
                return collect;
            }
            //手动分页
            int totalcount = collect.size();
            int pagecount = 0;
            int m = totalcount % pageSize;
            if (m > 0) {
                pagecount = totalcount / pageSize + 1;
            } else {
                pagecount = totalcount / pageSize;
            }
            if (m == 0) {
                collect = collect.subList((pageIndex - 1) * pageSize, pageSize * (pageIndex));
            } else {
                if (pageIndex == pagecount) {
                    collect = collect.subList((pageIndex - 1) * pageSize, totalcount);
                } else {
                    collect = collect.subList((pageIndex - 1) * pageSize, pageSize * (pageIndex));
                }
            }
        } catch (Exception e) {
            throw new BeokaRuntimeException("分页出现异常");
        }
        return collect;
    }
}
```

## 4.敏感词检测

检测敏感词(采用DFA算法):

```java
package com.beoka.iot.util;

import cn.hutool.core.date.DateUtil;
import lombok.extern.slf4j.Slf4j;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.*;

/**
 * 敏感词处理工具 - DFA算法实现
 *
 * @author MiaoDaWei
 */
@Slf4j
public class SensitiveWordUtil {

    /**
     * 敏感词匹配规则
     */
    public static final int MinMatchTYpe = 1;      //最小匹配规则，如：敏感词库["中国","中国人"]，语句："我是中国人"，匹配结果：我是[中国]人
    public static final int MaxMatchType = 2;      //最大匹配规则，如：敏感词库["中国","中国人"]，语句："我是中国人"，匹配结果：我是[中国人]
    static {
        //初始化敏感词库
        final Set<String> sensitiveWordSet = new HashSet<>((readWordFile("/敏感词.txt")));
        //初始化
        init(sensitiveWordSet);
    }
    /**
     * 敏感词集合
     */
    public static HashMap sensitiveWordMap;

    /**
     * 初始化敏感词库，构建DFA算法模型
     *
     * @param sensitiveWordSet 敏感词库
     */
    public static synchronized void init(Set<String> sensitiveWordSet) {
        initSensitiveWordMap(sensitiveWordSet);
    }

    /**
     * 初始化敏感词库，构建DFA算法模型
     *
     * @param sensitiveWordSet 敏感词库
     */
    private static void initSensitiveWordMap(Set<String> sensitiveWordSet) {
        //初始化敏感词容器，减少扩容操作
        sensitiveWordMap = new HashMap(sensitiveWordSet.size());
        String key;
        Map nowMap;
        Map<String, String> newWorMap;
        //迭代sensitiveWordSet
        Iterator<String> iterator = sensitiveWordSet.iterator();
        while (iterator.hasNext()) {
            //关键字
            key = iterator.next();
            nowMap = sensitiveWordMap;
            for (int i = 0; i < key.length(); i++) {
                //转换成char型
                char keyChar = key.charAt(i);
                //库中获取关键字
                Object wordMap = nowMap.get(keyChar);
                //如果存在该key，直接赋值，用于下一个循环获取
                if (wordMap != null) {
                    nowMap = (Map) wordMap;
                } else {
                    //不存在则，则构建一个map，同时将isEnd设置为0，因为他不是最后一个
                    newWorMap = new HashMap<>();
                    //不是最后一个
                    newWorMap.put("isEnd", "0");
                    nowMap.put(keyChar, newWorMap);
                    nowMap = newWorMap;
                }

                if (i == key.length() - 1) {
                    //最后一个
                    nowMap.put("isEnd", "1");
                }
            }
        }
    }

    /**
     * 判断文字是否包含敏感字符
     *
     * @param txt       文字
     * @param matchType 匹配规则 1：最小匹配规则，2：最大匹配规则
     * @return 若包含返回true，否则返回false
     */
    public static boolean contains(String txt, int matchType) {
        boolean flag = false;
        for (int i = 0; i < txt.length(); i++) {
            int matchFlag = checkSensitiveWord(txt, i, matchType); //判断是否包含敏感字符
            if (matchFlag > 0) {    //大于0存在，返回true
                flag = true;
            }
        }
        return flag;
    }

    /**
     * 判断文字是否包含敏感字符
     *
     * @param txt 文字
     * @return 若包含返回true，否则返回false
     */
    public static boolean contains(String txt) {
        return contains(txt, MaxMatchType);
    }

    /**
     * 获取文字中的敏感词
     *
     * @param txt       文字
     * @param matchType 匹配规则 1：最小匹配规则，2：最大匹配规则
     * @return
     */
    public static Set<String> getSensitiveWord(String txt, int matchType) {
        Set<String> sensitiveWordList = new HashSet<>();

        for (int i = 0; i < txt.length(); i++) {
            //判断是否包含敏感字符
            int length = checkSensitiveWord(txt, i, matchType);
            if (length > 0) {//存在,加入list中
                sensitiveWordList.add(txt.substring(i, i + length));
                i = i + length - 1;//减1的原因，是因为for会自增
            }
        }

        return sensitiveWordList;
    }

    /**
     * 获取文字中的敏感词
     *
     * @param txt 文字
     * @return
     */
    public static Set<String> getSensitiveWord(String txt) {
        return getSensitiveWord(txt, MaxMatchType);
    }

    /**
     * 替换敏感字字符
     *
     * @param txt         文本
     * @param replaceChar 替换的字符，匹配的敏感词以字符逐个替换，如 语句：我爱中国人 敏感词：中国人，替换字符：*， 替换结果：我爱***
     * @param matchType   敏感词匹配规则
     * @return
     */
    public static String replaceSensitiveWord(String txt, char replaceChar, int matchType) {
        String resultTxt = txt;
        //获取所有的敏感词
        Set<String> set = getSensitiveWord(txt, matchType);
        Iterator<String> iterator = set.iterator();
        String word;
        String replaceString;
        while (iterator.hasNext()) {
            word = iterator.next();
            replaceString = getReplaceChars(replaceChar, word.length());
            resultTxt = resultTxt.replaceAll(word, replaceString);
        }

        return resultTxt;
    }

    /**
     * 替换敏感字字符
     *
     * @param txt         文本
     * @param replaceChar 替换的字符，匹配的敏感词以字符逐个替换，如 语句：我爱中国人 敏感词：中国人，替换字符：*， 替换结果：我爱***
     * @return
     */
    public static String replaceSensitiveWord(String txt, char replaceChar) {
        return replaceSensitiveWord(txt, replaceChar, MaxMatchType);
    }

    /**
     * 替换敏感字字符
     *
     * @param txt        文本
     * @param replaceStr 替换的字符串，匹配的敏感词以字符逐个替换，如 语句：我爱中国人 敏感词：中国人，替换字符串：[屏蔽]，替换结果：我爱[屏蔽]
     * @param matchType  敏感词匹配规则
     * @return
     */
    public static String replaceSensitiveWord(String txt, String replaceStr, int matchType) {
        String resultTxt = txt;
        //获取所有的敏感词
        Set<String> set = getSensitiveWord(txt, matchType);
        Iterator<String> iterator = set.iterator();
        String word;
        while (iterator.hasNext()) {
            word = iterator.next();
            resultTxt = resultTxt.replaceAll(word, replaceStr);
        }

        return resultTxt;
    }

    /**
     * 替换敏感字字符
     *
     * @param txt        文本
     * @param replaceStr 替换的字符串，匹配的敏感词以字符逐个替换，如 语句：我爱中国人 敏感词：中国人，替换字符串：[屏蔽]，替换结果：我爱[屏蔽]
     * @return
     */
    public static String replaceSensitiveWord(String txt, String replaceStr) {
        return replaceSensitiveWord(txt, replaceStr, MaxMatchType);
    }

    /**
     * 获取替换字符串
     *
     * @param replaceChar
     * @param length
     * @return
     */
    private static String getReplaceChars(char replaceChar, int length) {
        String resultReplace = String.valueOf(replaceChar);
        for (int i = 1; i < length; i++) {
            resultReplace += replaceChar;
        }

        return resultReplace;
    }

    /**
     * 检查文字中是否包含敏感字符，检查规则如下：<br>
     *
     * @param txt
     * @param beginIndex
     * @param matchType
     * @return 如果存在，则返回敏感词字符的长度，不存在返回0
     */
    private static int checkSensitiveWord(String txt, int beginIndex, int matchType) {
        //敏感词结束标识位：用于敏感词只有1位的情况
        boolean flag = false;
        //匹配标识数默认为0
        int matchFlag = 0;
        char word;
        Map nowMap = sensitiveWordMap;
        for (int i = beginIndex; i < txt.length(); i++) {
            word = txt.charAt(i);
            //获取指定key
            nowMap = (Map) nowMap.get(word);
            if (nowMap != null) {//存在，则判断是否为最后一个
                //找到相应key，匹配标识+1
                matchFlag++;
                //如果为最后一个匹配规则,结束循环，返回匹配标识数
                if ("1".equals(nowMap.get("isEnd"))) {
                    //结束标志位为true
                    flag = true;
                    //最小规则，直接返回,最大规则还需继续查找
                    if (MinMatchTYpe == matchType) {
                        break;
                    }
                }
            } else {//不存在，直接返回
                break;
            }
        }
        if (matchFlag < 2 || !flag) {//长度必须大于等于1，为词
            matchFlag = 0;
        }
        return matchFlag;
    }
    /**
     * 读取敏感词库中的内容，将内容添加到set集合中
     */
    private static Set<String> readWordFile(String file) {
        Set<String> set;
        // 字符编码
        String encoding = "UTF-8";
        try (InputStreamReader read = new InputStreamReader(
                SensitiveWordUtil.class.getResourceAsStream(file), encoding)) {
            set = new HashSet<>();
            BufferedReader bufferedReader = new BufferedReader(read);
            String txt;
            // 读取文件，将文件内容放入到set中
            while ((txt = bufferedReader.readLine()) != null) {
                set.add(txt);
            }
        } catch (Exception e) {
            return new HashSet<>();
        }
        // 关闭文件流
        return set;
    }

    /**
     * 是否包含敏感词
     *
     * @param str str
     * @return boolean
     */
    public static boolean include(String str) {
        log.info("【{}】-【{}】待检测语句：【{}】", DateUtil.now(), "敏感词检测", str);
        //是否含有关键字
        boolean result = SensitiveWordUtil.contains(str);
        //获取语句中的敏感词
        Set<String> set = SensitiveWordUtil.getSensitiveWord(str);
        log.info("【{}】-【{}】语句中包含敏感词的个数为：【{}】。包含【{}】", DateUtil.now(), "敏感词检测", set.size(), set);
        return result;
    }


    public static void main(String[] args) throws Exception {
        Set<String> sensitiveWordSet = new HashSet<>((readWordFile("/色情词库.txt")));
        //初始化敏感词库
        SensitiveWordUtil.init(sensitiveWordSet);

        System.out.println("敏感词的数量：" + SensitiveWordUtil.sensitiveWordMap.size());
//        String string = "太多的伤感情怀也许只局限于饲养基地 荧幕中的情节。"
//                + "然后我们的扮演的角色就是跟随着主人公的喜红客联盟 怒哀乐而过于牵强的把自己的情感也附加于银幕情节中，然后感动就流泪，"
//                + "难过就躺在某一个人的怀里尽情的阐述心扉或者手机卡复制器一个贱人一杯红酒一部电影在夜 深人静的晚上，关上电话静静的发呆着。";
        String string = "便携式深沉肌肉按摩仪";
        System.out.println("待检测语句字数：" + string.length());

        //是否含有关键字
        boolean result = SensitiveWordUtil.contains(string);
        System.out.println(result);
        result = SensitiveWordUtil.contains(string, SensitiveWordUtil.MinMatchTYpe);
        System.out.println(result);

        //获取语句中的敏感词
        Set<String> set = SensitiveWordUtil.getSensitiveWord(string);
        System.out.println("语句中包含敏感词的个数为：" + set.size() + "。包含：" + set);
        set = SensitiveWordUtil.getSensitiveWord(string, SensitiveWordUtil.MinMatchTYpe);
        System.out.println("语句中包含敏感词的个数为：" + set.size() + "。包含：" + set);

        //替换语句中的敏感词
        String filterStr = SensitiveWordUtil.replaceSensitiveWord(string, '*');
        System.out.println(filterStr);
        filterStr = SensitiveWordUtil.replaceSensitiveWord(string, '*', SensitiveWordUtil.MinMatchTYpe);
        System.out.println(filterStr);

        String filterStr2 = SensitiveWordUtil.replaceSensitiveWord(string, "[*敏感词*]");
        System.out.println(filterStr2);
        filterStr2 = SensitiveWordUtil.replaceSensitiveWord(string, "[*敏感词*]", SensitiveWordUtil.MinMatchTYpe);
        System.out.println(filterStr2);
    }
}
```

这是其他链接:https://blog.csdn.net/sinat_14982831/article/details/77836034?fps=1&locationNum=2

相关敏感词库我已放在gitee上:https://gitee.com/miawei/resource/tree/master/%E6%95%8F%E6%84%9F%E8%AF%8D

## 5.log4j2日志配置及踩坑

这是日志配置:

添加依赖:

```xml-dtd
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-log4j2</artifactId>
</dependency>
```

然后在resource/log4j2.xml

```xml-dtd
<?xml version="1.0" encoding="UTF-8"?>
<!--日志级别以及优先级排序: OFF > FATAL > ERROR > WARN > INFO > DEBUG > TRACE > ALL -->
<!--Configuration后面的status，这个用于设置log4j2自身内部的信息输出，可以不设置，当设置成trace时，你会看到log4j2内部各种详细输出-->
<!--monitorInterval：Log4j能够自动检测修改配置 文件和重新配置本身，设置间隔秒数-->
<configuration status="WARN" monitorInterval="30">
    <!--先定义所有的appender-->
    <appenders>
        <!--这个输出控制台的配置-->
        <console name="Console" target="SYSTEM_OUT">
            <!--输出日志的格式-->
            <PatternLayout pattern="[%d{HH:mm:ss:SSS}] [%p] - %l - %m%n"/>
        </console>
        <!--文件会打印出所有信息，这个log每次运行程序会自动清空，由append属性决定，这个也挺有用的，适合临时测试用-->
        <File name="log" fileName="log/test.log" append="false">
            <PatternLayout pattern="%d{HH:mm:ss.SSS} %-5level %class{36} %L %M - %msg%xEx%n"/>
        </File>
        <!-- 这个会打印出所有的info及以下级别的信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档-->
        <RollingFile name="RollingFileInfo" fileName="${sys:user.home}/logs/iot/auth/info.log"
                     filePattern="${sys:user.home}/logs/iot/auth/$${date:yyyy-MM}/info-%d{yyyy-MM-dd}-%i.log">
            <!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）-->
            <ThresholdFilter level="info" onMatch="ACCEPT" onMismatch="DENY"/>
            <PatternLayout pattern="[%d{HH:mm:ss:SSS}] [%p] - %l - %m%n"/>
            <Policies>
                <TimeBasedTriggeringPolicy/>
                <SizeBasedTriggeringPolicy size="100 MB"/>
            </Policies>
        </RollingFile>
        <RollingFile name="RollingFileWarn" fileName="${sys:user.home}/logs/iot/auth/warn.log"
                     filePattern="${sys:user.home}/logs/iot/auth/$${date:yyyy-MM}/warn-%d{yyyy-MM-dd}-%i.log">
            <ThresholdFilter level="warn" onMatch="ACCEPT" onMismatch="DENY"/>
            <PatternLayout pattern="[%d{HH:mm:ss:SSS}] [%p] - %l - %m%n"/>
            <Policies>
                <TimeBasedTriggeringPolicy/>
                <SizeBasedTriggeringPolicy size="100 MB"/>
            </Policies>
            <!-- DefaultRolloverStrategy属性如不设置，则默认为最多同一文件夹下7个文件，这里设置了20 -->
            <DefaultRolloverStrategy max="20"/>
        </RollingFile>
        <RollingFile name="RollingFileError" fileName="${sys:user.home}/logs/iot/auth/error.log"
                     filePattern="${sys:user.home}/logs/iot/auth/$${date:yyyy-MM}/error-%d{yyyy-MM-dd}-%i.log">
            <ThresholdFilter level="error" onMatch="ACCEPT" onMismatch="DENY"/>
            <PatternLayout pattern="[%d{HH:mm:ss:SSS}] [%p] - %l - %m%n"/>
            <Policies>
                <TimeBasedTriggeringPolicy/>
                <SizeBasedTriggeringPolicy size="100 MB"/>
            </Policies>
        </RollingFile>
    </appenders>
    <!--然后定义logger，只有定义了logger并引入的appender，appender才会生效-->
    <loggers>
        <!--过滤掉spring和mybatis的一些无用的DEBUG信息-->
        <logger name="org.springframework" level="INFO"></logger>
        <logger name="org.mybatis" level="INFO"></logger>
        <root level="all">
            <appender-ref ref="Console"/>
            <appender-ref ref="RollingFileInfo"/>
            <appender-ref ref="RollingFileWarn"/>
            <appender-ref ref="RollingFileError"/>
        </root>
    </loggers>
</configuration>
```

在yml中:

```yaml
logging:
  config: classpath:log4j2/log4j2-dev.xml #指定日志配置路径
```

基本上以上配置日志就算结束了，但是由于springBoot自身自带了logback日志（默认），所以我们需要手动排除他！

这是我目前知道含有默认的依赖里面含有logback：

```xml-dtd
<!--quartz定时任务-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-quartz</artifactId>
            <exclusions> <!-- 去除springboot默认的logback配置-->
                <exclusion>
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot-starter-logging</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
<!--操作Redis-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
            <exclusions>
                <exclusion>
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot-starter-logging</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
<!--web包-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
            <exclusions> <!-- 去除springboot默认的logback配置-->
                <exclusion>
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot-starter-logging</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
<!--thymeleaf-->
		<dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-thymeleaf</artifactId>
            <exclusions> <!-- 去除springboot默认的logback配置-->
                <exclusion>
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot-starter-logging</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
```

**踩坑：**

项目使用log4j2然后需要排除项目本身自带的logback ,在这过程中漏掉了一个地方就是spring-boot-redis中的logback导致了这个问题，因为这个问题就会导致我在项目启动的时候由于使用`@slf4j`与logging与冲突了, 还有即使打包成功了但是一旦运行就报异常!

这是我解决的博客: https://blog.csdn.net/tangyajun_168/article/details/105607499

然后以上配置了之后就项目启动了之后就去:`C:\Users\MiaoDaWei\logs    `下面去找就能找到对应的日志

> 这是配置log4j2的日志的博客: https://www.cnblogs.com/keeya/p/10101547.html

## 6.大文件（秒传、断点续传、分片上传）

这个了解一点点概念，加深印象需要具体的业务场景并且也需要前端和后端协同才可以完成，所以到时候需要的时候就来边写边看

https://blog.csdn.net/Qingai521/article/details/119882230?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-8.pc_relevant_paycolumn_v3&spm=1001.2101.3001.4242.5&utm_relevant_index=9



这是最初看的：

https://mp.weixin.qq.com/s/sbw5RSOVtTXKce67reZPDA



## 7. 雪花算法

```java
package com.beoka.iot.common.utils.code;

import java.net.Inet4Address;
import java.net.UnknownHostException;
import java.util.HashSet;
import java.util.Random;
import java.util.Set;

/**
 * 雪花算法生成
 *
 * @author MiaoWei
 * @date 2022/07/01
 */
public class SnowflakeUtils {

    /**
     * 时间部分所占长度
     */
    private static final int TIME_LEN = 41;
    /**
     * 数据中心id所占长度
     */
    private static final int DATA_LEN = 5;
    /**
     * 机器id所占长度
     */
    private static final int WORK_LEN = 5;
    /**
     * 毫秒内序列所占长度
     */
    private static final int SEQ_LEN = 12;

    /**
     * 1609430400000定义起始时间 2022-01-01 00:00:00 1420041600000L
     */
    private static final long START_TIME = 1609430400000L;
    /**
     * 上次生成ID的时间截
     */
    private static long LAST_TIME_STAMP = -1L;
    /**
     * 时间部分向左移动的位数 22
     */
    private static final int TIME_LEFT_BIT = 64 - 1 - TIME_LEN;

    /**
     * 自动获取数据中心id（可以手动定义 0-31之间的数）
     */
    private static final long DATA_ID = getDataId();
    /**
     * 自动机器id（可以手动定义 0-31之间的数）
     */
    private static final long WORK_ID = getWorkId();
    /**
     * 数据中心id最大值 31
     */
    private static final int DATA_MAX_NUM = ~(-1 << DATA_LEN);
    /**
     * 机器id最大值 31
     */
    private static final int WORK_MAX_NUM = ~(-1 << WORK_LEN);
    /**
     * 随机获取数据中心id的参数 32
     */
    private static final int DATA_RANDOM = DATA_MAX_NUM + 1;
    /**
     * 随机获取机器id的参数 32
     */
    private static final int WORK_RANDOM = WORK_MAX_NUM + 1;
    /**
     * 数据中心id左移位数 17
     */
    private static final int DATA_LEFT_BIT = TIME_LEFT_BIT - DATA_LEN;
    /**
     * 机器id左移位数 12
     */
    private static final int WORK_LEFT_BIT = DATA_LEFT_BIT - WORK_LEN;

    /**
     * 上一次的毫秒内序列值
     */
    private static long LAST_SEQ = 0L;
    /**
     * 毫秒内序列的最大值 4095
     */
    private static final long SEQ_MAX_NUM = ~(-1 << SEQ_LEN);


    public synchronized static long genId() {
        long now = System.currentTimeMillis();

        //如果当前时间小于上一次ID生成的时间戳，说明系统时钟回退过这个时候应当抛出异常
        if (now < LAST_TIME_STAMP) {
            throw new RuntimeException(String.format("系统时间错误！ %d 毫秒内拒绝生成雪花ID！", START_TIME - now));
        }

        if (now == LAST_TIME_STAMP) {
            LAST_SEQ = (LAST_SEQ + 1) & SEQ_MAX_NUM;
            if (LAST_SEQ == 0) {
                now = nextMillis(LAST_TIME_STAMP);
            }
        } else {
            LAST_SEQ = 0;
        }

        //上次生成ID的时间截
        LAST_TIME_STAMP = now;

        return ((now - START_TIME) << TIME_LEFT_BIT) | (DATA_ID << DATA_LEFT_BIT) | (WORK_ID << WORK_LEFT_BIT) | LAST_SEQ;
    }


    /**
     * 获取下一不同毫秒的时间戳，不能与最后的时间戳一样
     */
    public static long nextMillis(long lastMillis) {
        long now = System.currentTimeMillis();
        while (now <= lastMillis) {
            now = System.currentTimeMillis();
        }
        return now;
    }

    /**
     * 获取字符串s的字节数组，然后将数组的元素相加，对（max+1）取余
     */
    private static int getHostId(String s, int max) {
        byte[] bytes = s.getBytes();
        int sums = 0;
        for (int b : bytes) {
            sums += b;
        }
        return sums % (max + 1);
    }

    /**
     * 根据 host address 取余，发生异常就获取 0到31之间的随机数
     */
    public static int getWorkId() {
        try {
            return getHostId(Inet4Address.getLocalHost().getHostAddress(), WORK_MAX_NUM);
        } catch (UnknownHostException e) {
            return new Random().nextInt(WORK_RANDOM);
        }
    }

    /**
     * 根据 host name 取余，发生异常就获取 0到31之间的随机数
     */
    public static int getDataId() {
        try {
            return getHostId(Inet4Address.getLocalHost().getHostName(), DATA_MAX_NUM);
        } catch (UnknownHostException e) {
            return new Random().nextInt(DATA_RANDOM);
        }
    }


    public static void main(String[] args) {
        Set ids = new HashSet();
        long start = System.currentTimeMillis();
        for (int i = 0; i < 10; i++) {
            ids.add(genId());
        }
        long end = System.currentTimeMillis();
        System.out.println(ids);
        System.out.println("共生成id[" + ids.size() + "]个，花费时间[" + (end - start) + "]毫秒");
    }
}
```

这是网上的学雪花：https://blog.csdn.net/jiaomubai/article/details/124385324

## 8.万能转（适配任何属性）

1. 统一的MQ消息体

   ```java
   public class RebateInfo {
   
       private String userId;  // 用户ID
       private String bizId;   // 业务ID
       private Date bizTime;   // 业务时间
       private String desc;    // 业务描述
       // ... get/set
   }
   ```

2. MQ消息适配类

   ```java
   public class MQAdapter {
   
       public static RebateInfo filter(String strJson, Map<String, String> link) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {
           return filter(JSON.parseObject(strJson, Map.class), link);
       }
   
       public static RebateInfo filter(Map obj, Map<String, String> link) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {
           RebateInfo rebateInfo = new RebateInfo();
           for (String key : link.keySet()) {
               Object val = obj.get(link.get(key));
               //使用反射调用的方式给我们的类型赋值
               RebateInfo.class.getMethod("set" + key.substring(0, 1).toUpperCase() + key.substring(1), String.class).invoke(rebateInfo, val.toString());
           }
           return rebateInfo;
       }
   }
   ```

3. 测试

   ```java
   create_account create_account = new create_account();
       create_account.setNumber("100001");
       create_account.setAddress("河北省.廊坊市.广阳区.大学里职业技术学院");
       create_account.setAccountDate(new Date());
       create_account.setDesc("在校开户");          
   
       HashMap<String, String> link01 = new HashMap<String, String>();
       link01.put("userId", "number");
       link01.put("bizId", "number");
       link01.put("bizTime", "accountDate");
       link01.put("desc", "desc");
       RebateInfo rebateInfo01 = MQAdapter.filter(create_account.toString(), link01);
   ```

   

## 9. 实现白名单拦截功能

```java
itstack-demo-design-10-02
└── src
    ├── main
    │   ├── java
    │   │   └── org.itstack.demo.design.door
    │   │       ├── annotation
    │   │       │	└── DoDoor.java	
    │   │       ├── config
    │   │       │	├── StarterAutoConfigure.java
    │   │       │	├── StarterService.java
    │   │       │	└── StarterServiceProperties.java
    │   │       └── DoJoinPoint.java
    │   └── resources	
    │       └── META_INF
    │           └── spring.factories
    └── test
        └── java
            └── org.itstack.demo.test
                └── ApiTest.java
```

![image-20221230143534703](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/202212301435767.png)

右侧是为了获取配置文件，左侧是对于切面的处理

代码：

1. 配置服务类

   ```java
   //获取配置信息
   public class StarterService {
   
       private String userStr;
   
       public StarterService(String userStr) {
           this.userStr = userStr;
       }
   
       public String[] split(String separatorChar) {
           return StringUtils.split(this.userStr, separatorChar);
       }
   }
   ```

2. 配置类注解定义

   ```java
   @ConfigurationProperties("itstack.door")
   public class StarterServiceProperties {
   
       private String userStr;
   
       public String getUserStr() {
           return userStr;
       }
   
       public void setUserStr(String userStr) {
           this.userStr = userStr;
       }
   }
   ```

3. 自定义配置类信息获取

   ```java
   @Configuration
   @ConditionalOnClass(StarterService.class)
   @EnableConfigurationProperties(StarterServiceProperties.class)
   public class StarterAutoConfigure {
   
       @Autowired
       private StarterServiceProperties properties;
   
       @Bean
       @ConditionalOnMissingBean
       @ConditionalOnProperty(prefix = "itstack.door", value = "enabled", havingValue = "true")
       StarterService starterService() {
           return new StarterService(properties.getUserStr());
       }
   }
   ```

4. 切面注解定义

   ```java
   @Retention(RetentionPolicy.RUNTIME)
   @Target(ElementType.METHOD)
   //此注解添加到需要扩展白名单的方法上。
   //这里提供了两个入参，key：获取某个字段例如用户ID、returnJson：确定白名单拦截后返回的具体内容。
   public @interface DoDoor {
   
       String key() default "";
   
       String returnJson() default "";
   
   }
   ```

5. 白名单切面逻辑

   ```java
   @Aspect
   @Component
   public class DoJoinPoint {
   
       private Logger logger = LoggerFactory.getLogger(DoJoinPoint.class);
   
       @Autowired
       private StarterService starterService;
   
       @Pointcut("@annotation(org.itstack.demo.design.door.annotation.DoDoor)")
       //获取指定key也就是获取入参中的某个属性，这里主要是获取用户ID，通过ID进行拦截校验。
       public void aopPoint() {
       }
   
       @Around("aopPoint()")
       //切面核心逻辑，这一部分主要是判断当前访问的用户ID是否白名单用户，如果是则放行jp.proceed();，否则返回自定义的拦截提示信息
       public Object doRouter(ProceedingJoinPoint jp) throws Throwable {
           //获取内容
           Method method = getMethod(jp);
           DoDoor door = method.getAnnotation(DoDoor.class);
           //获取字段值
           String keyValue = getFiledValue(door.key(), jp.getArgs());
           logger.info("itstack door handler method：{} value：{}", method.getName(), keyValue);
           if (null == keyValue || "".equals(keyValue)) return jp.proceed();
           //配置内容
           String[] split = starterService.split(",");
           //白名单过滤
           for (String str : split) {
               if (keyValue.equals(str)) {
                   return jp.proceed();
               }
           }
           //拦截
           return returnObject(door, method);
       }
   
       private Method getMethod(JoinPoint jp) throws NoSuchMethodException {
           Signature sig = jp.getSignature();
           MethodSignature methodSignature = (MethodSignature) sig;
           return getClass(jp).getMethod(methodSignature.getName(), methodSignature.getParameterTypes());
       }
   
       private Class<? extends Object> getClass(JoinPoint jp) throws NoSuchMethodException {
           return jp.getTarget().getClass();
       }
   
       //返回对象
       //返回拦截后的转换对象，也就是说当非白名单用户访问时则返回一些提示信息。
       private Object returnObject(DoDoor doGate, Method method) throws IllegalAccessException, InstantiationException {
           Class<?> returnType = method.getReturnType();
           String returnJson = doGate.returnJson();
           if ("".equals(returnJson)) {
               return returnType.newInstance();
           }
           return JSON.parseObject(returnJson, returnType);
       }
   
       //获取属性值
       private String getFiledValue(String filed, Object[] args) {
           String filedValue = null;
           for (Object arg : args) {
               try {
                   if (null == filedValue || "".equals(filedValue)) {
                       filedValue = BeanUtils.getProperty(arg, filed);
                   } else {
                       break;
                   }
               } catch (Exception e) {
                   if (args.length == 1) {
                       return args[0].toString();
                   }
               }
           }
           return filedValue;
       }
   
   }
   ```

6. 配置yaml

   ```yaml
   # 自定义中间件配置
   itstack:
     door:
       enabled: true
       userStr: 1001,aaaa,ccc #白名单用户ID，多个逗号隔开
   ```

7. 在Controller中添加自定义注解

   ```java
   /**
    * http://localhost:8080/api/queryUserInfo?userId=1001
    * http://localhost:8080/api/queryUserInfo?userId=小团团
    */
   @DoDoor(key = "userId", returnJson = "{\"code\":\"1111\",\"info\":\"非白名单可访问用户拦截！\"}")
   @RequestMapping(path = "/api/queryUserInfo", method = RequestMethod.GET)
   public UserInfo queryUserInfo(@RequestParam String userId) {
       return new UserInfo("虫虫:" + userId, 19, "天津市南开区旮旯胡同100号");
   }
   ```

## 手写一个万能迭代器

结构：

![image-20230103155828569](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/202301031558601.png)

模型结构：

![迭代器模式模型结构](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/202301031603116.png)

1. 雇员实体类

   ```java
   /**
    * 雇员
    */
   public class Employee {
   
       private String uId;   // ID
       private String name;  // 姓名
       private String desc;  // 备注
       
       // ...get/set
   }
   ```

2. 数节点链路

   ```java
   /**
    * 树节点链路，如：A to B 描述出一套完整的树组织结构
    */
   public class Link {
   
       private String fromId; // 雇员ID
       private String toId;   // 雇员ID    
       
       // ...get/set
   }
   ```

3. 迭代器定义

   ```java
   public interface Iterator<E> {
       boolean hasNext();
       E next();
   }
   ```

4. 可迭代接口定义

   ```java
   //提供了上面迭代器的实现Iterator的获取，也就是后续在自己的数据结构中需要实现迭代器的功能并交给Iterable，由此让外部调用方进行获取使用
   public interface Iterable<E> {
       Iterator<E> iterator();
   }
   ```

5. 集合功能接口定义

   ```java
   //定义了两个泛型<E, L>，因为我们的数据结构一个是用于添加元素，另外一个是用于添加树节点的链路关系
   public interface Collection<E, L> extends Iterable<E> {
       boolean add(E e);
       boolean remove(E e);
       boolean addLink(String key, L l);
       boolean removeLink(String key);
       Iterator<E> iterator();
   }
   ```

6. (核心)迭代器功能的实现

   ```java
   public class GroupStructure implements Collection<Employee, Link> {
   
       private String groupId;                                                 // 组织ID，也是一个组织链的头部ID
       private String groupName;                                               // 组织名称
       private Map<String, Employee> employeeMap = new ConcurrentHashMap<String, Employee>();  // 雇员列表
       private Map<String, List<Link>> linkMap = new ConcurrentHashMap<String, List<Link>>();  // 组织架构关系；id->list
       private Map<String, String> invertedMap = new ConcurrentHashMap<String, String>();       // 反向关系链
   
       public GroupStructure(String groupId, String groupName) {
           this.groupId = groupId;
           this.groupName = groupName;
       }
   
       public boolean add(Employee employee) {
           return null != employeeMap.put(employee.getuId(), employee);
       }
   
       public boolean remove(Employee o) {
           return null != employeeMap.remove(o.getuId());
       }
   
       public boolean addLink(String key, Link link) {
           invertedMap.put(link.getToId(), link.getFromId());
           if (linkMap.containsKey(key)) {
               return linkMap.get(key).add(link);
           } else {
               List<Link> links = new LinkedList<Link>();
               links.add(link);
               linkMap.put(key, links);
               return true;
           }
       }
   
       public boolean removeLink(String key) {
           return null != linkMap.remove(key);
       }
   
       public Iterator<Employee> iterator() {
   
           return new Iterator<Employee>() {
   
               HashMap<String, Integer> keyMap = new HashMap<String, Integer>();
   
               int totalIdx = 0;
               private String fromId = groupId;  // 雇员ID，From
               private String toId = groupId;   // 雇员ID，To
   
               public boolean hasNext() {
                   return totalIdx < employeeMap.size();
               }
   
               public Employee next() {
                   List<Link> links = linkMap.get(toId);
                   int cursorIdx = getCursorIdx(toId);
   
                   // 同级节点扫描
                   if (null == links) {
                       cursorIdx = getCursorIdx(fromId);
                       links = linkMap.get(fromId);
                   }
   
                   // 上级节点扫描
                   while (cursorIdx > links.size() - 1) {
                       fromId = invertedMap.get(fromId);
                       cursorIdx = getCursorIdx(fromId);
                       links = linkMap.get(fromId);
                   }
   
                   // 获取节点
                   Link link = links.get(cursorIdx);
                   toId = link.getToId();
                   fromId = link.getFromId();
                   totalIdx++;
   
                   // 返回结果
                   return employeeMap.get(link.getToId());
               }
                
               // 给每个层级定义宽度遍历进度
               public int getCursorIdx(String key) {
                   int idx = 0;
                   if (keyMap.containsKey(key)) {
                       idx = keyMap.get(key);
                       keyMap.put(key, ++idx);
                   } else {
                       keyMap.put(key, idx);
                   }
                   return idx;
               }
           };
       }
   }
   ```

   - 以上的这部分代码稍微有点长，主要包括了对元素的添加和删除。另外最重要的是对遍历的实现`new Iterator<Employee>`。
   - 添加和删除元素相对来说比较简单，使用了两个map数组结构进行定义；`雇员列表`、`组织架构关系；id->list`。当元素添加元素的时候，会分别在不同的方法中向`map`结构中进行填充**指向关系(A->B)**，也就构建出了我们的树形组织关系。

7. 测试类

   ```java
   @Test
   public void test_iterator() { 
       // 数据填充
       GroupStructure groupStructure = new GroupStructure("1", "小傅哥");  
       
       // 雇员信息
       groupStructure.add(new Employee("2", "花花", "二级部门"));
       groupStructure.add(new Employee("3", "豆包", "二级部门"));
       groupStructure.add(new Employee("4", "蹦蹦", "三级部门"));
       groupStructure.add(new Employee("5", "大烧", "三级部门"));
       groupStructure.add(new Employee("6", "虎哥", "四级部门"));
       groupStructure.add(new Employee("7", "玲姐", "四级部门"));
       groupStructure.add(new Employee("8", "秋雅", "四级部门"));   
       
       // 节点关系 1->(1,2) 2->(4,5)
       groupStructure.addLink("1", new Link("1", "2"));
       groupStructure.addLink("1", new Link("1", "3"));
       groupStructure.addLink("2", new Link("2", "4"));
       groupStructure.addLink("2", new Link("2", "5"));
       groupStructure.addLink("5", new Link("5", "6"));
       groupStructure.addLink("5", new Link("5", "7"));
       groupStructure.addLink("5", new Link("5", "8"));       
   
       Iterator<Employee> iterator = groupStructure.iterator();
       while (iterator.hasNext()) {
           Employee employee = iterator.next();
           logger.info("{}，雇员 Id：{} Name：{}", employee.getDesc(), employee.getuId(), employee.getName());
       }
   }
   ```

8. 测试结果：

   ![image-20230103161320226](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/202301031613281.png)

---

迭代器实现思路：

1. 这里的树形结构我们需要做的是深度遍历，也就是左侧的一直遍历到最深节点。
2. 当遍历到最深节点后，开始遍历最深节点的横向节点。
3. 当横向节点遍历完成后则向上寻找横向节点，直至树结构全部遍历完成。

