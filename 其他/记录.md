# 笔记

## 1. 数据库三范式

范式就是规范，就是要遵守的原则。一般要遵守有三种范式

1. 1NF(1范式): 设计数据库表的列的时候，这些列不可拆分。 列的`原子性`，其实这种范式可以不用管，关系型数据库默认都满足
2. 2NF(2范式)：表中行是`唯一`，通常设计一个主键来实现
3. 3NF(3范式)： 如果一张表的数据能够通过其他表推导出来，不应该单独设计，通过外键的方式`关联查询`出来

**注意**:反3NF：正常情况来说，我们必须遵循3NF，但是有的时候我们为了增强查询效率，会设计一些冗余字段，变多表查询为单表查询。

**理解**:1范式就是说列具有原子性不能拆分了,比如状态0和1就不能再拆分了;2范式指一张表中两行数据不能完全重复;3范式说如果一张表的数据能够通过其他表得出那么此时就要通过关联来获取,对字段的冗余部分进行剔除!

## 2. 短信验证码发送流程

![image-20211030093112116](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211030093112116.png)

​	**流程**:用户发送验证码,首先从通过手机号和业务绑定一个key,然后从Redis缓存中获取,如果获取到那么此时我们就对value进行拆分,获取我们设置的时间戳,然后我们就判断这个时间戳跟当前时间戳是否相差1分钟,也就是说判断用户是否存在1分钟内连续发送,如果存在连续发送那么就抛出异常非法信息,如果超过一分钟,那么并且此时我们是可以获取到的,那么就说明是在3分钟之内的,可能因为网络延迟等原因用户没有及时的收到短信,所以避免重复发送造成验证码不一致,所以这里就直接重置验证码的时间为3分钟,然后告知用户验证码已发送,然后回到我们刚刚那个点如果在Redis获取验证码不存在那么就直接发送验证码然后存于Redis缓存,注意要先执行发送再执行放入缓存中,因为可能出现手机号发送失败,而造成验证码存于缓存中!

```bash
1.校验
 1.1 手机号不能为空
 1.2 手机号是否被注册 查询t_user表
2.判断验证码是否有效（3分钟），从redis中是否能拿到 key： business_register:15982495855
 2.1 如果拿到了 需要判断是否过了1分钟重发时间      value:  9527:14679321341313
  2.1.1 如果没有过重发时间,报错：请勿重发获取验证码  1*60*1000
  2.1.2 如果过了，使用上次的验证码====
 2.2 如果拿不到
  2.2.1 直接生成新的验证码  ===
3.存储redis 设置3分钟过期
4.发送短信通知客人 验证码是：9527 请在3分钟内使用
```

注:如果说用户在1分钟之后重新发送验证码,那么这里还有另一种想法,比如可以重新发送验证码然后替换之前在redis中的验证码,但是这样就会造成一个问题,用户就会收到两次验证码,不过后台存储的是最新的那个!而一旦替换存储在redis服务器中那么时效重置为3分钟!

## 3. 短信接口

短信验证，只有三大运营商具有短信发送的能力。要发送短信只有找三大运营，或者中间商。简单说就是要找第三方的短信平台。常见的有阿里云，京东智联云，乐讯通等等非常多,

我们项目中使用网建短信通：http://sms.webchinese.com.cn/Rates.shtml

注册以后查看API接口:

![image-20211030094516079](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211030094516079.png)

![image-20211030094527470](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211030094527470.png)

测试:

```xml-dtd
<!-- https://mvnrepository.com/artifact/commons-httpclient/commons-httpclient -->
<dependency>
    <groupId>commons-httpclient</groupId>
    <artifactId>commons-httpclient</artifactId>
    <version>3.1</version>
</dependency>
```

```java
package cn.itsource.basic.util;

/**
 * 短信常量类
 */
public class SmsContants {

    //用户名
    public static final String UID = "xxx";
    //秘钥
    public static final String KEY = "yyyy";

}

package cn.itsource.basic.util;

import org.apache.commons.httpclient.Header;
import org.apache.commons.httpclient.HttpClient;
import org.apache.commons.httpclient.NameValuePair;
import org.apache.commons.httpclient.methods.PostMethod;

/**
 * 短信发送工具类
 */
public class SmsUtil {

    /**
     * 发送短信
     * @param phones 手机们 a,b
     * @param content 发送内容
     * @return 返回值
     */
    public static String  sendSms(String phones,String content){
        PostMethod post = null;
        try {
            HttpClient client = new HttpClient();
            post = new PostMethod("http://utf8.api.smschinese.cn");
            post.addRequestHeader("Content-Type","application/x-www-form-urlencoded;charset=utf8");//在头文件中设置转码
            NameValuePair[] data ={ new NameValuePair("Uid", SmsContants.UID),
                    new NameValuePair("Key", SmsContants.KEY),
                    new NameValuePair("smsMob",phones),
                    new NameValuePair("smsText",content)};
            post.setRequestBody(data);

            client.executeMethod(post);
            int statusCode = post.getStatusCode();
            System.out.println("statusCode:"+statusCode); //200 404 400
            String result = new String(post.getResponseBodyAsString().getBytes("utf8"));
            return result;

        } catch (Exception e) {
            e.printStackTrace();
        }
        finally {
            if (post != null) {

                post.releaseConnection();
            }
        }
        return null;
    }

    public static void main(String[] args) {
        System.out.println(SmsUtil
                .sendSms("13330964748", "您的验证码为：8848"));
    }
}
```

