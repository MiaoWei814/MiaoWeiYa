# 笔记

## 1. 数据库三范式

范式就是规范，就是要遵守的原则。一般要遵守有三种范式

1. 1NF(1范式): 设计数据库表的列的时候，这些列不可拆分。 列的`原子性`，其实这种范式可以不用管，关系型数据库默认都满足
2. 2NF(2范式)：表中行是`唯一`，通常设计一个主键来实现
3. 3NF(3范式)： 如果一张表的数据能够通过其他表推导出来，不应该单独设计，通过外键的方式`关联查询`出来

**注意**:反3NF：正常情况来说，我们必须遵循3NF，但是有的时候我们为了增强查询效率，会设计一些冗余字段，变多表查询为单表查询。

**理解**:1范式就是说列具有原子性不能拆分了,比如状态0和1就不能再拆分了;2范式指一张表中两行数据不能完全重复;3范式说如果一张表的数据能够通过其他表得出那么此时就要通过关联来获取,对字段的冗余部分进行剔除!

## 2. 短信验证码发送流程

![image-20211030093112116](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211030093112116.png)

​	**流程**:用户发送验证码,首先从通过手机号和业务绑定一个key,然后从Redis缓存中获取,如果获取到那么此时我们就对value进行拆分,获取我们设置的时间戳,然后我们就判断这个时间戳跟当前时间戳是否相差1分钟,也就是说判断用户是否存在1分钟内连续发送,如果存在连续发送那么就抛出异常非法信息,如果超过一分钟,那么并且此时我们是可以获取到的,那么就说明是在3分钟之内的,可能因为网络延迟等原因用户没有及时的收到短信,所以避免重复发送造成验证码不一致,所以这里就直接重置验证码的时间为3分钟,注意此时的value的时间戳也要得到更新,因为如果不更新下一次用户又重发那么获取value很明显已经过来时间戳那么又要重置3分钟;下一步告知用户验证码已发送,然后回到我们刚刚那个点如果在Redis获取验证码不存在那么就直接发送验证码然后存于Redis缓存,注意要先执行发送再执行放入缓存中,因为可能出现手机号发送失败,而造成验证码存于缓存中!

```bash
1.校验
 1.1 手机号不能为空
 1.2 手机号是否被注册 查询t_user表
2.判断验证码是否有效（3分钟），从redis中是否能拿到 key： business_register:15982495855
 2.1 如果拿到了 需要判断是否过了1分钟重发时间      value:  9527:14679321341313
  2.1.1 如果没有过重发时间,报错：请勿重发获取验证码  1*60*1000
  2.1.2 如果过了，使用上次的验证码====
 2.2 如果拿不到
  2.2.1 直接生成新的验证码  ===
3.存储redis 设置3分钟过期
4.发送短信通知客人 验证码是：9527 请在3分钟内使用
```

注:如果说用户在1分钟之后重新发送验证码,那么这里还有另一种想法,比如可以重新发送验证码然后替换之前在redis中的验证码,但是这样就会造成一个问题,用户就会收到两次验证码,不过后台存储的是最新的那个!而一旦替换存储在redis服务器中那么时效重置为3分钟!

## 3. 短信接口

短信验证，只有三大运营商具有短信发送的能力。要发送短信只有找三大运营，或者中间商。简单说就是要找第三方的短信平台。常见的有阿里云，京东智联云，乐讯通等等非常多,

我们项目中使用网建短信通：http://sms.webchinese.com.cn/Rates.shtml

注册以后查看API接口:

![image-20211030094516079](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211030094516079.png)

![image-20211030094527470](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211030094527470.png)

测试:

```xml-dtd
<!-- https://mvnrepository.com/artifact/commons-httpclient/commons-httpclient -->
<dependency>
    <groupId>commons-httpclient</groupId>
    <artifactId>commons-httpclient</artifactId>
    <version>3.1</version>
</dependency>
```

```java
package cn.itsource.basic.util;

/**
 * 短信常量类
 */
public class SmsContants {

    //用户名
    public static final String UID = "xxx";
    //秘钥
    public static final String KEY = "yyyy";

}

package cn.itsource.basic.util;

import org.apache.commons.httpclient.Header;
import org.apache.commons.httpclient.HttpClient;
import org.apache.commons.httpclient.NameValuePair;
import org.apache.commons.httpclient.methods.PostMethod;

/**
 * 短信发送工具类
 */
public class SmsUtil {

    /**
     * 发送短信
     * @param phones 手机们 a,b
     * @param content 发送内容
     * @return 返回值
     */
    public static String  sendSms(String phones,String content){
        PostMethod post = null;
        try {
            HttpClient client = new HttpClient();
            post = new PostMethod("http://utf8.api.smschinese.cn");
            post.addRequestHeader("Content-Type","application/x-www-form-urlencoded;charset=utf8");//在头文件中设置转码
            NameValuePair[] data ={ new NameValuePair("Uid", SmsContants.UID),
                    new NameValuePair("Key", SmsContants.KEY),
                    new NameValuePair("smsMob",phones),
                    new NameValuePair("smsText",content)};
            post.setRequestBody(data);

            client.executeMethod(post);
            int statusCode = post.getStatusCode();
            System.out.println("statusCode:"+statusCode); //200 404 400
            String result = new String(post.getResponseBodyAsString().getBytes("utf8"));
            return result;

        } catch (Exception e) {
            e.printStackTrace();
        }
        finally {
            if (post != null) {

                post.releaseConnection();
            }
        }
        return null;
    }

    public static void main(String[] args) {
        System.out.println(SmsUtil
                .sendSms("13330964748", "您的验证码为：8848"));
    }
}
```

> 其实发短信流程不复杂,第一步:通过点击链接进行注册,第二步通过注册我们有5条免费的短信和一个APIKey,第三步:根据官方示例copy过来进行修改,就可以发送!

## 4.token

**引入**:我们思考一下之前有状态的登录方案是什么?

`session`-登录之后要把登录状态保持下来,就用到tomcat的会话跟踪技术;

session往往跟Cokkie一起搭配使用,比较依赖于cookie里面的jessionid;

![image-20211101144519464](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211101144519464.png)

**理解**:用户访问网站,如果是第一次登录那么就会创建一个cookie并将服务器创建好的session信息通过一个jessionid进行写入并进行保存到客户端的浏览器总,下一次访问的时候就可以携带cookie中的jessionID到服务器端查找session进而判断是否存在或有效,来决定是否登录!

**注意:**cookie是服务器端创建然后保存到浏览器的,session是一种会话技术!

**缺点:**

1. 随着项目不断演进,存放在服务器端的session就会变得庞大,占用一定的资源,服务器性能降低
2. cookie+session不支持APP环境,因为APP里面压根就没有cookie
3. cookie是存储在客户端,安全性较低,若清除cookie那么登录信息也就没有了!

> 解决方案:无状态方案-token方案

这是一种完全抛弃了session的方案,我们可以使用redis缓存机制来实现这个方案,因为redis缓存是一款高性能、高可用的缓存中间件!

**流程:**token其实就是由UUID进行生成的字符串,我们通常设置30分钟就到期来保持用户的登录信息,然后前端每次发起请求都带上token,后端拦截器进行判断是否存在token

这种方案与session方案的**好处**就在于:session是存放在服务器端,会造成服务器内存资源的占用较大,效率较低,影响服务器性能!而token使用的字符串的形式在单独的服务中进行存储,这种不仅提高了效率并且后面项目分裂为分布式集群的形式那么这种方案依然有效!而session的话就会变得不太友好!

### 4.1 浏览器存储技术

之前我们都知道浏览器进行存储的有`Cookie`;

**好处:**设置有效期,降低服务器压力

**缺点:**有大小限制,并且是存储在客户端不安全!

其实还有另外两种存储技术:`sessionStorage`和`localStorage`

sessionStorage:存放的数据只在当前窗口有效

localStorage:持久化存储。只要不删除，在当前浏览器永远有效

这是DEMO代码:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script type="text/javascript">
        //sessionStorage 会话存储，当前窗口有效
        //localStorage 持久化存储，永远有效，只要不删除
        // function add() {
        //
        //     sessionStorage.setItem("user","{'name':'zs','age':18}")
        // }
        // function del() {
        //     sessionStorage.removeItem("user")
        // }
        // function update() {
        //     sessionStorage.setItem("user","{'name':'ls','age':18}")
        // }
        // function get() {
        //     alert(sessionStorage.getItem("user"));
        // }
        function add() {

            localStorage.setItem("user","{'name':'zs','age':18}")
        }
        function del() {
            localStorage.removeItem("user")
        }
        function update() {
            localStorage.setItem("user","{'name':'ls','age':18}")
        }
        function get() {
            alert(localStorage.getItem("user"));
        }
    </script>
</head>
<body>
  <input type="button" value="add" onclick="add()">
  <input type="button" value="del" onclick="del()">
  <input type="button" value="update" onclick="update()">
  <input type="button" value="get" onclick="get()">

</body>
</html>
```

客户端在这里:

![image-20211101151810061](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211101151810061.png)



**注意:**

1. sessionStorage只是在单个网页窗口有效,一旦关闭则自动清除
2. LocalStoage是存储在浏览器本地,也就是换个窗口都是依然存在的,浏览器关闭然后再打开也是存在的!

3. 以上两种存储都是基于当前网站存储,所以可以看见对应的地址,如果换个网站比如现在打开京东网页,那么我们在当前项目保存的信息就不存在!

### 4.2 拦截器

怎么让token每次都携带过去:

1）登录成功后把token存放到浏览器，如果是移动端写文件。  localStorage

2）每次对后端的请求，都从浏览器获取token并且携带过去,对后端请求都是使用axios，使用axios前置拦截器给请求追加一个请求头

**核心:**其拦截器的核心,后端:一个拦截器获取token进行判断是否有效,前端三个拦截器:前置、后置、静态资源拦截器;

这里直接贴代码:

后端:

```java
@Configuration
public class WebConfigurer implements WebMvcConfigurer {
    @Autowired
    private LoginInterceptor loginInterceptor;
    /**
     * 添加拦截器
     *
     * @param registry 注册表
     */
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(loginInterceptor)
                //拦截所有请求
                .addPathPatterns("/**")
                //放行地址
                    //文件上传
                .excludePathPatterns("/fastDfs/**")
                    //用户门户网站端发起验证码、注册、登录
                .excludePathPatterns("/user/**")
                    //管理端店铺入驻、管理员登录
                .excludePathPatterns("/shop/**");
    }
}
@Component
public class LoginInterceptor implements HandlerInterceptor {
    @Autowired
    private RedisUtil redisUtil;
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        //获取前端请求中携带的token
        String token = request.getHeader("token");
        //为空则拦截,不为空则判断是否存在token
        if (CharSequenceUtil.isNotEmpty(token)) {
            //从缓存中是否能拿得到
            Object isExist = redisUtil.get(token);
            if (!Objects.isNull(isExist)) {
                //如果缓存中存在那么此时就重置失效时间
                redisUtil.expire(token, 60 * 30);
                return true;
            }
        }
        // TODO: 2021/10/30 拦截做处理
        throw new AccountExpiredException("您当前账户已过期,请重新登录!");
    }
}
```

前端:

```javascript
//前置拦截器,每次发起请求都会首先从这里开始拦截
//为了后端校验是否已经登录，只要用axios的请求都要携带token
//这个算前置拦截器
axios.interceptors.request.use(config => {
    //从本地存储空间获取这个token然后添加到请求中的headers里面给后端!
    let token = localStorage.getItem("token");
    if (token) {
        config.headers["token"] = token;  
    }
    return config;
}, error => {
    Promise.reject(error)
});

//这个是前端后置拦截器,在获取每一个请求的响应走这个拦截器
axios.interceptors.response.use(config=>{
    //如果在前置拦截器中没有token,后端就会拦截并返回这个状态
    if (config.data.code === 403) {
        localStorage.removeItem("token");
        localStorage.removeItem("logininfo");
        //跳转到指定路径path
        router.push({ path: '/login' });
    }
    return config;
},error => {
    Promise.reject(error)
})

// 静态资源拦截器,拦截页面请求path比如登录或者店铺注册就不拦截,其他访问静态资源如:path判断是不是有token,有则不拦截
//对页面跳转进行拦截!
router.beforeEach((to, from, next) => {
  //NProgress.start();
  if (to.path === '/login' || to.path==='/shopRegister') {
    localStorage.removeItem("token");
    localStorage.removeItem("logininfo");
    next(); //放行
    return; //不往下执行

  }
  let user = JSON.parse(localStorage.getItem('logininfo'));
  if (!user) {
    next({ path: '/login' })
  } else {
    next()
  }
})
```

> 拦截器的话也不复杂,就是每次请求前和响应后进行一个拦截,然后进行相应的处理!

访问资源流程分析:

![image-20211101152835590](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211101152835590.png)

**理解**:用户请求axios异步请求,首先会经过前置拦截器,从本地存储技术中拿取token并设置到请求头信息中,然后请求到后端,此时后端就有一个后端拦截器,会对请求信息中的token判断是否能从redis中获取到,如果可以拿到那么设置刷新过期时间30分钟,并放行请求,如果获取不到那么就直接拦截下来并返回给前端报没有权限的异常信息,然后前端返回请求就会经过一个后置拦截器,分析返回的请求中是否是后端拦截报的异常,如果是那么就定位跳转到指定登录界面,如果不是照常放行!

## 5.Saas平台设计

SaaS提供商为企业搭建信息化所需要的所有网络基础设施及软件、硬件运作平台，并负责所有前期的实施、后期的维护等一系列服务，企业无需购买软硬件、建设机房、招聘IT人员，即可通过互联网使用信息系统。就像打开自来水龙头就能用水一样，企业根据实际需要，从SaaS提供商租赁软件服务。

![image-20211125111234693](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211125111234693.png)

传统软件模式:

开发公司开发的产品给客户安装, 然后客户需要自己安装服务器等等, 如果有问题那么就需要开发公司去专门派发人员去维护!

缺点:人员成本高!维护麻烦!



SaaS模式带来的问题：

1. 软件面向的是多个客户企业的数据,数据量变大，比如达到上百万，千万数据：考虑做集群，分库，分表

2. 不同客户企业的数据如何隔离

3. 不同客户企业权限如何处理：需要考虑企业，套餐，角色，权限，资源

### 5.1 Saas平台数据隔离

```
如何把不同的公司做数据库区分?
```

1. 独立数据库

   即一个租户一个数据库，这种方案的用户数据隔离级别最高，安全性最好，但成本较高

   1. 优点
      为不同的租户提供独立的数据库，有助于简化数据模型的扩展设计，满足不同租户的独特需求；如果出现故障，恢复数据比较简单。

   2. 缺点
      增多了数据库的安装数量，随之带来维护成本和购置成本的增加。
      这种方案与传统的一个客户、一套数据、一套部署类似，差别只在于软件统一部署在运营商那里。如果面对的是银行、医院等需要非常高数据隔离级别的租户，可以选择这种模式，提高租用的定价。如果定价较低，产品走低价路线，这种方案一般对运营商来说是无法承受的。

   ![image-20211125111656133](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211125111656133.png)

2. 共享数据库,隔离数据库架构

   这是第二种方案，即多个或所有租户共享Database，但是每个租户一个Schema（也可叫做一个user）。

      通过Schema做区分user
   
   1. 优点
      为安全性要求较高的租户提供了一定程度的逻辑数据隔离，并不是完全隔离；每个数据库可支持更多的租户数量。
   
   2. 缺点
      如果出现故障，数据恢复比较困难，因为恢复数据库将牵涉到其他租户的数据；
      如果需要跨租户统计数据，存在一定困难。
   
   ![image-20211125111739901](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211125111739901.png)

3.共享数据库，共享数据架构，使用外键区分数据

​	这是第三种方案，即租户共享同一个Database、同一个Schema，共享表，但在表中增加TenantID多租户的数据字段。这是共享程度最高、隔离级别最低的模式。

用外键区分数据库,都在一个数据库通过不同的表的外键来关联查找属于客户自己的数据;缺点：数据隔离不是很彻底

	1. 优点
		三种方案比较，第三种方案的维护和购置成本最低，允许每个数据库支持的租户数量最多。

2. 缺点：
   隔离级别最低，安全性最低，需要在设计开发时加大对安全的开发量；
   数据备份和恢复最困难，需要逐表逐条备份和还原。
   如果希望以最少的服务器为最多的租户提供服务，并且租户接受牺牲隔离级别换取降低成本，这种方案最适合。

![image-20211125111923006](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211125111923006.png)

查询不同的租户的数据的时候，需要增加条件：where tenant_id = 登录的租户ID



4. 共亨数据库，共亨数据架构，不同的机构使用不同的表

   不同的机构使用不同的表,表使用后缀进行区分如：t_employee_ali ， t_employee_tx

   ![image-20211125111957356](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211125111957356.png)

   使用mybatis拦截器来修改表名,   好处: 用占位符来替换表名 但是这样呢表也会随之增多

## 6.优化的方案

**从后端角度来说**:
	1. 查询较多可以做redis
		1.1 实时性要求不高:可以写一个定时任务如:一个小时就从数据库查询然后更新redis,而前端查询就可以直接从redis查询即可!
		1.2 实时性要求高:保证redis和数据库的一致性那么可以使用某些框架去监听数据库日志文件的变化然后去更新redis,从而达到数据的一致性!或者每次修改数据库就立即删除、更新缓存！
	2.如果前端发起一个请求,在这一个请求里要查询各种数据然后综合返回给前端,那么这种我们就可以使用jdk1.8新特性新开一个线程,达到一个异步的作用,然后最终合并在一起再返回给客户端,如实现Callable接口

**从前端角度来说**:

1. 我们可以使用js压缩技术将js进行压缩,然后从后台服务中返回!这样就减少网络传输中静态资源大小
2. 由于每次加载前端都是首先从后台获取js等然后加载到前端页面,然后再发送异步请求到后台服务,那么这种呢我们可以把静态资源：html,js,css部署到Nginx , 减轻后台服务的压力，实现动静分离
3.当然每次都从Nginx中获取静态资源也是属于一种网络开销的一种方式,而用户在不同地区访问这个页面那么就会在网络上走各种网络服务商到达Nginx然后返回,这样的方式比较缓慢,所以可以把静态资源放到专门的CDN缓存服务器，浏览器直接从CDN获取静态资源 ， CDN可以根据地区就近选择
4. 还有一种方式就是将请求的数据渲染到一个HTML模板上,然后每次请求都是访问这个静态页面,那么这种每次加载都是加载这个html,效率也得到了提高!
5. 滚动加载，鼠标往下滚动才去会去发请求加载！

## 7.BitStatus(位状态)

![image-20211201192532483](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211201192532483.png)

位状态呢指在一个表中有多种状态,而且随着项目的发展这些状态要随之增加,那么按照我们传统的方式就用字段来表达,比如邮箱绑定就需要一个字段,而手机绑定也需要一个字段表示,而且这些往往只是用于表示是还是否的状态,那么我们可以采用一个位状态的方式!



如Long的二进制表示为8个0,那么每个状态占一个坑位,比如邮箱绑定就是第一个坑位,然后手机绑定占第二个坑位,那么如果用户绑定了手机认证那么就执行位操作,就好比是加法,然后计算得出新的二进制然后放进数据库,如果用户取消手机绑定那么就直接减去该状态所对应的二进制,通常这种状态都有一个约定成俗的规定,如:邮箱绑定就对应这5,那么在执行位操作的时候就会将5换算成二进制然后进行相关的运算!

工具类:

```java
/**
 * 用户状态类，记录用户在平台使用系统中所有的状态。
 * @author nixianhua
 */
public class BitStatesUtils {
	
	/**
	 * 用户注册成功的标示,及为默认初始状态
	 */
	public final static long OP_REGISTED = 1L << 0;
	/**
	 * 是否已激活（认证手机或认证邮箱）。
	 */
	public final static long OP_ACTIVED = 1L << 1;
	/**
	 * 是否锁定（未锁定则没有该状态），安全监测程序/后台对用户的锁定操作。
	 */
	public final static long OP_LOCKED = 1L << 2;
	/**
	 * 是否手机认证
	 */
	public final static long OP_AUTHED_PHONE = 1L << 3;
	/**
	 * 是否邮箱认证
	 */
	public final static long OP_AUTHED_EMAIL = 1L << 4;
	
	/**
	 * 是否完善个人信息
	 */
	public final static long OP_SAVE_BASIC_INFO = 1L << 5;
	
	/**
	 * 是否正在进行实名认证
	 */
	public final static long OP_IDENTITY_AUTHING = 1L << 6;
	
	/**
	 * 是否完成实名认证
	 */
	public final static long OP_IDENTITY_AUTHED = 1L << 7;
	/**
	 * 是否初始化支付密码
	 */
	public final static long OP_INIT_PAY_PASSWORD = 1L << 8;
	
	/**
	 * @param states 用户当前状态值
	 * @param value  需要判断状态值
	 * @return 是否存在
	 */
	public static boolean hasState(long states,long value){
		return (states & value) == value;
	}
	
	/**
	 * @param states 已有状态值
	 * @param value  需要添加状态值
	 * @return 新的状态值
	 */
	public static long addState(long states,long value){
		if(hasState(states, value)){
			return states;
		}
		return (states | value);
	}
	
	/**
	 * @param states 已有状态值
	 * @param value  需要删除状态值
	 * @return 新的状态值
	 */
	public static long removeState(long states,long value){
		if(!hasState(states, value)){
			return states;
		}
		return states ^ value;
	}
	
}
```

