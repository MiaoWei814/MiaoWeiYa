# 笔记

## 1. 数据库三范式

范式就是规范，就是要遵守的原则。一般要遵守有三种范式

1. 1NF(1范式): 设计数据库表的列的时候，这些列不可拆分。 列的`原子性`，其实这种范式可以不用管，关系型数据库默认都满足
2. 2NF(2范式)：表中行是`唯一`，通常设计一个主键来实现
3. 3NF(3范式)： 如果一张表的数据能够通过其他表推导出来，不应该单独设计，通过外键的方式`关联查询`出来

**注意**:反3NF：正常情况来说，我们必须遵循3NF，但是有的时候我们为了增强查询效率，会设计一些冗余字段，变多表查询为单表查询。

**理解**:1范式就是说列具有原子性不能拆分了,比如状态0和1就不能再拆分了;2范式指一张表中两行数据不能完全重复;3范式说如果一张表的数据能够通过其他表得出那么此时就要通过关联来获取,对字段的冗余部分进行剔除!

## 2. 短信验证码发送流程

![image-20211030093112116](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211030093112116.png)

​	**流程**:用户发送验证码,首先从通过手机号和业务绑定一个key,然后从Redis缓存中获取,如果获取到那么此时我们就对value进行拆分,获取我们设置的时间戳,然后我们就判断这个时间戳跟当前时间戳是否相差1分钟,也就是说判断用户是否存在1分钟内连续发送,如果存在连续发送那么就抛出异常非法信息,如果超过一分钟,那么并且此时我们是可以获取到的,那么就说明是在3分钟之内的,可能因为网络延迟等原因用户没有及时的收到短信,所以避免重复发送造成验证码不一致,所以这里就直接重置验证码的时间为3分钟,注意此时的value的时间戳也要得到更新,因为如果不更新下一次用户又重发那么获取value很明显已经过来时间戳那么又要重置3分钟;下一步告知用户验证码已发送,然后回到我们刚刚那个点如果在Redis获取验证码不存在那么就直接发送验证码然后存于Redis缓存,注意要先执行发送再执行放入缓存中,因为可能出现手机号发送失败,而造成验证码存于缓存中!

```bash
1.校验
 1.1 手机号不能为空
 1.2 手机号是否被注册 查询t_user表
2.判断验证码是否有效（3分钟），从redis中是否能拿到 key： business_register:15982495855
 2.1 如果拿到了 需要判断是否过了1分钟重发时间      value:  9527:14679321341313
  2.1.1 如果没有过重发时间,报错：请勿重发获取验证码  1*60*1000
  2.1.2 如果过了，使用上次的验证码====
 2.2 如果拿不到
  2.2.1 直接生成新的验证码  ===
3.存储redis 设置3分钟过期
4.发送短信通知客人 验证码是：9527 请在3分钟内使用
```

注:如果说用户在1分钟之后重新发送验证码,那么这里还有另一种想法,比如可以重新发送验证码然后替换之前在redis中的验证码,但是这样就会造成一个问题,用户就会收到两次验证码,不过后台存储的是最新的那个!而一旦替换存储在redis服务器中那么时效重置为3分钟!

## 3. 短信接口

短信验证，只有三大运营商具有短信发送的能力。要发送短信只有找三大运营，或者中间商。简单说就是要找第三方的短信平台。常见的有阿里云，京东智联云，乐讯通等等非常多,

我们项目中使用网建短信通：http://sms.webchinese.com.cn/Rates.shtml

注册以后查看API接口:

![image-20211030094516079](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211030094516079.png)

![image-20211030094527470](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211030094527470.png)

测试:

```xml-dtd
<!-- https://mvnrepository.com/artifact/commons-httpclient/commons-httpclient -->
<dependency>
    <groupId>commons-httpclient</groupId>
    <artifactId>commons-httpclient</artifactId>
    <version>3.1</version>
</dependency>
```

```java
package cn.itsource.basic.util;

/**
 * 短信常量类
 */
public class SmsContants {

    //用户名
    public static final String UID = "xxx";
    //秘钥
    public static final String KEY = "yyyy";

}

package cn.itsource.basic.util;

import org.apache.commons.httpclient.Header;
import org.apache.commons.httpclient.HttpClient;
import org.apache.commons.httpclient.NameValuePair;
import org.apache.commons.httpclient.methods.PostMethod;

/**
 * 短信发送工具类
 */
public class SmsUtil {

    /**
     * 发送短信
     * @param phones 手机们 a,b
     * @param content 发送内容
     * @return 返回值
     */
    public static String  sendSms(String phones,String content){
        PostMethod post = null;
        try {
            HttpClient client = new HttpClient();
            post = new PostMethod("http://utf8.api.smschinese.cn");
            post.addRequestHeader("Content-Type","application/x-www-form-urlencoded;charset=utf8");//在头文件中设置转码
            NameValuePair[] data ={ new NameValuePair("Uid", SmsContants.UID),
                    new NameValuePair("Key", SmsContants.KEY),
                    new NameValuePair("smsMob",phones),
                    new NameValuePair("smsText",content)};
            post.setRequestBody(data);

            client.executeMethod(post);
            int statusCode = post.getStatusCode();
            System.out.println("statusCode:"+statusCode); //200 404 400
            String result = new String(post.getResponseBodyAsString().getBytes("utf8"));
            return result;

        } catch (Exception e) {
            e.printStackTrace();
        }
        finally {
            if (post != null) {

                post.releaseConnection();
            }
        }
        return null;
    }

    public static void main(String[] args) {
        System.out.println(SmsUtil
                .sendSms("13330964748", "您的验证码为：8848"));
    }
}
```

> 其实发短信流程不复杂,第一步:通过点击链接进行注册,第二步通过注册我们有5条免费的短信和一个APIKey,第三步:根据官方示例copy过来进行修改,就可以发送!

## 4.token

**引入**:我们思考一下之前有状态的登录方案是什么?

`session`-登录之后要把登录状态保持下来,就用到tomcat的会话跟踪技术;

session往往跟Cokkie一起搭配使用,比较依赖于cookie里面的jessionid;

![image-20211101144519464](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211101144519464.png)

**理解**:用户访问网站,如果是第一次登录那么就会创建一个cookie并将服务器创建好的session信息通过一个jessionid进行写入并进行保存到客户端的浏览器总,下一次访问的时候就可以携带cookie中的jessionID到服务器端查找session进而判断是否存在或有效,来决定是否登录!

**注意:**cookie是服务器端创建然后保存到浏览器的,session是一种会话技术!

**缺点:**

1. 随着项目不断演进,存放在服务器端的session就会变得庞大,占用一定的资源,服务器性能降低
2. cookie+session不支持APP环境,因为APP里面压根就没有cookie
3. cookie是存储在客户端,安全性较低,若清除cookie那么登录信息也就没有了!

> 解决方案:无状态方案-token方案

这是一种完全抛弃了session的方案,我们可以使用redis缓存机制来实现这个方案,因为redis缓存是一款高性能、高可用的缓存中间件!

**流程:**token其实就是由UUID进行生成的字符串,我们通常设置30分钟就到期来保持用户的登录信息,然后前端每次发起请求都带上token,后端拦截器进行判断是否存在token

这种方案与session方案的**好处**就在于:session是存放在服务器端,会造成服务器内存资源的占用较大,效率较低,影响服务器性能!而token使用的字符串的形式在单独的服务中进行存储,这种不仅提高了效率并且后面项目分裂为分布式集群的形式那么这种方案依然有效!而session的话就会变得不太友好!

### 4.1 浏览器存储技术

之前我们都知道浏览器进行存储的有`Cookie`;

**好处:**设置有效期,降低服务器压力

**缺点:**有大小限制,并且是存储在客户端不安全!

其实还有另外两种存储技术:`sessionStorage`和`localStorage`

sessionStorage:存放的数据只在当前窗口有效

localStorage:持久化存储。只要不删除，在当前浏览器永远有效

这是DEMO代码:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script type="text/javascript">
        //sessionStorage 会话存储，当前窗口有效
        //localStorage 持久化存储，永远有效，只要不删除
        // function add() {
        //
        //     sessionStorage.setItem("user","{'name':'zs','age':18}")
        // }
        // function del() {
        //     sessionStorage.removeItem("user")
        // }
        // function update() {
        //     sessionStorage.setItem("user","{'name':'ls','age':18}")
        // }
        // function get() {
        //     alert(sessionStorage.getItem("user"));
        // }
        function add() {

            localStorage.setItem("user","{'name':'zs','age':18}")
        }
        function del() {
            localStorage.removeItem("user")
        }
        function update() {
            localStorage.setItem("user","{'name':'ls','age':18}")
        }
        function get() {
            alert(localStorage.getItem("user"));
        }
    </script>
</head>
<body>
  <input type="button" value="add" onclick="add()">
  <input type="button" value="del" onclick="del()">
  <input type="button" value="update" onclick="update()">
  <input type="button" value="get" onclick="get()">

</body>
</html>
```

客户端在这里:

![image-20211101151810061](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211101151810061.png)



**注意:**

1. sessionStorage只是在单个网页窗口有效,一旦关闭则自动清除
2. LocalStoage是存储在浏览器本地,也就是换个窗口都是依然存在的,浏览器关闭然后再打开也是存在的!

3. 以上两种存储都是基于当前网站存储,所以可以看见对应的地址,如果换个网站比如现在打开京东网页,那么我们在当前项目保存的信息就不存在!

### 4.2 拦截器

怎么让token每次都携带过去:

1）登录成功后把token存放到浏览器，如果是移动端写文件。  localStorage

2）每次对后端的请求，都从浏览器获取token并且携带过去,对后端请求都是使用axios，使用axios前置拦截器给请求追加一个请求头

**核心:**其拦截器的核心,后端:一个拦截器获取token进行判断是否有效,前端三个拦截器:前置、后置、静态资源拦截器;

这里直接贴代码:

后端:

```java
@Configuration
public class WebConfigurer implements WebMvcConfigurer {
    @Autowired
    private LoginInterceptor loginInterceptor;
    /**
     * 添加拦截器
     *
     * @param registry 注册表
     */
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(loginInterceptor)
                //拦截所有请求
                .addPathPatterns("/**")
                //放行地址
                    //文件上传
                .excludePathPatterns("/fastDfs/**")
                    //用户门户网站端发起验证码、注册、登录
                .excludePathPatterns("/user/**")
                    //管理端店铺入驻、管理员登录
                .excludePathPatterns("/shop/**");
    }
}
@Component
public class LoginInterceptor implements HandlerInterceptor {
    @Autowired
    private RedisUtil redisUtil;
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        //获取前端请求中携带的token
        String token = request.getHeader("token");
        //为空则拦截,不为空则判断是否存在token
        if (CharSequenceUtil.isNotEmpty(token)) {
            //从缓存中是否能拿得到
            Object isExist = redisUtil.get(token);
            if (!Objects.isNull(isExist)) {
                //如果缓存中存在那么此时就重置失效时间
                redisUtil.expire(token, 60 * 30);
                return true;
            }
        }
        // TODO: 2021/10/30 拦截做处理
        throw new AccountExpiredException("您当前账户已过期,请重新登录!");
    }
}
```

前端:

```javascript
//前置拦截器,每次发起请求都会首先从这里开始拦截
//为了后端校验是否已经登录，只要用axios的请求都要携带token
//这个算前置拦截器
axios.interceptors.request.use(config => {
    //从本地存储空间获取这个token然后添加到请求中的headers里面给后端!
    let token = localStorage.getItem("token");
    if (token) {
        config.headers["token"] = token;  
    }
    return config;
}, error => {
    Promise.reject(error)
});

//这个是前端后置拦截器,在获取每一个请求的响应走这个拦截器
axios.interceptors.response.use(config=>{
    //如果在前置拦截器中没有token,后端就会拦截并返回这个状态
    if (config.data.code === 403) {
        localStorage.removeItem("token");
        localStorage.removeItem("logininfo");
        //跳转到指定路径path
        router.push({ path: '/login' });
    }
    return config;
},error => {
    Promise.reject(error)
})

// 静态资源拦截器,拦截页面请求path比如登录或者店铺注册就不拦截,其他访问静态资源如:path判断是不是有token,有则不拦截
//对页面跳转进行拦截!
router.beforeEach((to, from, next) => {
  //NProgress.start();
  if (to.path === '/login' || to.path==='/shopRegister') {
    localStorage.removeItem("token");
    localStorage.removeItem("logininfo");
    next(); //放行
    return; //不往下执行

  }
  let user = JSON.parse(localStorage.getItem('logininfo'));
  if (!user) {
    next({ path: '/login' })
  } else {
    next()
  }
})
```

> 拦截器的话也不复杂,就是每次请求前和响应后进行一个拦截,然后进行相应的处理!

访问资源流程分析:

![image-20211101152835590](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211101152835590.png)

**理解**:用户请求axios异步请求,首先会经过前置拦截器,从本地存储技术中拿取token并设置到请求头信息中,然后请求到后端,此时后端就有一个后端拦截器,会对请求信息中的token判断是否能从redis中获取到,如果可以拿到那么设置刷新过期时间30分钟,并放行请求,如果获取不到那么就直接拦截下来并返回给前端报没有权限的异常信息,然后前端返回请求就会经过一个后置拦截器,分析返回的请求中是否是后端拦截报的异常,如果是那么就定位跳转到指定登录界面,如果不是照常放行!

## 5.Saas平台设计

SaaS提供商为企业搭建信息化所需要的所有网络基础设施及软件、硬件运作平台，并负责所有前期的实施、后期的维护等一系列服务，企业无需购买软硬件、建设机房、招聘IT人员，即可通过互联网使用信息系统。就像打开自来水龙头就能用水一样，企业根据实际需要，从SaaS提供商租赁软件服务。

![image-20211125111234693](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211125111234693.png)

传统软件模式:

开发公司开发的产品给客户安装, 然后客户需要自己安装服务器等等, 如果有问题那么就需要开发公司去专门派发人员去维护!

缺点:人员成本高!维护麻烦!



SaaS模式带来的问题：

1. 软件面向的是多个客户企业的数据,数据量变大，比如达到上百万，千万数据：考虑做集群，分库，分表

2. 不同客户企业的数据如何隔离

3. 不同客户企业权限如何处理：需要考虑企业，套餐，角色，权限，资源

### 5.1 Saas平台数据隔离

```
如何把不同的公司做数据库区分?
```

1. 独立数据库

   即一个租户一个数据库，这种方案的用户数据隔离级别最高，安全性最好，但成本较高

   1. 优点
      为不同的租户提供独立的数据库，有助于简化数据模型的扩展设计，满足不同租户的独特需求；如果出现故障，恢复数据比较简单。

   2. 缺点
      增多了数据库的安装数量，随之带来维护成本和购置成本的增加。
      这种方案与传统的一个客户、一套数据、一套部署类似，差别只在于软件统一部署在运营商那里。如果面对的是银行、医院等需要非常高数据隔离级别的租户，可以选择这种模式，提高租用的定价。如果定价较低，产品走低价路线，这种方案一般对运营商来说是无法承受的。

   ![image-20211125111656133](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211125111656133.png)

2. 共享数据库,隔离数据库架构

   这是第二种方案，即多个或所有租户共享Database，但是每个租户一个Schema（也可叫做一个user）。

      通过Schema做区分user
   
   1. 优点
      为安全性要求较高的租户提供了一定程度的逻辑数据隔离，并不是完全隔离；每个数据库可支持更多的租户数量。
   
   2. 缺点
      如果出现故障，数据恢复比较困难，因为恢复数据库将牵涉到其他租户的数据；
      如果需要跨租户统计数据，存在一定困难。
   
   ![image-20211125111739901](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211125111739901.png)

3.共享数据库，共享数据架构，使用外键区分数据

​	这是第三种方案，即租户共享同一个Database、同一个Schema，共享表，但在表中增加TenantID多租户的数据字段。这是共享程度最高、隔离级别最低的模式。

用外键区分数据库,都在一个数据库通过不同的表的外键来关联查找属于客户自己的数据;缺点：数据隔离不是很彻底

	1. 优点
		三种方案比较，第三种方案的维护和购置成本最低，允许每个数据库支持的租户数量最多。

2. 缺点：
   隔离级别最低，安全性最低，需要在设计开发时加大对安全的开发量；
   数据备份和恢复最困难，需要逐表逐条备份和还原。
   如果希望以最少的服务器为最多的租户提供服务，并且租户接受牺牲隔离级别换取降低成本，这种方案最适合。

![image-20211125111923006](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211125111923006.png)

查询不同的租户的数据的时候，需要增加条件：where tenant_id = 登录的租户ID



4. 共亨数据库，共亨数据架构，不同的机构使用不同的表

   不同的机构使用不同的表,表使用后缀进行区分如：t_employee_ali ， t_employee_tx

   ![image-20211125111957356](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211125111957356.png)

   使用mybatis拦截器来修改表名,   好处: 用占位符来替换表名 但是这样呢表也会随之增多

## 6.优化的方案

**从后端角度来说**:
	1. 查询较多可以做redis
		1.1 实时性要求不高:可以写一个定时任务如:一个小时就从数据库查询然后更新redis,而前端查询就可以直接从redis查询即可!
		1.2 实时性要求高:保证redis和数据库的一致性那么可以使用某些框架去监听数据库日志文件的变化然后去更新redis,从而达到数据的一致性!或者每次修改数据库就立即删除、更新缓存！
	2.如果前端发起一个请求,在这一个请求里要查询各种数据然后综合返回给前端,那么这种我们就可以使用jdk1.8新特性新开一个线程,达到一个异步的作用,然后最终合并在一起再返回给客户端,如实现Callable接口

**从前端角度来说**:

1. 我们可以使用js压缩技术将js进行压缩,然后从后台服务中返回!这样就减少网络传输中静态资源大小
2. 由于每次加载前端都是首先从后台获取js等然后加载到前端页面,然后再发送异步请求到后台服务,那么这种呢我们可以把静态资源：html,js,css部署到Nginx , 减轻后台服务的压力，实现动静分离
3.当然每次都从Nginx中获取静态资源也是属于一种网络开销的一种方式,而用户在不同地区访问这个页面那么就会在网络上走各种网络服务商到达Nginx然后返回,这样的方式比较缓慢,所以可以把静态资源放到专门的CDN缓存服务器，浏览器直接从CDN获取静态资源 ， CDN可以根据地区就近选择
4. 还有一种方式就是将请求的数据渲染到一个HTML模板上,然后每次请求都是访问这个静态页面,那么这种每次加载都是加载这个html,效率也得到了提高!
5. 滚动加载，鼠标往下滚动才去会去发请求加载！

## 7.BitStatus(位状态)

![image-20211201192532483](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211201192532483.png)

位状态呢指在一个表中有多种状态,而且随着项目的发展这些状态要随之增加,那么按照我们传统的方式就用字段来表达,比如邮箱绑定就需要一个字段,而手机绑定也需要一个字段表示,而且这些往往只是用于表示是还是否的状态,那么我们可以采用一个位状态的方式!



如Long的二进制表示为8个0,那么每个状态占一个坑位,比如邮箱绑定就是第一个坑位,然后手机绑定占第二个坑位,那么如果用户绑定了手机认证那么就执行位操作,就好比是加法,然后计算得出新的二进制然后放进数据库,如果用户取消手机绑定那么就直接减去该状态所对应的二进制,通常这种状态都有一个约定成俗的规定,如:邮箱绑定就对应这5,那么在执行位操作的时候就会将5换算成二进制然后进行相关的运算!

工具类:

```java
/**
 * 用户状态类，记录用户在平台使用系统中所有的状态。
 * @author nixianhua
 */
public class BitStatesUtils {
	
	/**
	 * 用户注册成功的标示,及为默认初始状态
	 */
	public final static long OP_REGISTED = 1L << 0;
	/**
	 * 是否已激活（认证手机或认证邮箱）。
	 */
	public final static long OP_ACTIVED = 1L << 1;
	/**
	 * 是否锁定（未锁定则没有该状态），安全监测程序/后台对用户的锁定操作。
	 */
	public final static long OP_LOCKED = 1L << 2;
	/**
	 * 是否手机认证
	 */
	public final static long OP_AUTHED_PHONE = 1L << 3;
	/**
	 * 是否邮箱认证
	 */
	public final static long OP_AUTHED_EMAIL = 1L << 4;
	
	/**
	 * 是否完善个人信息
	 */
	public final static long OP_SAVE_BASIC_INFO = 1L << 5;
	
	/**
	 * 是否正在进行实名认证
	 */
	public final static long OP_IDENTITY_AUTHING = 1L << 6;
	
	/**
	 * 是否完成实名认证
	 */
	public final static long OP_IDENTITY_AUTHED = 1L << 7;
	/**
	 * 是否初始化支付密码
	 */
	public final static long OP_INIT_PAY_PASSWORD = 1L << 8;
	
	/**
	 * @param states 用户当前状态值
	 * @param value  需要判断状态值
	 * @return 是否存在
	 */
	public static boolean hasState(long states,long value){
		return (states & value) == value;
	}
	
	/**
	 * @param states 已有状态值
	 * @param value  需要添加状态值
	 * @return 新的状态值
	 */
	public static long addState(long states,long value){
		if(hasState(states, value)){
			return states;
		}
		return (states | value);
	}
	
	/**
	 * @param states 已有状态值
	 * @param value  需要删除状态值
	 * @return 新的状态值
	 */
	public static long removeState(long states,long value){
		if(!hasState(states, value)){
			return states;
		}
		return states ^ value;
	}
	
}
```



## 8.记录一些需求

1. 图片验证码

   ![image-20211204181657252](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211204181657252.png)

2. 短信验证码

   ![image-20211204181946721](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211204181946721.png)

## 9.Oauth2授权模式

这是介绍文章:http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html 

登录所用的协议就是Oauth2-----安全不会涉及第三方用户账号密码

OAuth 2.0定义了四种授权方式:

1. 授权码模式

   ![image-20211207160245436](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211207160245436.png)

​		授权流程:		

```
1. 用户访问客户端，后者将前者导向认证服务器
2. 用户选择是否给予客户端授权
3. 假设用户给予授权，认证服务器将用户导向客户端事先指定的"重定向URI"（redirection URI），同时附上一个授权码
4. 客户端收到授权码，附上早先的"重定向URI"，向认证服务器申请令牌。这一步是在客户端的后台的服务器上完成的，对用户不可见
5. 认证服务器核对了授权码和重定向URI，确认无误后，向客户端发送访问令牌（access token）和更新令牌（refresh token）
```

2. 简化模式

理解:简化模式（implicit grant type）不通过第三方应用程序的服务器，直接在浏览器中向认证服务器申请令牌，跳过了"授权码"这个步骤，因此得名。所有步骤在浏览器中完成，令牌对访问者是可见的，且客户端不需要认证

> 省略了授权码步骤, 在客户端同意授权以后直接往第三方服务获取token

3. 密码模式

理解:密码模式（Resource Owner Password Credentials Grant）中，`用户向客户端提供自己的用户名和密码。客户端使用这些信息，向"服务商提供商"索要授权`。

在这种模式中，用户必须把自己的密码给客户端，但是客户端不得储存密码。这通常用在用户对客户端高度信任的情况下，比如客户端是操作系统的一部分，或者由一个著名公司出品。而认证服务器只有在其他授权模式无法执行的情况下，才能考虑使用这种模式

> 用户向客户端发起登录请求, 然后第三方就会返回给客户端提供自己的账号和密码, 通过账号和密码来登录授权, 不过这个账号和密码是第三方的账号,不会去涉及客户端去保留之类的, 也就是说这个账号密码不会去在客户端做一个保存!---类似于我们在游戏授权的时候都是需要我们进行登录QQ来进行授权

4. 客户端模式

理解:客户端模式（Client Credentials Grant）指`客户端以自己的名义，而不是以用户的名义`，向"服务提供商"进行认证。严格地说，客户端模式并不属于OAuth框架所要解决的问题。在这种模式中，用户直接向客户端注册，客户端以自己的名义要求"服务提供商"提供服务，其实不存在授权问题。

> 以客户端自己的名义去往第三方获取资源, 不适合做登录, 只适合做一些自家平台的获取资源登录等等!
>
> 应用往第三方平台直接获取token,不会经过用户确认! 这种呢就不会存在授权啊这些问题!

### 9.1.JWT

jwt是一种令牌!它的出现就是为了解决在之前的使用的过程中我们每次访问资源都要通过资源服务器远程调用认证服务器进行token的校验和授权才能访问到资源。但是如果我们的`访问比较频繁`，并发比较高，那么这种权限校验方式无疑比较消耗性能。而JWT就是用来`解决远程校验令牌的问题`!



JWT:是一种轻巧的规范!这个规范允许我们使用JWT在`用户和服务器`之间传递安全可靠的信息

**理解**:使用JWT生产的Token是安全的，可以理解成就是在我们之前的Token基础上做了加密处理,实现了数据的安全传输，也实现了资源服务器对Token的自校验

特点:

1. 基于JSON，方便解析

2. 可以在令牌中定义内容，方便扩展

3. 非对称加密算法即数字签名，JWT防篡改

4. 资源服务使用JWT可以不依赖认证服务即可完成授权

---

组成部分:https://www.jianshu.com/p/99a458c62aa4

包含三部分组成:

1. 头部(header):

   ```json
   JSON格式，描述JWT的最基本的信息，如签名算法等效果如下：
   {"type":"JWT","alg":"HS256"} 这里指明了签名算法是HS256算法。在使用过程中会对该JSON进行BASE64编码如：yJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9
   ```

2. 载荷(playload):

   ```
   JSON格式，包含了需要的数据内容，也需要BASE64编码。包含三部分
   1. 标准中注册的声明（建议但不强制使用）
       iss: jwt签发者
       sub: jwt所面向的用户, zs
       aud: 接收jwt的一方
       exp: jwt的过期时间，这个过期时间必须要大于签发时间
       nbf: 定义在什么时间之前，该jwt都是不可用的.
       iat: jwt的签发时间
       jti: jwt的唯一身份标识，主要用来作为一次性token
   2. 公共的声明:
   	公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密
   3. 私有的声明:
   	私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息
   	
   定义一个payload: 如 {"sub":"1234","name":"xxx","admin":true} 进行Base64编码后得到JWT第二部分如 eyJzdWIiOiIxMjM0NTY3ODkbmFtZSI6IkpvaG4gRG9lIiwiYW...
   ```

3. 签名(signature):

   ```
   通过指定的算法生成哈希，以确保数据不会被篡改。jwt的第三部分是一个签证信息，通过指定的算法生成哈希，以确保数据不会被篡改，这个签证信息由三部分组成：head(base64编码后的)；playload(base64编码后的)；secret(秘钥)
   签名后的密文构成JWT第三部分如：ThecMfgYjtoys3JX7dpx3hu6pUm0piZ0tXXr
   ```

> 最后JWT构建的内容编码后的字符串:“eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiI4ODgiLCJzdWIiOiLlsI_nmb0iLCJpYXQiOjE1NTc5MDQxODF9.ThecMfgYjtoys3JX7dpx3hu6pUm0piZ0tXXreFU_u3Y”



理解:其实这三部分分别是:

1. 头部: 存放JWT基本信息-->以JSON结构存储然后以Base64转码
2. 载荷: 存放主要的数据内容-->以JSON结构存储然后以Base64转码
3. 签名: 通过前两个部分再加一个秘钥通过算法生成一个签证信息-->Base64

然后最终的JWT就是将上面每部分的Base64再一次Base64编码就是最终的字符!

### 9.2.SpringCloud Oauth2

​	SpingSecurityOauth2实现了Oatuh2，SpingSecurityOauth2分为两个大块，一者为`认证授权`(Authorization Server)服务和`资源服务`(Resource server);

**认证授权服务**一般负责执行`认证逻辑`(登录)和`加载用户的权限`(给用户授权)，以及认证成功后的`令牌颁发` ，

**资源服务器**一般指的是我们系统中的微服务(被访问的微服务)，在资源服务器需要对用户的令牌(`认证成功与否`)，以及`授权(是不是有访问权限)做检查`

授权服务和资源服务的流程图：

![image-20211207163658139](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211207163658139.png)

以上是一种SpringCloud Oauth2的认证和授权的流程图!

![image-20211207163742678](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211207163742678.png)

这个就是一种标准的`授权码模式`!先获取授权码再通过授权码获取token, 根据token去请求资源信息!

----

1. 授权服务配置类:

   ```java
   package cn.miao.config;
   
   import org.springframework.beans.factory.annotation.Autowired;
   import org.springframework.context.annotation.Bean;
   import org.springframework.context.annotation.Configuration;
   import org.springframework.http.HttpMethod;
   import org.springframework.security.authentication.AuthenticationManager;
   import org.springframework.security.crypto.password.PasswordEncoder;
   import org.springframework.security.oauth2.config.annotation.configurers.ClientDetailsServiceConfigurer;
   import org.springframework.security.oauth2.config.annotation.web.configuration.AuthorizationServerConfigurerAdapter;
   import org.springframework.security.oauth2.config.annotation.web.configuration.EnableAuthorizationServer;
   import org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerEndpointsConfigurer;
   import org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerSecurityConfigurer;
   import org.springframework.security.oauth2.provider.client.JdbcClientDetailsService;
   import org.springframework.security.oauth2.provider.code.JdbcAuthorizationCodeServices;
   import org.springframework.security.oauth2.provider.token.AuthorizationServerTokenServices;
   import org.springframework.security.oauth2.provider.token.DefaultTokenServices;
   import org.springframework.security.oauth2.provider.token.TokenEnhancerChain;
   import org.springframework.security.oauth2.provider.token.TokenStore;
   import org.springframework.security.oauth2.provider.token.store.InMemoryTokenStore;
   import org.springframework.security.oauth2.provider.token.store.JwtAccessTokenConverter;
   import org.springframework.security.oauth2.provider.token.store.JwtTokenStore;
   
   import javax.sql.DataSource;
   import java.util.Arrays;
   
   //授权服务配置
   @Configuration
   //开启授权服务配置
   @EnableAuthorizationServer
   public class AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter {
   
       //1.客户端详情配置(请求参数)
       @Autowired
       private DataSource dataSource ;
   
       @Autowired
       private PasswordEncoder passwordEncoder ;
   
       //1.1.注册客户端详情Bean,基于数据库,自动操作表：oauth_client_details
       @Bean
       public JdbcClientDetailsService jdbcClientDetailsService(){
           JdbcClientDetailsService jdbcClientDetailsService = new JdbcClientDetailsService(dataSource);
           //数据库的秘钥使用了PasswordEncoder加密
           jdbcClientDetailsService.setPasswordEncoder(passwordEncoder);
           return jdbcClientDetailsService;
       }
   
       /**
        * 客户端详情：配置客户端请求的参数
        *
        * @param clients 客户
        * @throws Exception 异常
        */
       @Override
       public void configure(ClientDetailsServiceConfigurer clients) throws Exception {
           clients.withClientDetails(jdbcClientDetailsService());
       }
   
       //2.授权服务端点配置(授权码，令牌)
   
       @Autowired
       private AuthenticationManager authenticationManager ;
   
       //2.1.定义授权码服务,连接数据库 oauth_code
       @Bean
       public JdbcAuthorizationCodeServices jdbcAuthorizationCodeServices(){
           return new JdbcAuthorizationCodeServices(dataSource);
       }
       //2.2.令牌服务配置
       //令牌的管理服务
       @Bean
       public AuthorizationServerTokenServices tokenService(){
           //创建默认的令牌服务
           DefaultTokenServices services = new DefaultTokenServices();
           //指定客户端详情配置
           services.setClientDetailsService(jdbcClientDetailsService());
           //支持产生刷新token
           services.setSupportRefreshToken(true);
           //token存储方式
           services.setTokenStore(tokenStore());
   
           //设置token增强 - 设置token转换器
           TokenEnhancerChain tokenEnhancerChain = new TokenEnhancerChain();
           tokenEnhancerChain.setTokenEnhancers(Arrays.asList(jwtAccessTokenConverter()));
           services.setTokenEnhancer(tokenEnhancerChain);  //jwtAccessTokenConverter()
   
           return services;
       }
   
       //2.3.配置Token的存储方案
       //基于内存的Token存储
       @Bean
       public TokenStore tokenStore(){
   //        return new InMemoryTokenStore();
           return new JwtTokenStore(jwtAccessTokenConverter());
       }
   
       //2.4.配置令牌转换器 ，设置JWT签名密钥。它可以是简单的MAC密钥，也可以是RSA密钥
       private final String sign_key  = "123";
   
       //JWT令牌校验工具
       @Bean
       public JwtAccessTokenConverter jwtAccessTokenConverter(){
           JwtAccessTokenConverter jwtAccessTokenConverter = new JwtAccessTokenConverter();
           //设置JWT签名密钥。它可以是简单的MAC密钥，也可以是RSA密钥
           jwtAccessTokenConverter.setSigningKey(sign_key);
           return jwtAccessTokenConverter;
       }
   
       /**
        * 授权服务断点：配置授权码和令牌的管理/存储方式
        *
        * @param endpoints 端点
        * @throws Exception 异常
        */
       @Override
       public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception {
           endpoints
               //1.密码授权模式需要 密码模式，需要认证管理器
               .authenticationManager(authenticationManager)
               //2.授权码模式服务
               .authorizationCodeServices(jdbcAuthorizationCodeServices())
               //3.配置令牌管理服务
               .tokenServices(tokenService())
               //允许post方式请求
               .allowedTokenEndpointRequestMethods(HttpMethod.POST);
       }
   
   
       /**
        * 授权服务安全配置：配置哪些路径放行(检查token的路径要放行)
        *
        * @param security 安全
        * @throws Exception 异常
        */
       @Override
       public void configure(AuthorizationServerSecurityConfigurer security) throws Exception {
           security
                   //对应/oauth/check_token ，路径公开
                   .checkTokenAccess("permitAll()")
                   //允许客户端进行表单身份验证,使用表单认证申请令牌
                   .allowFormAuthenticationForClients();
       }
   
   }
   ```

分析:

SpringSecurityOauth2提供了AuthorizationServerConfigurerAdapter适配器类来作为认证授权服务的配置,其中有三个方法源码如下：

```java
public class AuthorizationServerConfigurerAdapter  {
    //客户端详情：配置客户端请求的参数
    public void configure(ClientDetailsServiceConfigurer clients)...	
    //授权服务断点：配置授权码和令牌的管理/存储方式
    public void configure(AuthorizationServerEndpointsConfigurer endpoints)...
    //授权服务安全配置：配置哪些路径放行(检查token的路径要放行)
    public void configure(AuthorizationServerSecurityConfigurer security) ...
}
```

作用分别如下：

1. `ClientDetailsServiceConfigurer`：用来配置客户端详情服务：如配置客户端id(client_id)资源id、客户端密钥(secrect)、授权方式、scope等,可以基于内存或jdbc。(可以理解为是对浏览器向授权服务器获取授权码或令牌时需要提交的参数配置)
2. `AuthorizationServerEndpointsConfigurer`:配置令牌的访问端点url和令牌服务，如配置如何管理授权码(内存或jdbc)，如何管理令牌(存储方式，有效时间等等)
3. `AuthorizationServerSecurityConfigurer`: 用来配置令牌端点的安全约束，如配置对获取授权码，检查token等某些路径进行放行

授权服务配置分析:

![image-20211207165519707](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211207165519707.png)

总结:

授权服务配置了三个东西:

1. `ClientDetailsServiceConfigurer`:配置客户端信息，如同做微信登录的时候获取授权码和令牌时需要传入很多的参数，这些参数就是客户端详情配置的参数

2. `AuthorizationServerEndpointsConfigurer`:配置token相关端点，以及token如何存取，以及客户端支持哪些类型token

3. `AuthorizationServerSecurityConfigurer`:配置了端点就要对端点配置约束

----

**授权码模式获取token:**

先进行登录

![image-20211207165841539](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211207165841539.png)

第一步，通过浏览器获取授权码，GET访问:

http://localhost:1100/oauth/authorize?client_id=webapp2&response_type=code&redirect_uri=http://www.baidu.com ，操作如下：

![image-20211207165903812](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211207165903812.png)

![image-20211207165910412](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211207165910412.png)

第二步使用Postmain获取令牌，Post访问：

Url: [http://localhost:1100/oauth/token](http://localhost:3000/oauth/token)?client_id=webapp2&client_secret=123&grant_type=authorization_code&code=gD8ZbB&redirect_uri=http://www.baidu.com ，

操作如下：

![image-20211207165932700](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211207165932700.png)

---

密码授权模式:

在授权服务中我们配置了"password"密码模式,"authorization_code"授权码模式两种方式，接下来是测试“password”模式获取，将grant_type修改为“password” 添加username和password两个参数，去掉code参数:

![image-20211207165958237](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211207165958237.png)

----

刷新token:

http://localhost:3000/oauth/token?grant_type=refresh_token&refresh_token=刷新Token值&client_id=webapp&client_secret=secret

校验token:

http://localhost:3000/oauth/check_token?token=token值

访问资源 ，请求头带参数： “Authorization= Bearer token的值“-->注意Bearer后面有个空格!

----

当获取到token以后携带token去访问资源服务,那么在资源服务中也需要这样去配置:

```java
package cn.miao.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.oauth2.config.annotation.web.configuration.EnableResourceServer;
import org.springframework.security.oauth2.config.annotation.web.configuration.ResourceServerConfigurer;
import org.springframework.security.oauth2.config.annotation.web.configurers.ResourceServerSecurityConfigurer;
import org.springframework.security.oauth2.provider.token.TokenStore;
import org.springframework.security.oauth2.provider.token.store.JwtAccessTokenConverter;
import org.springframework.security.oauth2.provider.token.store.JwtTokenStore;

//ResourceServerConfigurer:资源服务器配置
//@EnableResourceServer:开启资源服务配置
@Configuration
@EnableResourceServer
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class ResourceServerConfig implements ResourceServerConfigurer {

    //2.3.配置Token的存储方案
    //基于内存的Token存储
    @Bean
    public TokenStore tokenStore(){
        //return new InMemoryTokenStore();
        return new JwtTokenStore(jwtAccessTokenConverter());
    }

    //2.4.配置令牌转换器 ，设置JWT签名密钥。它可以是简单的MAC密钥，也可以是RSA密钥
    private final String sign_key  = "123";

    //JWT令牌校验工具
    @Bean
    public JwtAccessTokenConverter jwtAccessTokenConverter(){
        JwtAccessTokenConverter jwtAccessTokenConverter = new JwtAccessTokenConverter();
        //设置JWT签名密钥。它可以是简单的MAC密钥，也可以是RSA密钥
        jwtAccessTokenConverter.setSigningKey(sign_key);
        return jwtAccessTokenConverter;
    }

    //授权服务安全配置
    @Override
    public void configure(ResourceServerSecurityConfigurer configurer) throws Exception {
        //微服务的资源ID
        configurer.resourceId("courseId");
        //token的存储
        configurer.tokenStore(tokenStore());
    }

    //资源的授权规则配置
    @Override
    public void configure(HttpSecurity httpSecurity) throws Exception {
        httpSecurity.authorizeRequests()
                .antMatchers("/courseType/crumbs/**",
                        "/courseType/treeData",
                        "/swagger-ui.html","/**").permitAll()
                //校验scope必须为hrm ， 对应认证服务的客户端详情配置的clientId
                .antMatchers("/**").access("#oauth2.hasScope('hrm')")
                .anyRequest().authenticated()
                .and().csrf().disable();

    }
}
```

测试:

向资源服务器发起请求，请求头携带：`Authorization=Bearer token`值 ，如下:

![image-20211207173649167](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211207173649167.png)

​	这里我们已经成功的访问到真正的资源，请求资源之前，资源服务器会发送远程请求到授权服务器验证token的合法性，并且根据当前token获取权限列表，然后在进行授权，如果权限列表拥有资源(controller的方法)所需要的权限，即可访问成功;

错误示范：

如果Token是无效的会出现如下信息：

![image-20211207173733432](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211207173733432.png)

如果Token中的权限不包含资源所需要的权限会出现如下信息：

![image-20211207173754158](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211207173754158.png)

### 9.3. 微服务与微服务之间的授权

为什么?

​	当客户端先资源服务发起请求，请求头携带Token，在资源服务(A)需要校验Token进行访问授权，但是我们一个请求往往是需要多个微服务一起完成，如果A服务调用B服务调用C服务，那么A服务校验Token之后，B服务需不需要也校验Token呢？答案是当然的，因为每个微服务都是独立的都需要做好权限校验工作？那么如何实现服务之间的授权？



解决方案:

​	直接把客户端提交给资源服务的Token继续向下游资源服务提交，那么就需要在消费者服务A向提供者服务器B发起请求(Feign)的时候进行拦截(Feign的拦截器)，在拦截器中获取请求头中的Token添加到Fiegn的请求头中，这样一来Token就由A服务传递给了B服务，B服务就可以对Token进行校验了。如图

![image-20211207174224358](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211207174224358.png)

这样虽然在发起请求的时候拦截并手动的添加到目标服务的请求头中,可是如果遇到hystrix那么这也就会暴露出一个问题: `资源隔离`!

![image-20211207174454312](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211207174454312.png)

解决方案:

![image-20211207174518001](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211207174518001.png)

解决:

理解:

​	其实看到这张图也就懂了,在A服务向B服务发起调用的时候那么就需要将Token权限给带过去,那么这个过程是这样的: 首先一个请求会在A线程里执行,那么进入到Hystrix的线程池中因为hystrix的资源隔离的特性会让A请求不在A线程里执行而是更换新的线程B里面执行,那么这开始执行的线程和最后执行的线程是不一致的!所以我们需要修改线程池并发策略,在更换新的线程的时候手动的将开始的请求中的token手动添加到目标线程里面,然后还需要在B服务接收的时候需要使用Feigin拦截器去获取令牌然后放进请求头中!这样token才会进行目标的资源进行判断是否授权!



请求拦截:

```java
//Fiegn拦截器----调用的那一方获取到的拦截器,如B服务
@Component
public class DefaultOAuth2FeignRequestInterceptor implements RequestInterceptor {

    //请求头中的token
    private final String AUTHORIZATION_HEADER = "Authorization";
    
    @Override
    public void apply(RequestTemplate requestTemplate) {

        //1.获取请求对象
        ServletRequestAttributes servletRequestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
        HttpServletRequest request = servletRequestAttributes.getRequest();

        //2.从请求头获取到令牌
        String authorization = request.getHeader(AUTHORIZATION_HEADER);

        //3.把令牌添加到Fiegn的请求头
        requestTemplate.header(AUTHORIZATION_HEADER,authorization);
    }

}
```

修改线程池并发策略:

```java
@Configuration
@Slf4j
public class FeignHystrixConcurrencyStrategy extends HystrixConcurrencyStrategy {

    private HystrixConcurrencyStrategy hystrixConcurrencyStrategy;

    public FeignHystrixConcurrencyStrategy() {
        try {
            this.hystrixConcurrencyStrategy = HystrixPlugins.getInstance().getConcurrencyStrategy();
            if (this.hystrixConcurrencyStrategy instanceof FeignHystrixConcurrencyStrategy) {
                return;
            }
            HystrixCommandExecutionHook commandExecutionHook =
                    HystrixPlugins.getInstance().getCommandExecutionHook();
            HystrixEventNotifier eventNotifier = HystrixPlugins.getInstance().getEventNotifier();
            HystrixMetricsPublisher metricsPublisher = HystrixPlugins.getInstance().getMetricsPublisher();
            HystrixPropertiesStrategy propertiesStrategy =
                    HystrixPlugins.getInstance().getPropertiesStrategy();

            HystrixPlugins.reset();
            HystrixPlugins instance = HystrixPlugins.getInstance();
            instance.registerConcurrencyStrategy(this);
            instance.registerCommandExecutionHook(commandExecutionHook);
            instance.registerEventNotifier(eventNotifier);
            instance.registerMetricsPublisher(metricsPublisher);
            instance.registerPropertiesStrategy(propertiesStrategy);
        } catch (Exception e) {
            System.out.println("策略注册失败");
        }
    }

    @Override
    public <T> Callable<T> wrapCallable(Callable<T> callable) {
        //此时在 A 线程 ,拿到请求
        RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes();
        //新开线程，把请求传入进去
        log.info("线程{} ， 拿到请求 {}", Thread.currentThread().getName(),requestAttributes);
        return new WrappedCallable<>(callable, requestAttributes);
    }

    @Override
    public ThreadPoolExecutor getThreadPool(HystrixThreadPoolKey threadPoolKey,
                                            HystrixProperty<Integer> corePoolSize,
                                            HystrixProperty<Integer> maximumPoolSize,
                                            HystrixProperty<Integer> keepAliveTime,
                                            TimeUnit unit, BlockingQueue<Runnable> workQueue) {
        return this.hystrixConcurrencyStrategy.getThreadPool(threadPoolKey, corePoolSize, maximumPoolSize, keepAliveTime,
                unit, workQueue);
    }

    @Override
    public ThreadPoolExecutor getThreadPool(HystrixThreadPoolKey threadPoolKey,
                                            HystrixThreadPoolProperties threadPoolProperties) {
        return this.hystrixConcurrencyStrategy.getThreadPool(threadPoolKey, threadPoolProperties);
    }

    @Override
    public BlockingQueue<Runnable> getBlockingQueue(int maxQueueSize) {
        return this.hystrixConcurrencyStrategy.getBlockingQueue(maxQueueSize);
    }

    @Override
    public <T> HystrixRequestVariable<T> getRequestVariable(HystrixRequestVariableLifecycle<T> rv) {
        return this.hystrixConcurrencyStrategy.getRequestVariable(rv);
    }

    static class WrappedCallable<T> implements Callable<T> {
        private final Callable<T> target;

        //A线程扔过来的请求
        private final RequestAttributes requestAttributes;

        public WrappedCallable(Callable<T> target, RequestAttributes requestAttributes) {
            this.target = target;
            this.requestAttributes = requestAttributes;
        }

        @Override
        public T call() throws Exception {
            try {
                //此时的代码在 B 线程 ，把请求设置到 RequestContextHolder
                RequestContextHolder.setRequestAttributes(requestAttributes);
                log.info("线程执行{} ， 设置请求到RequestContextHolder {}", Thread.currentThread().getName(),requestAttributes);
                return target.call();
            } finally {
                RequestContextHolder.resetRequestAttributes();
            }
        }
    }
}
```

---

获取当前登录用户的信息

​	其实这种呢我们可以在用户登录认证的时候有一个`Userdetailservice`里查询用户信息进行修改, 一次性查询出想要的信息,然后通过JSON序列化返回给客户端, 然后下次我们想要的时候就会通过一个工具类去获取然后转换为实体类:

```java
@Component
@Slf4j
public class MyUserDetailService implements UserDetailsService {

    @Autowired
    private ILoginService loginService ;

    @Autowired
    private PermissionMapper permissionMapper ;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {

        Login login = loginService.selectOne(new EntityWrapper<Login>().eq("username", username));
        Assert.notNull(login, "用户不存在!");

        //查询用户的权限
        List<GrantedAuthority> authorities = new ArrayList<>();
        List<Permission> permissions = permissionMapper.selectPermissionsByUserId(login.getId());
        if(CollUtil.isNotEmpty(permissions)){
            authorities = permissions.stream().map(p -> new SimpleGrantedAuthority(p.getSn()) ).collect(Collectors.toList());
        }

        log.info("加载用户的权限 {}",authorities);
        authorities.forEach(System.out::println);

        //获取用户上下文信息, 那么可以用户登录的时候通过查询的login就查询出所需要的字段信息,放入token中
        //下次获取的时候我们可以通过scurity中的ScurityContextHolder来获取用户的信息

        Map<Object, Object> build = MapUtil.builder().put("id", login.getId()).put("username", login.getUsername()).put("tenantId", login.getTenantId()).put("tenantName", login.getTenantName()).build();
        //用户名
        return new User(JSONObject.toJSONString(build),
                login.getPassword(),//密码
                true,true,true,true,
                authorities);//权限
    }
}
```

获取工具类:

```java
public class LoginContext {

    public static Login getLogin(){
        try {
            SecurityContext context = SecurityContextHolder.getContext();
            //这里就能获取到校验token中的user_name, 这里封装了我们想要的数据
            String principal = (String)context.getAuthentication().getPrincipal();
            return JSONObject.parseObject(principal, Login.class);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }
}
```

### 9.4 小结

理解JWT:

```
jwt是一种规范!这个规范允许我们在用户和服务之间传递可靠的信息 , 传输使用的JSON结构来传输,又是存在数字签名所以传输时可靠的!并且使用token进行加密然后解密!    
```

好处:其实使用jwt这种token方案比之前的redis缓存也有一定的好处,之前需要依赖于redis服务去存储权限和用户信息去放在redis中,每次需要用到都需要去拿然后解析,而现在只需要将信息放在客户端,由客户端去保存信息,然后每次获取的时候携带到对应服务中然后解析获取权限, 依赖度也降低了!

我们可以理解为就是在之前生成的token的基础之上进行了加密! 并且这种token方式无需放在redis缓存中而是存放在客户端, 客户端就存放的是用户的权限等信息, 所以资源服务就会根据这个token进行解密然后就会走security进行授权的流程!

![image-20211207191754350](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211207191754350.png)



对于Spring Security oauth2的权限和token,我总结分两大块:

1. **认证服务**:登录认证授权和颁发token;
2. **资源服务**:解析token获取权限判断是否有权限;

整个的执行的流程:

​	认证服务:

```
用户在浏览器通过表单登录,这时就会携带账号和密码提交到认证服务中,这时就会封装携带clientID和秘钥一起发送请求获取token,那么此时就会走scurity的认证流程,通过一层一层认证通过username查询用户,最后查询出用户信息和对应的权限信息一并返回,这时登录认证的工作就完成了,那么接下来就是走JWT的颁发token的一个过程: 根据clientID去客户端详情表中查询获取颁发token所需要的参数,然后根据scurity认证获取的权限信息利用JWT封装成一个密文, 这个密文就是转为Base64后的token,然后将其token返回给客户端!
```

​	资源服务:

```
在访问其他资源的时候就会携带上这个token去访问,那么在资源服务里就会根据在认证服务里根据密文生成的token,此时就会根据相同的秘文去解析整个token,解析后获取对应的权限列表和一些其他参数信息,然后就判断resourceID做一个资源的大的判断,然后接下来就会走scurity的授权流程根据方法上的注解的权限进行判断, 如果满足,哎就放行,如果不满足,哎就打回!
```

总结:

![image-20211207182235873](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211207182235873.png)

其实就往大的一个方向去说: 先认证后颁发token, 然后解析token然后走授权流程!------这就是JWT微服务token方案!

----

服务之间授权的理解:	

```
按照正常的调用过程中,我们会携带一个token去调用另一个服务,但是在调用过程中我们是使用的是HTTP调用,那么token是没有带过去的,那么就需要我们使用feigin拦截手动将请求头的token添加目标请求的请求头中!但是要知道feigin是集成了hystrix,那么我们知道hystrix里面有一个资源隔离的说法,一个信号量一个线程池; 就会造成A请求是在A线程里面,当经过hystrix的线程池中,就会将A线程更换为B线程去执行,那么此时请求头中的token也会丢失,所以解决办法:
1. 信号量(自始至终都是一个线程)
2. 修改线程池并发策略

我们要做的就是第二个解决办法,就是在覆写线程池并发策略手动将A线程中的token放入到B线程中去! 然后在目标服务中使用feigin拦截器拦截并将B线程中的token放入到请求头中去!
```

为什么换个线程请求就不在了?

​	因为首先A请求中的token是单个线程独有的,当执行到线程池这里就会新开一个线程,比如线程B, 那么之前的请求中的token在A线程有那么到线程B就不存在了!



## 10.单点登录和无感刷新

在微服务中发起请求将token通过zuul就会拦截token ,解决办法:

zuul会默认认为浏览器请求头中会存在敏感信息,所以就会屏蔽拿不到token,所以解决办法就是在yaml中配置修改默认存在敏感信息即可!

```yaml
zuul:
  sensitive-headers:     #把zuul忽略敏感请求头的配置覆盖为空
```

请求状态:

401: 过期或者token不存在

403: 没有权限

----

单点登录:

概念:是指在一个网站登录那么其他的网站的就不需要登录了,就好比京东的网站,你在一个站点登录了那么在其他站点就不需要登录了!

不同的站点服务器只要任一地方登录那么访问任何地方都是已经登录的状态!



那么这个如何实现的呢?

将之前存在localStorage中的token改存于cookie中, 然后将cookie中的domain修改为几个服务器域名共同访问,如: [www.hrm.com](http://www.hrm.com)  admin.hrm.com  那么就可以修改为 .hrm.com 那么只要包含这个域名下这个cookie都可以访问!

如何修改本地hosts文件:

```java
127.0.0.1 admin.hrm.com
127.0.0.1 user.hrm.com
```

以上就是模拟几个站点的域名

然后在一个前端站点登录的时候:

![image-20211207193055416](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211207193055416.png)

将其添加cookie,注意此时domain作用域是`.hrm.com`,也就是说只要域名是.hrm.com后缀的都可以享有这个cookie!那么也就是说只要一次登录那么此时cookie就有了,那么其他站点访问资源的时候就会从cookie里面拿就获取用户的登录信息了!

![image-20211207195236324](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211207195236324.png)

-----

无感刷新:

概念: 如用户在浏览网页的时候如果突然token过期了那么此时就会影响客户的一个浏览体验,所以我们可以采用无感刷新让用户没有感觉一样的浏览网页!

根据返回状态请重新刷新token,  然后获取token再覆盖本地的token,再 重新发起请求---无感token 对于用户来说是没有任何的感觉的!

token存在过期的几种情况?

1. 对于客户端:如果在cookie里那么也有过期时间就会自动消失
2. 对于服务端:本身来讲token里面就有一个过期时间,如果到了过期时间你再去访问那么就会报出过期的异常信息!



解决办法:

1. 延长token的过期时间
2. 使用刷新token去刷新获取token

因为第一次登录获取token的时候就有一个本身的token还有一个刷新token, 那么我们可以利用刷新token来获取新的token然后存于客户端!



实战:

前端:添加请求响应拦截器

这里判断了如果是401的响应代表Token过期，重新组装参数刷新Token,然后重新设置到localStorage,然后调用  ***\**axios\**\***.request 继续执行请求 ， 需要注意的是刷新Token的请求必须是同步的，因为我们需要拿到Token后才能继续发请求。

```javascript
//处理Token刷新========================================================================
axios.interceptors.response.use(config => {
    return config
},error => {
    if (error && error.response) {
        console.log(error);
        switch (error.response.status) {
            case 401: return doRequest(error);
            case 403: return doNoPerHandler(error);
        }
    }
    Promise.reject(error)
});
function doNoPerHandler(error) {
    alert("没访问权限");
}
async function doRequest (error) {
    try {
        //获取新的Token
        const data = await getNewToken();
        var token = data.data.resultObj.access_token;
        var refresh_token = data.data.resultObj.refresh_token;
        sessionStorage.setItem("U-TOKEN",token);
        sessionStorage.setItem("R-TOKEN",refresh_token);
        //继续执行上一次失败的请求
        const res = await axios.request(error.config);
        return res;
    } catch(err) {
        alert("登录失效,请重新登录");
        sessionStorage.clear();
        router.replace({ path:"/login" });
        return err;
    }
}

//刷新Token
async function getNewToken() {
    var refreshToken = sessionStorage.getItem('R-TOKEN');
    if(refreshToken){
        return await axios({
            url: '/auth/login/refresh?refreshToken='+refreshToken+"&type=1",
            method: 'post',
            headers: {
                'Content-Type':'application/x-www-form-urlencoded'
            }
        })
    }else{
        alert("登录失效,请重新登录");
        sessionStorage.clear();
        router.replace({ path:"/login" });
    }
}

//处理Token刷新end================================================================
```

后台刷新:

```java
//系统刷新
@RequestMapping(value="/refresh")
public AjaxResult refresh(@RequestParam("refreshToken") String refreshToken,@RequestParam("type") Integer type){
    AccessTokenVo accessTokenVo = loginService.refresh(refreshToken,type);
    return AjaxResult.me().setResultObj(accessTokenVo);
}

@Override
public AccessTokenVo refresh(String refreshToken,Integer type) {
    //根据传入的type,得到对应的客户端配置
    Oauth2ClientDetails clientDetails = properties.getClientDetials(type);

    //1.拼接一个获取oath2的token的url:密码模式
    String url = String.format(URL_TOKEN_REFRESH, clientDetails.getClientId(),
            clientDetails.getSecret(),refreshToken);
    //2.发送请求获取token
    Map<String, String> map = HttpUtil.sendPost(url);
    //3.封装结果
    String tokenJson = JSON.toJSONString(map);
    return JSON.parseObject(tokenJson,AccessTokenVo.class );
}
```

-----

面试题:

1. Token失效了怎么办?
   - 我们可以做无感刷新
2. 注销了怎么办?
   - 删除前端存储的token(包括刷新token)
3. Token丢失怎么办，别人拿到你的Token来访问你的系统？
   - 其实这个问题怎么可能嘛,反过来想这个token是保存在我们的浏览器中我的电脑中,如果别人能拿到难道这不就是在黑客入侵我的电脑,难道此时关注的重点是token被拿? 如果是身边的人拿那么我们也可以做一个自动锁屏的功能? 对于一般的用户来讲它都不会去点开F12更不会去操作token!并且会想token是不会暴露给用户的, 因为这是放在请求头中的!
4. 讲一下你们的认证授权的总体流程?
   - 首先用户在前端发起表单登录,然后此时就会请求到我们认证服务中,我们拿到账号和密码去通过SpringSecurity去进行认证的一个流程(通过loginDetailService查询),此时我们能拿到用户的权限等信息,然后根据后台自己定义的clientID去客户端参数详情表中查询生成token所需要的参数,然后根据秘钥将权限和参数生成一个密文,这个密文就是token,然后将这个token返回给客户端进存储
   - 访问资源服务的时候就会携带这个token,然后在资源服务中根据生成token相同的密文进行令牌转换器解析,通过解析后得到权限信息, 进行校验SourceID和scope,如果满足就执行下一步,然后访问到具体的方法上的security的权限注解,那么此时就会进入security的授权的流程,如果满足这个权限就会开放资源,如果不满足那么就会直接拒绝访问!
   - 
