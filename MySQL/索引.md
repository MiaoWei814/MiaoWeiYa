# 索引

## 1. 概念:

**引入**:何为索引?我也心存疑惑,有人说索引的功能就是让你的SQL语句的查询效率变快,你只要一搜关于SQL那么索引的关键字必不可少,所以索引这个知识点的重要程度也就呼之欲出了!

**索引的通俗了解**:索引就像书的目录,通过书的目录就准确的定位到书籍具体的内容

**准确概念**:一般的应用系统，读写比例在10:1左右，而且插入操作和一般的更新操作很少出现性能问题，在生产环境中，我们遇到最多的，也是最容易出问题的，还是一些复杂的查询操作，因此对查询语句的优化显然是重中之重。说起加速查询，就不得不提到索引了

**一般在数据库中有两种查询方式:**

1. 全表扫描(从第一条记录开始扫描直到整张表,效率很低)
2. 根据索引检索(效率很高!)

```
注意:
	虽然添加了索引会让数据的查询效率变快,但是也不能随意添加,因为索引也是数据库中的对象,也需要数据库不断的维护,也是有维护成本的。
	比如：表中的数据经常被修改这样就不适合添加索引，因为数据一旦修改那么索引也要重新排序从而进行维护的。
```

> 索引最根本的原理就是缩小了扫描的范围,从而导致提高了效率

添加索引的方式:就是给某一个字段添加或者某一些字段添加索引

```mysql
select ename,sal from emp where ename='SMITH';
1. 当ename字段上添加索引的时候,以上SQL语句会根据索引扫描,从而快速定位
2. 当ename字段上没有添加索引的时候,以上SQL语句就会进行全表扫描,来进行扫描ename字段中所有的值
```

索引时一个什么东西?

​	索引就是一个数据结构，我们把表中的记录用一个适合高效查找的数据结构来表示，目的就是让查询变得更高效。

## 2.索引的应用

其实索引的创建并不复杂但是如何理解索引的原理还是很复杂的,现在先来看如何创建和删除:

首先我们在建立索引并不是盲目的建立索引(多建的话反而效率并不是那么高),我们通过执行计划来查询:

### 2.1 执行计划

MySQL使用`explain+sql语句`查看执行计划:

```mysql
EXPLAIN SELECT * FROM user WHERE nid = 3;
```

执行计划:

![执行计划](https://gitee.com/miawei/pic-go-img/raw/master/imgs/1334255-20181218161456575-1277410542.png)

来教你如何去看:

#### 2.1.1 id

**id**:Query Optimizer 所选定的执行计划中查询的序列号；

表示Select查询的序列号,包含一组数字,表示查询中执行select子句或操作表的顺序

三种情况:

1. id相同:执行顺序从上往下

   ![img](https://gitee.com/miawei/pic-go-img/raw/master/imgs/20170509234043416)

2. id不同:如果是子查询,id的序号会递增,id值越大表示优先级就越高,就会被越先执行

   ![img](https://gitee.com/miawei/pic-go-img/raw/master/imgs/20170510223451835)

3. id相同又不相同(两种情况都存在):id如果相同,可以认为是一组,从上往下顺序执行;在所有组中,id值越大,优先级就越高,就表示越先执行

   ![img](https://gitee.com/miawei/pic-go-img/raw/master/imgs/20170510224901726)

#### 2.1.2 select_type

- **select_type**:查询的类型,主要是用于区分普通查询、联合查询、子查询等复杂问题

| select_type  |                             说定                             |
| :----------: | :----------------------------------------------------------: |
|    SIMPLE    |              简单查询（不包含子查询或者union）               |
|   PRIMARY    |   查询中包含任何复杂的子部分，最外层查询则被标记为primary    |
|   SUBQUERY   |             在select 或 where列表中包含了子查询              |
|   DERIVED    | 在from列表中包含的子查询被标记为derived（衍生），mysql或递归执行这些子查询，把结果放在临时表里 |
|    UNION     | 若第二个select出现在union之后，则被标记为union；若union包含在from子句的子查询中，外层select将被标记为derived |
| UNION RESULT |                  从union表获取结果的select                   |

![img](https://gitee.com/miawei/pic-go-img/raw/master/imgs/20170510231953999)

#### 2.1.3 table

- table:表示要访问的表名,这个表名如果被重命名了那么在执行计划里也是显示重命名后的名字

#### 2.1.4 type

- type:访问类型，sql查询优化中一个很重要的指标!

|    type     |                             说明                             |
| :---------: | :----------------------------------------------------------: |
|  fulltext   |                         全文索引扫描                         |
|     ALL     |                MySQL将遍历全表以找到匹配的行                 |
|    index    |            index与ALL区别为index类型只遍历索引树             |
|    RANGE    | 索引范围扫描，对索引的扫描开始于某一点，返回匹配值域的行，常见于between、<、>等的查询 |
| INDEX_MERGE |                合并索引，使用多个单列索引搜索                |
|     REF     | 非唯一性索引扫描，返回匹配某个单独值的所有行。常见于使用非唯一索引即唯一索引的非唯一前缀进行的查找 |
|   EQ_REF    | 唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描 |
|    CONST    | 通过索引依次就找到了,const用于比较primary key 或者 unique索引。因为只需匹配一行数据，所有很快。如果将主键置于where列表中，mysql就能将该查询转换为一个const |
|   SYSTEM    |   系统，表仅有一行(=系统表)。这是const联接类型的一个特例。   |
|    NULL     |    MySQL在优化过程中分解语句，执行时甚至不用访问表或索引     |

关于性能方面好坏从左往右依次:System > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL

> 其中SQL能执行到range比较好,若是能达到ref就更好

理解:

```sql
1.ALL 全表扫描
2.index 索引全扫描
3.range 索引范围扫描，常用语<,<=,>=,between,in等操作
4.ref 使用非唯一索引扫描或唯一索引前缀扫描，返回单条记录，常出现在关联查询中
5.eq_ref 类似ref，区别在于使用的是唯一索引，使用主键的关联查询
6.const/system 单条记录，系统会把匹配行中的其他列作为常数处理，如主键或唯一索引查询
7.null MySQL不访问任何表或索引，直接返回结果
```



1. **System**:表只有一行记录（等于系统表），这是const类型的特例，平时不会出现，可以忽略不计

2. **const**:表示通过索引一次就找到了，const用于比较primary key 或者 unique索引。因为只需匹配一行数据，所有很快。如果将主键置于where列表中，mysql就能将该查询转换为一个const 

   ![img](https://gitee.com/miawei/pic-go-img/raw/master/imgs/20170511215148532)

3. **eq_ref**:唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键 或 唯一索引扫描。 

   ![img](https://gitee.com/miawei/pic-go-img/raw/master/imgs/20170512143354425)

4. **ref**:非唯一性索引扫描，返回匹配某个单独值的所有行。本质是也是一种索引访问，它返回所有匹配某个单独值的行，然而他可能会找到多个符合条件的行，所以它应该属于查找和扫描的混合体,也可以理解为筛选条件使用两个索引字段筛选 

   ![img](https://gitee.com/miawei/pic-go-img/raw/master/imgs/20170512150131136)

5. **range**:只检索给定范围的行，使用一个索引来选择行。key列显示使用了那个索引。一般就是在where语句中出现了bettween、<、>、in等的查询。这种索引列上的范围扫描比全索引扫描要好。只需要开始于某个点，结束于另一个点，不用扫描全部索引

   ![img](https://gitee.com/miawei/pic-go-img/raw/master/imgs/20170512151841933)

6. **index**:Full Index Scan，index与ALL区别为index类型只遍历索引树。这通常为ALL块，应为索引文件通常比数据文件小。（Index与ALL虽然都是读全表，但index是从索引中读取，而ALL是从硬盘读取） 

   ![img](https://gitee.com/miawei/pic-go-img/raw/master/imgs/20170512152255874)

   ![image-20210818091929807](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210818091929807.png)

7. **ALL**:遍历全表以找到匹配的行

   ![img](https://gitee.com/miawei/pic-go-img/raw/master/imgs/20170512152537516)



#### 2.1.5 possible_keys

possible_keys:查询涉及到的字段上存在索引，则该索引将被列出，但不一定被查询实际使用,也就是说可能会用到的索引

#### 2.1.6 key

- key:

  实际使用的索引,如果为NULL,那么就表示没有使用索引

  **查询中如果使用了覆盖索引,则该索引仅出现在key列表中**

  ![img](https://gitee.com/miawei/pic-go-img/raw/master/imgs/20170512155222855)

#### 2.1.7 key_len

- key_len:表示索引中使用的字节数，查询中使用的索引的长度（最大可能长度），并非实际使用长度，理论上长度越短越好。key_len是根据表定义计算而得的，不是通过表内检索出的

  **理解:**MySQL中使用索引字节长度

  ![image-20210818093658587](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210818093658587.png)

#### 2.1.8 ref

- ref:显示索引的那一列被使用了,如果可能,是一个常量的const

#### 2.1.9 rows

**rows**:根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数

**注意:**mysql 预估为了找到所需的行而要读取的行数

#### 2.1.10 extra

 不适合在其他字段中显示，但是十分重要的额外信息

|                    extra                    |                             说明                             |
| :-----------------------------------------: | :----------------------------------------------------------: |
|                 Using index                 | 表示直接访问索引就能够获取到所需要的数据（覆盖索引），不需要通过索引回表。 |
|                 Using where                 | 通常来说，意味着全表扫描或者在查找使用索引的情况下，但是还有查询条件不在索引字段当中。 如果需要回表也是用这个。 |
|               Using temporary               |  表示MySQL需要使用临时表来存储结果集，常见于排序和分组查询   |
|               Using filesort                | mysql会对结果使用一个外部索引排序，而不是按索引次序从表里读取行。mysql有两种文件排序算法，这两种排序方式都可以在内存或者磁盘上完成，explain不会告诉你mysql将使用哪一种文件排序，也不会告诉你排序会在内存里还是磁盘上完成。MySQL中无法利用索引完成的排序操作称为“文件排序” |
| Range checked for each record(index map: N) | 没有好用的索引，新的索引将在联接的每一行上重新估算，N是显示在possible_keys列中索引的位图，并且是冗余的 |
|           using index;using where           | 表示直接访问索引也能搞定数据，但是在索引中还进行过滤。 比如说使用了betwween, <, >。 |
|            Using Index Condition            | 会先条件过滤索引，过滤完索引后找到所有符合索引条件的数据行，随后用 WHERE 子句中的其他条件去过滤这些数据行； |

理解:

```mysql
1.Using filesort:
	MySQL需要额外的一次传递，以找出如何按排序顺序检索行。通过根据联接类型浏览所有行并为所有匹配WHERE子句的行保存排序关键字和行的指针来完成排序。然后关键字被排序，并按排序顺序检索行
2.Using temporary：
	使用了临时表保存中间结果，性能特别差，需要重点优化
3.Using index：
	表示相应的 select 操作中使用了覆盖索引（Coveing Index）,避免访问了表的数据行，效率不错！如果同时出现 using where，意味着无法直接通过索引查找来查询到符合条件的数据。
4.Using index condition：
	MySQL5.6之后新增的ICP，using index condtion就是使用了ICP（索引下推），在存储引擎层进行数据过滤，而不是在服务层过滤，利用索引现有的数据减少回表的数据。
```



- Using filesort

  mysql对数据使用一个外部的索引排序，而不是按照表内的索引进行排序读取。也就是说mysql无法利用索引完成的排序操作成为“文件排序” 

  ![img](https://gitee.com/miawei/pic-go-img/raw/master/imgs/20170515175218264)

  由于索引是先按email排序、再按address排序，所以查询时如果直接按address排序，索引就不能满足要求了，mysql内部必须再实现一次“文件排序”

- Using temporary

  使用临时表保存中间结果，也就是说mysql在对查询结果排序时使用了临时表，常见于order by 和 group by 

  ![img](https://gitee.com/miawei/pic-go-img/raw/master/imgs/20170515180947413)

- Using index

  表示相应的select操作中使用了**覆盖索引**（Covering Index），避免了访问表的数据行，效率高 
  如果同时出现Using where，表明索引被用来执行索引键值的查找（参考上图） 
  如果没用同时出现Using where，表明索引用来读取数据而非执行查找动作 

  ![img](https://gitee.com/miawei/pic-go-img/raw/master/imgs/20170515182415063)

覆盖索引:

```
也叫索引覆盖。就是select列表中的字段，只用从索引中就能获取，不必根据索引再次读取数据文件，换句话说查询列要被所建的索引覆盖。 
注意:
	1. 如需使用覆盖索引，select列表中的字段只取出需要的列，不要使用select * 
	2. 如果将所有字段都建索引会导致索引文件过大，反而降低crud性能
```

#### 2.1.11 filtered

表示此查询条件过滤的数据百分比

#### 2.1.12 综合case

![这里写图片描述](https://gitee.com/miawei/pic-go-img/raw/master/imgs/20170516093515092)

执行顺序:从执行计划中看哈(id值越大表示执行的优先级就越高)

1. id=4:

   ```mysql
   【select id,name from t2】:select_type 为union,说明id=4的select是union里面的第二个select。
   ```

2. id=3:

   ```mysql
   【select id, name from t1 where address = ‘11’】：因为是在from语句中包含的子查询所以被标记为DERIVED（衍生），where address = ‘11’ 通过复合索引idx_name_email_address就能检索到，所以type为index。
   ```

3. id=2:

   ```mysql
   【select id from t3】：因为是在select中包含的子查询所以被标记为SUBQUERY。
   ```

4. id=1:

   ```mysql
   【select d1.name, … d2 from … d1】：select_type为PRIMARY表示该查询为最外层查询，table列被标记为 “derived3”表示查询结果来自于一个衍生表（id = 3 的select结果）。
   ```

5. id=null:

   ```mysql
   【 … union … 】：代表从union的临时表中读取行的阶段，table列的 “union 1, 4”表示用id=1 和 id=4 的select结果进行union操作。
   ```

   

### 2.2 创建索引

我们如果没有创建索引,那么我们查询的话就会从全表扫描,从第一行直到最后一行,如:

![image-20210818103814812](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210818103814812.png)

 我们在数据库中创建使用的索引一般都是非聚集索引:

1. 创建普通索引:

   ```mysql
   语法:
   create index 索引名 on 表名(列名,列名2...);
   修改表的时候创建:
   alter table 表名 add index 索引名(列名1,列名2);
   创建表的时候指定索引:
   create table 表名([...],index 索引名(列名1,列名2));
   ```

   eg:

   CREATE INDEX name_index ON index_test(name); 此为在index_test表上的name列上创建一个索引name_index。

2. 创建唯一性索引:

   表示唯一的,不允许重复的索引,如果该字段信息保证不会重复例如身份证号用作索引时,可设置为`unique`;

   ```mysql
   1.创建索引:
   	create unique index 索引名 on 表名(列的列表)
   2.在表上增加索引:
   	alter table 表名 add unique 索引名(列的列表)
   3.创建表的时候指定索引:
   	create table 表名([...],unique 索引名(列的列表));
   ```

   eg:

   create unique index id_num_index on index_test(idNum);

   或:

   alter table index_test add unique id_num_index(idNum)

   表示在index_test表的idNum列上创建一个唯一索引id_name_index

   **注意:**创建唯一索引后,表示列中的值不能重复,那么如果插入一条重复的值就会报 Error Code: 1062. Duplicate entry '3' for key 'id_num_index'即在id_num_index唯一索引上出现了重复。



### 2.3 查看索引

查看索引一般都是查看整张表的索引:

语法:

```mysql
show index from 表名;
```

比如:

show index from emp;

![image-20210818105504191](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210818105504191.png)

解读每个字段:

|     字段     |                             说明                             |
| :----------: | :----------------------------------------------------------: |
|    table     |                             表名                             |
|  Non_unique  |                 是否不唯一,0:唯一,1:不为唯一                 |
|   key_name   |                          索引的名称                          |
| Seq_in_index |                   索引中的列序列号,从1开始                   |
|  Collation   | 列以什么方式存储在索引中,在MySQL中,有值'A'(升序)或NULL(无分类) |
| Cardinality  | 索引中惟一值的数目的估计值。通过运行analyze table或myisamchk -a 可以更新。基数根绝被存储为整数的统计数据来计数，所以即使对于小型表，该值也没有必要是精确的，基数越大，当进行联合时，MySQL使用索引的机会就越大 |
|   Sub_part   | 如果列只是被部分地编入索引，则为被编入索引的字符的数目。如果整列被编入索引,则为null |
|    Packed    |       指示关键字如何被压缩。如果没有被压缩，则为NULL。       |
|     Null     |     如果列含有NULL，则含有YES。如果没有，则该列含有NO。      |
|  Index_type  |          用过的索引方法(btree,Fulltext,hash,rtree)           |
|   Comment    |                          更多评注。                          |



### 2.4 查看索引

在指定的字段上建立了索引,那么使用的话就正常查询就会使用索引,比如就拿上面已经创建了索引,那我们建立索引如何查看索引呢?就可以在查询的语句前面增加`explain`查看SQL语句的执行计划:

比如:

```mysql
explain select sal from emp where sal > 1500;
```

![image-20210818111324027](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210818111324027.png)

而在条件中sal>1500使用了索引

说明:假如我们要查找sal大于1500的所有行，那么可以扫描索引，索引时排序的，结果得出7行，我们知道不会再有匹配的记录，可以退出了。如果查找一个值，它在索引表中某个中间点以前不会出现，那么也有找到其第一个匹配索引项的定位算法，而不用进行表的顺序扫描（如二分查找法）。这样，可以快速定位到第一个匹配的值，以节省大量搜索时间。数据库利用了各种各样的快速定位索引值的技术，通常这些技术都属于DBA的工作。

查看一个表中所有的索引:

```mysql
show index from emp;
```



### 2.5 删除索引

如:

```mysql
1. DROP INDEX index_name ON talbe_name
2. ALTER TABLE table_name DROP INDEX index_name
3. ALTER TABLE table_name DROP PRIMARY KEY
```

其中，前两条语句是等价的，删除掉table_name中的索引index_name。

第3条语句只在删除PRIMARY KEY索引时使用，因为一个表只可能有一个PRIMARY KEY索引， 

实战:

ALTER TABLE EMP DROP INDEX test_index;

![image-20210818111613181](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210818111613181.png)

这里删除了执行就会从全表扫描!

### 2.6 索引的添加时机

添加索引也不能乱加,也就是说不能每个字段都要添加索引,那么就会导致性能变差!

那我们就会经常思考什么时候添加索引呢?

1. 较频繁的作为查询条件的字段应该创建索引
2. 重复太多的字段不适合单独创建索引，即使频繁作为查询条件 
3. 不会出现在WHERE子句中的字段不应该创建索引

**注意:**主键会自动添加索引,所以推荐尽量根据主键查询效率较高

以下两种情况不建议使用索引:

1. 表的记录比较少,比如只有几百,一千条记录,那么没必要建立索引,直接全表扫描即可!

2. 不重复的字段越多,那么索引的价值就越高,查看不重复的字段占总体的比例可以使用下面的sql语句

   ```mysql
   select count(distinct(name)) / count(*) as Selectivity from index_test
   ```

   表示name字段中不重复的值占整体的比例,这个比例在(0,1]之间,这个数值越大,那么就越该使用索引

> 在程序中如果访问较慢,并且遇到瓶颈问题,那么首先应该思考是否是程序的算法问题,那么在考虑再针对查询次数较高的字段建立索引

### 2.7 索引的分类

#### 2.7.1 功能划分:

- 主键索引:一张表只能有一个主键索引，不允许重复、不允许为 NULL；

  ```mysql
  ALTER TABLE TableName ADD PRIMARY KEY(column_list); 
  ```

- 唯一索引：数据列不允许重复，允许为 NULL 值，一张表可有多个唯一索引，索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。

  ```mysql
  CREATE UNIQUE INDEX IndexName ON `TableName`(`字段名`(length));
  # 或者
  ALTER TABLE TableName ADD UNIQUE (column_list); 
  ```

- 普通索引：一张表可以创建多个普通索引，一个普通索引可以包含多个字段，允许数据重复，允许 NULL 值插入；

  ```mysql
  CREATE INDEX IndexName ON `TableName`(`字段名`(length));
  # 或者
  ALTER TABLE TableName ADD INDEX IndexName(`字段名`(length));
  ```

- 全文索引：它查找的是文本中的关键词，主要用于全文检索

#### 2.7.2 按列数划分:

- 单例索引：一个索引只包含一个列，一个表可以有多个单例索引。
- 组合索引：一个组合索引包含两个或两个以上的列。查询的时候遵循 mysql 组合索引的 “最左前缀”原则，即使用 where 时条件要按照建立索引的时候字段的排列方式放置索引才会生效。

#### 2.7.3 按物理区分:

##### 2.7.3.1 聚簇索引:

```mysql
一般来说索引就是如B-树这类可以来存储键值方便快速查找的数据结构
```

聚簇索引是物理索引，数据表就是按顺序存储的，物理上是连续的。一旦创建了聚簇索引,表中的所有列都根绝构造聚簇索引的关键列来存储

**理解:**所有的记录行都根据聚簇索引顺序存储,如按照主键id递增方式一次物理顺序存储

**注意:**因为聚簇索引是按照该列的排序存储的,因此一个表只能由一个聚簇索引

在MySQL中的InnoDB表中的聚簇索引:

```mysql
每个InnoDB表中都需要一个聚簇索引,该聚簇索引能够快速定位记录行实现表优化增删改查操作。
1.如果为表定义一个主键那么MySQL将使用主键作为聚簇索引
2.如果不为表定义一个主键,那么MySQL将第一个组成列的not null的唯一索引作为聚簇索引
3.如果InnoDB表没有主键且没有适合的唯一索引(没有构成该唯一索引的所有列都not null),MySQL将自动创建一个隐藏的名字为"GET_CLUST_INDEX"的聚簇索引。
```

总结：每个InnoDB引擎中的表都会有一个且仅有一个聚簇索引

自我理解:

```mysql
聚集索引的意思可以理解为顺序排列，比如一个主键自增的表即为聚集索引，即id为1的存在于第一条，id为2的存在于第二条...假使数据库中是使用数组来存放的这张表中的数据，那么如果我需要查找第100条，那么直接第一条数据的地址加上100即为第一百条的地址，一次就能查询出来。 因为数据库中的数据只能按照一个顺序进行排列，所以聚集索引一个数据库只能有一个。在mysql中，不能自己创建聚集索引，主键即为聚集索引，如果没有创建主键，那么默认非空的列为聚集索引，如果没有非空的列那么会自动生成一个隐藏列为聚集索引。 所以一般在mysql中，我们创建的主键即为聚集索引，数据是按照我们的主键顺序进行排列。所以在根据主键进行查询时会非常快。
```



##### 2.7.3.2 非聚簇索引(辅助索引)

除了聚簇索引以外的都叫非聚簇索引

**理解:**也就是我们常说的联合索引,也就是说除了id主键以外的字段加了索引就称非聚簇索引

**注意:**在InnoDB存储引擎中,每个非聚簇索引的每条记录都包含主键,也包含非聚簇索引指定的列

自我理解:

```mysql
非聚集索引可以简单理解为有序目录，是一种以空间换取时间的方法。举个例子，在一个user表中，有一个id_num，即身份号，此不为主键id，那么这些数据在存储的时候都是无序的，比如 id为1的id_num为100，id为2的id_num为97，id为3的id_num为98，id为4的id_num为99，id为5的id_num为96。。。id为67的id_num为56。。。 那么如果我要查找id_num为56的人，那么只能一条一条的遍历，n条就需要查询n次，时间复杂度为O(n)，这是非常耗费性能的。所以，现在就需要为id_num增加非聚集索引，添加了非聚集索引后，会给id_num进行排序（内部使用结构为B+树），并且排序后，我只需要查询此目录(即查询B+树)，很快就知道为id为56的在数据库中的第67条，而不需要在去遍历表中的所有数据。
所以，在非聚集索引中，不重复的数据越多，那么索引的效率越高。
```

## 3.索引的优缺点

优点:

1. 索引大大减少了服务器需要扫描的数据量,从而大大加快数据的检索速度,这也是创建索引的主要的原因

2. 索引可以帮助服务器避免排序和创建临时表

3. 索引可以将随机IO变成顺序IO

4. 索引对于InnoDB(对索引支持行级锁)非常重要,因为它可以让查询锁更少的元组,提高了表访问并发性

   ```
   扩展:
   	在MySQL5.1和更新的版本中,InnoDB可以在服务器端过滤掉行后释放锁,但在早期的MySQL版本中,InnoDB直到服务提交时才会解锁,对不需要的元组的加锁,会增加锁的开销,降低并发性。
   InnoDB仅对需要访问的元组加锁,而索引能够减少InnoDB访问的元组数。但是只有在存储引擎层过滤掉那些不需要的数据才能达到这种目的,一旦索引不允许InnoDB那样做(即索引达不到过滤的目的),MySQL服务器只能对InnoDB返回的数据进行WHERE操作，此时，已经无法避免对那些元组加锁了。如果查询不能使用索引，MySQL会进行全表扫描，并锁住每一个元组，不管是否真正需要。
   ```

5. 关于InnoD、索引和锁:InnoDB在二级索引上使用共享锁(读锁),但访问主键索引需要排它锁(谢锁)

6. 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。

7. 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。

8. 在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。

9. 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。

缺点:

1. 虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存索引文件。
2. 建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在一个大表上创建了多种组合索引，索引文件的会膨胀很快。
3. 如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。
4. 对于非常小的表，大部分情况下简单的全表扫描更高效；



> MySQL里同一个数据表里的索引总数限制为16个。

## 4.索引结构

索引结构又称索引存储类型,而试想索引在MySQL是如何被运作起来的,在mysql中使用最广泛的数据引擎是InnoDB 引擎，它里面用的是 B+ 树索引。

而谈到B+树那你关于树的概念应该也是模糊的,那么我们来看一下树的演化过程:

首先从二叉查找树开始说:

### 4.1 二叉查找树



![img](https://gitee.com/miawei/pic-go-img/raw/master/imgs/77094b36acaf2edda159cae178c5cbef3801936e.jpeg)

以上这种就是一颗二叉查找树!

**特点:**

1. 每个节点最多只有两颗子节点
2. 每个左节点小于根节点,右节点大于根节点
3. 没有值相等的节点,最顶端的节点"20"也称根节点,

**二叉查找树的查找过程:**

首先从根节点开始找,若根节点的值等于查找的值那么就直接返回成功,否则就判断若小于根节点的值,递归查左子树(也就是根节点左边的所有树),反之若大于根节点的值,则递归查右子树(也就是根节点右边所有节点形成的树)

**实战:**

假设用二叉树来创建book表的索引:

![img](https://gitee.com/miawei/pic-go-img/raw/master/imgs/v2-97374ea7ae2d24475e6af59994c8c2c3_720w.jpg)

然后在mysql底层中索引就应该是这样子的:

![preview](https://pic3.zhimg.com/v2-7593f8a420f89150391784fd739bfd3c_r.jpg?source=1940ef5c)

过程:

此处bid为主键,每个节点存储了主键的值和该条记录的内容,如果我们要查找bid为6的图书的信息,则先用6和根节点的主键值7比较,然后发现比7小,那么就会去跟7左边的节点的5进行比较,此时又会发现比5大然后找到5右边的节点6,然后与此匹配,发现匹配上了成功了,然后取出6对应的记录行的值"ee";

**总结:**总共经历了3次比较,如果扫描全表需要经过5次比较

那么看出二叉树的特点:

1. 二叉树的时间复杂度为O(n)



但是普通的二叉查找树有个致命缺点：极端情况下会退化为线性链表，二分查找也会退化为遍历查找，时间复杂退化为 O（N），检索性能急剧下降。比如以下这个情况，二叉树已经极度不平衡了，已经退化为链表了，检索速度大大降低。此时检索 id=12 的数据的所需要计算的次数已经变为 6 了。

![图片](https://gitee.com/miawei/pic-go-img/raw/master/imgs/640)

在数据库中，数据的自增是一个很常见的形式，比如一个表的主键是 id，而主键一般默认都是自增的，如果采取二叉树这种数据结构作为索引，那上面介绍到的不平衡状态导致的线性查找的问题必然出现。因此，简单的二叉查找树存在不平衡导致的检索性能降低的问题，是不能直接用于实现 Mysql 底层索引的。

二叉树中，有一种特殊的结构——平衡二叉树，平衡二叉树的特点：

1. 根节点会随着数据的改变而变更
2. 数据量越多，遍历次数越多，IO次数就越多，就越慢（磁盘的IO由树高决定）
3. 左右子树的高度差不能超过1，如果插入数据导致高度差超过了1则自动进行调整，回复到平衡状态。

### 4.2 B树

B-树通常意味着所有的值都是按顺序存储的，并且每一个叶子页到根的距离相同，很适合查找范围数据。

B-Tree可以对<，<=，=，>，>=，BETWEEN，IN，以及不以通配符开始的LIKE使用索引。

B树又称B-树,是多路搜索树,不会遵从二叉树那样每个节点最多只有两个节点;其中树高一层意味着多一次的磁盘I/O;下面是3阶B树

![img](https://pic3.zhimg.com/v2-f139d2b402e7def56e8bf4bc44a279ab_r.jpg?source=1940ef5c)

从上图可以看出跟二叉树的区别,二叉树极有可能造成单向节点一直延伸造成树越来越高,而是用B-树,一眼就能看出树变得又矮又胖,矮胖的数是索引的最爱,用它做索引可以降低磁盘的IO

B-树节点主要是:键值、数据、指针;

解读:一个节点上有两个升序排列的键值和三个指向子树根节点的指针,指针存储的是子节点所在的磁盘块的地址,两个键值划分的三个范围域对应三个指针指向的子树的数据的范围与,以根节点为例,键值为17和35,P1指针指向的子树的数据范围为小于17.P2指针指向的子树的数据范围为17~35,P3指针指向的子树的数据范围为大于35

**模拟查找关键字29的过程:**

1. 根据根节点找到磁盘块1,读入内存。[磁盘I/O操作第1次]
2. 比较关键字29区间（17,35），此时在这个区间内，然后找到磁盘块1的指针P2
3. 根据P2指针找到磁盘块3，读入内存。【磁盘I/O操作第2次】
4. 比较关键字在29区间（26,30），找到磁盘块3的指针P2
5. 根据P2指针找到磁盘块8，读入内存【磁盘I/O操作第3次】
6. 在磁盘块8中的关键字列表中找到关键字29

分析：找到指定关键字可以发现3次磁盘I/O操作，和3次内存查找操作，由于内存中的键值是一个有序表结构，可以利用二分查找提高效率，而3次磁盘I/O操作是影响整个B树查找效率的决定因素

B树的特征:

- 关键字结合分布在整棵树中;
- 任何一个关键字出现且出现在一个节点中;
- 搜索有可能在非叶子节点结束;
- 其搜索性能等价于在关键字全集内做一次二分查找;
- 自动层次控制;

### 4.3 HASH

Hash 索引是比较常见的一种索引，他的单条记录查询的效率很高，时间复杂度为1。但是，Hash索引并不是最常用的数据库索引类型，尤其是我们常用的Mysql Innodb引擎就是不支持hash索引的。主要有以下原因：哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可立刻定位到相应的位置，速度非常快。

![在这里插入图片描述](https://gitee.com/miawei/pic-go-img/raw/master/imgs/2021013023265936.png)

**注意:**Hash索引适合精确查找,但是范围不适合;

**理由:**因为存储引擎都会为每一行计算一个hash码，hash码都是比较小的，并且不同键值行的hash码通常是不一样的，hash索引中存储的就是Hash码，hash 码彼此之间是没有规律的，且 Hash 操作并不能保证顺序性，所以值相近的两个数据，Hash值相差很远，被分到不同的桶中。这就是为什么hash索引只能进行全值匹配的查询，因为只有这样，hash码才能够匹配到数据。

也就是说hash索引仅仅满足"=","in"查询,不能进行范围查询,例如使用between..and...或者where price>100

由于Hash索引比较的是进行Hash运算之后的Hash值，所以它只能用于等值的过滤，不能用于基于范围的过滤，因为经过相应的Hash算法处理之后的Hash值的大小关系，并不能保证和Hash运算前完全一样。

### 4.4 B+树

在B树中每个节点的内容由三部分组成：键值，指针，数据，而磁盘块的容量是有限的，并不是每次读取磁盘块都会取出里面的数据，只是在最后一次读取的时候才会取出里面的数据，能不能将数据只存储在叶子节点里面，非叶子节点只存储键值和指针呢？这样就能最大化的利用磁盘块空间，一个磁盘块也就能存更多的东西了，没错，B+树就是这么干的；

说明:在MySQL中最常用的索引结构是B+树

![img](https://gitee.com/miawei/pic-go-img/raw/master/imgs/v2-08af8e0c98d5ddfad6bf89ec6158a646_r.jpg)

假设在非叶子节点不存数据以后每个节点可以存储4个键值和指针，就变成了上图的B+树

B+树相对于B树有几点不同：

1. 非叶子节点只存储键值和指针
2. 所有叶子节点之间都有一个链指针
3. 数据记录都存放在叶子节点中，

在B+树中因为叶子节点的键值是按顺序排列的所以进行键值的范围查找效率非常高。

在B+树中由于一个节点存储了更多的键值和指针，所以同样多的内容可以降低树的高度，减少磁盘io次数，从而提高效率。

数据库的索引分为聚集索引和非聚集索引，innoDb存储引擎中的聚集索引表中的数据按主键的顺序存放，它实际上就是按主键构建的一个B+树，叶子节点存放的是数据行记录。所以数据库中的数据实际上是索引的一部分。由于实际的数据页只能按照一个顺序存放，所以每张表聚集索引只能有一个。

非聚集索引的叶子节点中存放的是键值和主键值，所以通过非聚集索引需要先查找到主键值然后通过聚集索引查询到具体的数据，因此非聚集索引的效率要低于聚集索引。非聚集索引并不会影响到数据的存储顺序，所以非聚集索引可以存在多个。

B+树的特点:

1. 在 B+ 树中，所有数据记录节点都是按照键值的大小存放在同一层的叶子节点上，而非叶子结点只存储key的信息，这样可以大大减少每个节点的存储的key的数量，降低B+ 树的高度
2. B+ 树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针。
3. B+ 树的层级更少：相较于 B 树 B+ 每个非叶子节点存储的关键字数更多，树的层级更少所以查询数据更快
4. B+ 树查询速度更稳定：B+ 所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;
5. B+ 树天然具备排序功能：B+ 树所有的叶子节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高
6. B+ 树全节点遍历更快：B+ 树遍历整棵树只需要遍历所有的叶子节点即可，，而不需要像 B 树一样需要对每一层进行遍历，这有利于数据库做全表扫描。

#### 4.4.1 主键目录

由于在mysql底层默认使用的是InnoDB存储引擎,而存储引擎使用的是B+树的存储结构,我们把上面那张图优化一下再来看:

![img](https://mmbiz.qpic.cn/mmbiz_png/6fuT3emWI5ISibSFH1YZZWuNSO1ceb6mpc9D0jExUqUU3r3ibCWHB0QTtB0pKfKzlGBbKDt8tAHTu0yztiaRtiahoA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

这里所谓的主键目录也就是非叶子节点,然后数据页就是叶子结点,叶子结点之间有双向链表衔接,而非叶子节点有指针指向叶子节点中

**说明:**我们都知道 MySQL 在存储数据的时候是以**数据页**为最小单位的，且数据在数据页中的存储是**连续**的，数据页中的数据是按照主键排序的（没有主键是由 MySQL自己维护的 ROW_ID 来排序的），数据页和数据页之间是通过**双向链表**来关联的，数据与数据时间是通过**单向链表**来关联的。

回到MySQL中在每个数据页中，他必然就有一个最小的主键，然后每个数据页的页号和最小的主键会组成一个**主键目录**（就像上图中的左边部分），

```
假设现在要查找主键为 2 的数据，通过二分查找法最后确定下主键为 2 的记录在数据页 1 中，此时就会定位到数据页 1 接着再去定位主键为 2 的记录，
```



#### 4.4.2 索引页

上面只是建立起一种存储概念,那么试想如果在数据库中的某一张表有1000万条数据,也就是说有1万条数据页,那主键目录不就很大很大吗?就算使用二分查找那么也会导致效率过慢,所以为了解决这种问题 MySQL 又设计出了一种新的存储结构—**索引页**。

![图片](https://mmbiz.qpic.cn/mmbiz_png/6fuT3emWI5ISibSFH1YZZWuNSO1ceb6mpHylfuSL7MYLNxMuFr91PXXSPBEQooZzfYQkMfCicqPL2uQDw2YMkRvw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

假设上面的主键目录中的记录是非常非常多的，此时上面的结构是演变成这样子的，MySQL 会将里面的记录拆分到不同的索引页中，也就是下面这样子的:

![图片](https://mmbiz.qpic.cn/mmbiz_png/6fuT3emWI5ISibSFH1YZZWuNSO1ceb6mpaUdgYfO36eibBwmbN5lMC6I11ASLZU7NN02CJzBiaic8aicsZ8HNUeQEyQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

从图中看出这个索引页很像数据页,不过这个索引页跟数据页类似,一张存储不够就分裂为两张,但是光分裂是不够的的,还得去维护索引页,就好比现在我要查询id=20,我不知道在那张索引页去查找,那么MySQL 同时也设计出了用于维护索引页的数据结构，其实也还叫**索引页**，只不过他们是在不同的层级，类似下面这样子的：

![图片](https://mmbiz.qpic.cn/mmbiz_png/6fuT3emWI5ISibSFH1YZZWuNSO1ceb6mp29ia18SjavcPkIodQp9vYe3EbHOWu52t8qzzJEbPtDKDFBkibdYZVp0A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

也就是说**维护索引页的索引页**是在真正**存储记录和数据页的索引页**的上一层，现在如果你想查找 id=20 的这条记录，那就是从最上层的索引页开始查找，通过二分法查找，很快就能够定位到 id=20 s这条记录是在索引页 2 上，然后到就索引页 2 上面查找，接着就是和之前一样了（注意，索引页中的记录也是通过单向链表连接的），根据各个最小的主键能够定位到 id=20 是在数据页5上，假设数据页5是这样子的

![图片](https://mmbiz.qpic.cn/mmbiz_png/6fuT3emWI5ISibSFH1YZZWuNSO1ceb6mpPnWl9zzvH7HXrDTxgiaMaGgJ4ZXFqmiaP9ZTDGrsuYem5shaa2Rz9M3g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

```
理解:
	在B+树中叶子节点存储的是数据页,每个叶子结点之间都有双向链表连接,这也对应了数据页与数据页之间的联系,而非叶子节点对应着索引目录,存储的是对应数据页的最小主键和数据页,不过这样随着数据量大慢慢演化成索引页,而索引页则理解为另一个版本的主键目录,可以分裂为多个索引目录,不过太多了为了方便管理就升级了一个索引页的管理结构,也就是专门存储每个索引页的最小主键和对应的索引页,这样就算使用二分查找,那么也能快速定位到指定的索引页然后指定的数据页中指定的记录
```

#### 4.4.3 索引分层

索引分层就是把索引页不断的分裂升级管理成新的索引页:如下图:

![图片](https://mmbiz.qpic.cn/mmbiz_png/6fuT3emWI5ISibSFH1YZZWuNSO1ceb6mpanT3Hzm6P2okPHIRjzPeRaiaJrTcpcdWUxp8aicWfO1JA5RKQnB2pjbQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

这样的结构是否让你想起B+树的结构呢,这个索引分层就是将管理索引页继续分裂为新的索引页,这样的好处就是说让这个范围逐渐变短,减少查询次数

模拟查询查询过程:

```
现在我们要查找id为37这条记录:
	首先我们是根本不知道具体的记录在哪里!然后我们模拟从最顶层的索引页开始查找:因为id=37,37不在索引页20的最小主键范围之内,所以由此定位到索引页16,然后将主键id=37进行二分查找.由此定位到 id=37 在索引页 3 中，然后继续查找，最终能够定位到数据实在数据页 8 中.
```

假设数据页 8 是这样子的:

![图片](https://mmbiz.qpic.cn/mmbiz_png/6fuT3emWI5ISibSFH1YZZWuNSO1ceb6mplDfj1WaHBTYq0UZwP19sPaNwQjqibwlkxcHlpSibbNTRzTVjsGJIUaOw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

#### 4.4.4 总结

再来一张完整结构图来演示,但是链表结构太大就暂时不演示:

![图片](https://mmbiz.qpic.cn/mmbiz_png/6fuT3emWI5ISibSFH1YZZWuNSO1ceb6mphhJn6cg1INQzYy2EWmQ2sNX1rb5OMSUibkNXwFpbfDka1QEqNoqvCEw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

```
总结:
	不看数据页就看上面的索引页,就有点像二叉树,而这实际上是一颗B+树的数据结构,这也是数据在磁盘中真正存储的物理结构
```

B+树的特性:

​	B+树也是属于二叉搜索树的一种,但是他的数据仅仅存储在叶子结点(在这里就是数据页),像这种**索引页+数据页**组成的B+树就是**聚簇索引**

> 聚簇索引是MySQL基于主键索引结构创建的!

#### 4.4.5非主键索引

上面强调的是**主键索引**,那么在实际开发中难免也会增加其他字段为索引,假设你现在对name、age建立索引!

```mysql
主键索引在 insert数据的时候是会基于主键的顺序去维护一个B+树,而非主键索引原理跟主键索引是一样的,MySQL底层都是去维护一颗B+树
```

理解:说白了就是你建立多少个索引,MySQL底层就会帮你维护多少颗树

> 这也侧面说明了之前说为什么索引不能建太多会占用空间,这就是原因

假如现在真的对 name+age 建立索引，那此时是存放的呢？此时 MySQL 根据会 name+age 维护一个单独的 B+ 树结构，数据依旧是存放在数据页中的，只不过是原来数据中的每条记录写的是 id=xx，现在写的是name=xx，age=xx，id=xx，不管怎么样，主键肯定会存放的，先来张图压压惊:

![图片](https://mmbiz.qpic.cn/mmbiz_png/6fuT3emWI5ISibSFH1YZZWuNSO1ceb6mpJtzA0JcEnmN3fjlYPDqgicDODKnOTAkCUHYc0gbsDUcYaNWUDTfnnNg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

在插入数据的时候，MySQL 首先会根据 name 进行排序，如果 name 一样，就根据联合索引中的 age 去排序，如果还一样，那么就会根据 主键 字段去排序。插入的原理就是这样子的:

```mysql
此时每个数据页中的记录存放的实际是索引字段和主键字段，而其他字段是不存的（为什么不存放？一样的数据到处存放很浪费空间的，也没必要，所以才会有下面的索引优化），至于查找，原理和过程跟聚簇索引一样，这里就不再赘述，但是，下面说的内容却是至关重要的：假设现在执行这样的SQL：
SELECT name FROM student WHERE name='wx'
```

表示:现在要根据 name 查找到该条记录，且查询的字段（即 select 后面的查询字段）也仅仅有 name（只要是在 name,age,id 这三个字段中都可以）这个时候是能够直接获取到最终的记录的

换句话说，因为联合索引中的记录也仅仅有 name，age，id，所以在查询的如果也仅仅查询这三个字段，那么在该B+树中就能够查询到想要的结果了。

##### 4.4.5.1 维护过程

MySQL对于非主键索引的维护过程:

```mysql
对于非主键索引(一般都是联合索引),在维护B+树的过程中的时候会根据索引的字段依次去判断,比如我们现在假设联合索引为: name+address+age,那么MySQL在维护该索引的B+树的时候,首先会根据name进行排序,name相同的话根据第二个address排序,如果此时address也是一样的,那么就会根据age去排序,如果age也一样,那么就会根绝主键字段值去排序,且对于非主键索引,MySQL在维护B+树的时候,仅仅是维护索引字段和主键字段
```



#### 4.4.6 回表

回表就是SQL语句中使用了索引查询但是select语句后查询的字段并不是索引字段,这个时候就称**回表**;

比如:其中增加索引字段为name、age,id为主键,并且还有其他字段;

```mysql
SELECT * FROM student WHERE name='wx'
```

说明:这种就有问题了,虽然我么可以通过name快速定位到这条记录,但是因为name+age不是聚簇索引,此时的B+树中的数据页存放的仅仅是自己关联的索引和主键索引字段,并不会存放其他字段,所以这个时候其他的属性值是获取不到的,那这个怎么办呢?

**回表**就呼之欲出了:此时MySQL就会根绝定位到的某条记录中的id再次进行聚簇索引查找,也就是说会根据id去维护id的那么B+树中查找,因为聚簇索引中数据页记录的是一条记录的完整的记录,这个过程就叫回表;

**回表的含义:**根据非主键索引查询到的结果并没有查找的字段值,此时就需要再次根据主键从聚簇索引的根节点开始查找,这样再次查找到的记录才是完成的! 

![img](https://gitee.com/miawei/pic-go-img/raw/master/imgs/20210206194334864.png)

#### 4.4.7 B+树的一个节点的高度

B+树一个节点的大小设为一页或页的倍数最为合适。因为如果一个节点的大小 < 1页，那么读取这个节点的时候其实读取的还是一页，这样就造成了资源的浪费。
在 MySQL 中 B+ 树的一个节点大小为“1页”，也就是16k。之所以设置为一页，是因为对于大部分业务，一页就足够了：
首先InnoDB的B+树中，非叶子节点存的是key + 指针；叶子节点存的是数据行。

```
对于叶子节点，如果一行数据大小为1k，那么一页就能存16条数据；对于非叶子节点，如果key使用的是bigint，则为8字节，指针在mysql中为6字节，一共是14字节，则16k能存放 16 * 1024 / 14 = 1170 个索引指针。于是可以算出，对于一颗高度为2的B+树，根节点存储索引指针节点，那么它有1170个叶子节点存储数据，每个叶子节点可以存储16条数据，一共 1170 x 16 = 18720 条数据。而对于高度为3的B+树，就可以存放 1170 x 1170 x 16 = 21902400 条数据（两千多万条数据），也就是对于两千多万条的数据，我们只需要高度为3的B+树就可以完成，通过主键查询只需要3次IO操作就能查到对应数据。所以在 InnoDB 中B+树高度一般为3层时，就能满足千万级的数据存储，所以一个节点为1页，也就是16k是比较合理的。
```



### 4.5 索引存储方式

我们在建立索引的时候,MySQL中每个引擎的保存索引的方式都不一样!

索引是占据物理空间的，在不同的存储引擎中，索引存在的文件也不同。存储引擎是基于表的，以下分别使用**MyISAM**和**InnoDB**存储引擎建立两张表。

![存储引擎是基于表的，以下建立两张别使用MyISAM和InnoDB引擎的表，看看其在文件系统中对应的文件存储格式。](https://gitee.com/miawei/pic-go-img/raw/master/imgs/20210130233352294.png)

存储引擎为MyISAM:

- *frm:与表相关的元数据信息都存放在frm文件，包括表结构的定义信息等
- *.MYD：MyISAM DATA，用于存储MyISAM表的数据
- *.MYI：MyISAM INDEX，用于存储MyISAM表的索引相关信息

存储引擎为InnoDB:

- *.frm：与表相关的元数据信息都存放在frm文件，包括表结构的定义信息等
- *.ibd：InnoDB DATA，表数据和索引的文件。该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据

### 4.6索引最终选择B+树的原因:

1. hash很快，但每次IO只能取一个数
2. AVL和红黑树，在大量数据的情况下，IO操作还是太多
3. B树每个节点内存储的是数据，因此每个节点存储的分支太少
4. B+节点存储的是索引+指针(引用指向下一个节点)，可以存储大量索引，同时最终数据存储在叶子节点，并且有引用横向链接，可以在2-3次的IO操作内完成千万级别的表操作。
5. 建议索引是是自增长数字，这样适合范围查找

## 5.最左前缀原则

在MySQL建立**联合索引**时会遵守最左前缀匹配原则，即最左优先（查询条件精确匹配索引的左边连续一列或几列，则构建对应列的组合索引树），在检索数据时也从联合索引的最左边开始匹配。

```mysql
mysql> create table t(
    -> a int not null,
    -> b char(10) not null,
    -> c int not null,
    -> d varchar(20) not null,
    -> index abc(a,b,c)
    -> )engine=innodb charset=utf8;
    
mysql> insert into t values(1,'hello',1,'world');
mysql> insert into t values(2,'hello',2,'mysql');

```

![在这里插入图片描述](https://gitee.com/miawei/pic-go-img/raw/master/imgs/20210203220425543.png)

以下均为筛选条件不包含主键索引情况下：（主键索引优先级最高）

1. 只要筛选条件中含有组合索引最左边的列但不含有主键搜索键的时候，至少会构建包含组合索引最左列的索引树。（如：index(a)）

![在这里插入图片描述](https://gitee.com/miawei/pic-go-img/raw/master/imgs/20210203235249136.png)

2. 查询列都是组合索引列且筛选条件全是组合索引列时，会构建满列组合索引树（index(a,b,c) ）【覆盖索引】

![在这里插入图片描述](https://gitee.com/miawei/pic-go-img/raw/master/imgs/2021020323534787.png)

3. 筛选条件包含普通搜索键但没包含组合索引列最左键，不会构建组合索引树

![在这里插入图片描述](https://gitee.com/miawei/pic-go-img/raw/master/imgs/20210204000023867.png)

4. 如果筛选条件全是组合索引最左连续列作为搜索键，将构建连续列组合索引树。（比如：index(a,b)却不能index(a,c)）

![在这里插入图片描述](https://gitee.com/miawei/pic-go-img/raw/master/imgs/20210204000233307.png)

5. MySQL查询优化器会优化and连接，将组合索引列规则排号。（比如：b and a 等同于 a and b）

   ![在这里插入图片描述](https://gitee.com/miawei/pic-go-img/raw/master/imgs/20210203235831538.png)

## 6.前缀索引

所谓前缀索引就是针对字段的前几个字符作为前缀索引,使检索速度得到极大的优化

有时候需要索引很长的字符列，这会让索引变得大且慢。通常可以以某列开始的部分字符作为索引，这样可以大大节约索引空间，从而提高索引效率。但这样也会降低索引的选择性。索引的选择性是指不重复的索引值和数据表的记录总数的比值，索引的选择性越高则查询效率越高。

比如:

![在这里插入图片描述](https://gitee.com/miawei/pic-go-img/raw/master/imgs/20210206162724268.png)

不使用索引查询某条记录:

![在这里插入图片描述](https://gitee.com/miawei/pic-go-img/raw/master/imgs/20210206162906197.png)

使用索引查询某条记录:

```mysql
alter table x_test add index(x_name(4));
```

![在这里插入图片描述](https://gitee.com/miawei/pic-go-img/raw/master/imgs/20210206163004906.png)

总结:可以对比两张图中的查询时间.虽然只差了0.02但是也是因为这里数据量太少了的缘故,如果这是百万数据量级别的数据,那么这个检索速度是肉眼可见的

> 前缀字符并非越多越好，需要在索引的选择性和索引IO读取量中做出衡量。

## 7.覆盖索引

在InnoDB中的主键索引就是聚簇索引，主键索引的查询效率也是非常高的，除此之外，还有非聚簇索引，其查询效率稍逊。覆盖索引其形式就是，搜索的索引键中的字段恰好是查询的字段（或是组合索引键中的其它字段）。覆盖索引的查询效率极高，原因在与其不用做回表查询。

**理解:**覆盖索引就是查询字段为组合索引字段并且筛选条件也是组合索引字段,就是两者都是一个组合索引字段中的字段,那么就称覆盖索引!可以通过explain查询执行计划看Extra是否是Using index

直接看图:

```mysql
mysql> desc student;
+----------+--------------+------+-----+---------+----------------+
| Field    | Type         | Null | Key | Default | Extra          |
+----------+--------------+------+-----+---------+----------------+
| id       | int(11)      | NO   | PRI | NULL    | auto_increment |
| name     | varchar(255) | NO   | MUL | NULL    |                |
| c_id     | int(11)      | YES  |     | NULL    |                |
| phone    | char(11)     | YES  |     | NULL    |                |
| guardian | varchar(50)  | NO   |     | NULL    |                |
+----------+--------------+------+-----+---------+----------------+
```

最直观的呈现：（通过explain执行分析SQL可观测到Extra字段值包含Using index）:

![在这里插入图片描述](https://gitee.com/miawei/pic-go-img/raw/master/imgs/20210206191658155.png)

当然对于组合索引你还可以查询组合索引键中的其他字段：

![在这里插入图片描述](https://gitee.com/miawei/pic-go-img/raw/master/imgs/20210206192402549.png)

但是不能包含杂质搜索键（不属于所搜索索引中的列）:

![在这里插入图片描述](https://gitee.com/miawei/pic-go-img/raw/master/imgs/20210206192553447.png)





## 8.全文索引

通过数值比较、范围过滤等就可以完成绝大多数我们需要的查询，但是，如果希望通过关键字的匹配来进行查询过滤，那么就需要基于相似度的查询，而不是原来的精确数值比较。全文索引，就是为这种场景设计的，通过建立**倒排索引**,可以极大的提升检索效率,解决判断字段是否包含的问题。

**理解:**全文索引跟我们常用的`like`模糊查询是一样的,说白了就是所有记录中包含某个关键字的记录来进行匹配

那如何进行选择呢?

​	在一些小文本,数据量少的时候可以用`like+%`来进行模糊搜索,但是对于大量的文本检索那么就需要使用全文索引,执行效率杠杠滴!前者使用的全表扫描,而后者顾名思义就是使用索引来进行检索!

注意:

1. MySQL 5.6 及以后的版本，MyISAM 和 InnoDB 存储引擎均支持全文索引;之前只有只有 MyISAM 存储引擎支持全文索引；
2. 只有字段的数据类型为 char、varchar、text 及其系列才可以建全文索引

> nnoDB内部并不支持中文、日文等，因为这些语言没有分隔符。可以使用插件辅助实现中文、日文等的全文索引。

创建语法:

```mysql
//建表的时候
FULLTEXT KEY keyname(colume1,colume2)  // 创建联合全文索引列

//在已存在的表上创建
create fulltext index keyname on xxtable(colume1,colume2);

alter table xxtable add fulltext index keyname (colume1,colume2);
```

使用:

全文索引有独特的语法格式，需要配合match 和 against 关键字使用

- match()函数中指定的列必须是设置为全文索引的列
- against()函数标识需要模糊查找的关键字

```mysql
 create table fulltext_test(
     id int auto_increment primary key,
     words varchar(2000) not null,
     artical text not null,
     fulltext index words_artical(words,artical)
)engine=innodb default charset=utf8;

insert into fulltext_test values(null,'a','a');
insert into fulltext_test values(null,'aa','aa');
insert into fulltext_test values(null,'aaa','aaa');
insert into fulltext_test values(null,'aaaa','aaaa');
```

执行:

```mysql
select * from fulltext_test where match(words,artical) against('a');
select * from fulltext_test where match(words,artical) against('aa');
select * from fulltext_test where match(words,artical) against('aaa');
select * from fulltext_test where match(words,artical) against('aaaa');
```

对应执行效果:

![image-20210820095142892](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210820095142892.png)

### 8.1 长度阈值

看到了上图的执行效果你也应该想到了为什么我搜索"a"和"aa"搜索不到了,这是因为在InnnoDB执行引擎里的搜索长度问题;

我们执行`show variables like '%ft%';`来看:

```mysql
show variables like '%ft%';
```

![image-20210820095353799](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210820095353799.png)

其中name为"innodb_ft_min_token_size"表示InnoDB引擎使用全文检索的最小长度为3,那么这也说明了为什么使用"a"却搜索不出来的原因了

那如果你就只想搜索一个怎么办?那么就只能修改InnoDB的配置文件,才可以:

1. 修改配置文件

   ```mysql
   [mysqld]
   innodb_ft_min_token_size = 5
   ft_min_word_len = 5
   ```

2. 重启MySQL服务器,还要修复索引，不然参数不会生效

   ```mysql
   repair table 表名 quick;
   ```

   

### 8.2 自然语言全文索引

在介绍自然语言模式之前我们应该思考为什么使用全文索引搜索"aaa",查询出来的可只有一条记录,按照我们之前使用`like+%`的习惯,就应该出现两条记录,对吧?

**概念:**在默认情况下全文索引使用的是自然语言模式,当然也可以指定自然语言,使用`IN NATURAL LANGUAGE MODE`修饰符可显示指定,其中`match()`函数对文本集合执行自然语言搜索

**查询规则:**自然语言搜索引擎将计算每一个文档对象和查询的相关度。这里，相关度是基于匹配的关键词的个数，以及关键词在文档中出现的次数。在整个索引中出现次数越少的词语，匹配时的相关度就越高。MySQL在全文查询中会对每个合适的词都会先计算它们的权重，如果一个词出现在多个记录中，那它只有较低的权重；相反，如果词是较少出现在这个集的文档中，它将得到一个较高的权重。

**注意:**MySQL默认的阀值是50%。如果一个词语的在超过 50% 的记录中都出现了，那么自然语言的搜索将不会搜索这类词语。

所以上面搜索的关键字长度为3,正常查询出来的记录数为2条,如"aaa","aaaa",其中搜索关键字"aaa"匹配成功次数2/2=100%,这时已经超过了默认的阈值50%,所以说现在就开始精确查找"aaa"了,

演示一下显示指定的用法:

```mysql
select * from fulltext_test where match(words,artical) against('aaa');
等价
select * from fulltext_test where match(words,artical) against('aaa'  IN NATURAL LANGUAGE MODE);
```

### 8.3 布尔全文索引

这个索引功能比较强大,相当于可以自定义搜索,也就是说使用一些操作符来进行匹配关键词在结果中的包含情况:

使用表结构:

```mysql
CREATE TABLE articles (
    id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY,
    title VARCHAR(200),
    body TEXT,
    FULLTEXT (title,body)
) ENGINE=InnoDB
```

- `+`AND）全文索引列必须包含该词且全文索引列（之一）有且仅有该词

- `-` （NOT）表示必须不包含,默认为误操作符。如果只有一个关键词且使用了`-` ，会将这个当成错误操作，相当于没有查询关键词；如果有多个关键词，关键词集合中不全是负能符（`~ -`），那么`-`则强调不能出现

  ```mysql
  -- 查找title,body列中有且仅有apple（是apple不是applexx 也不是 xxapple）但是不含有banana的记录
  SELECT * FROM articles WHERE MATCH (title,body) AGAINST ('+apple -banana' IN BOOLEAN MODE);
  ```

- `>` 提高该词的相关性，查询的结果靠前

- `<` 降低该词的相关性，查询的结果靠后

  ```mysql
  -- 返回同时包含apple（是apple不是applexx 也不是 xxapple）和banana或者同时包含apple和orange的记录。但是同时包含apple和banana的记录的权重高于同时包含apple和orange的记录。
  SELECT * FROM articles WHERE MATCH (title,body) AGAINST ('+apple +(>banana <orange)' IN BOOLEAN MODE);   
  ```

- `~` 异或，如果包含则降低关键词整体的相关性

  ```mysql
  -- 返回的记录必须包含apple（且不能是applexx 或 xxapple），但是如果同时也包含banana会降低权重（只出现apple的记录会出现在结果集前面）。但是它没有 +apple -banana 严格，因为后者如果包含banana压根就不返回。
  SELECT * FROM articles WHERE MATCH (title,body) AGAINST ('+apple ~banana' IN BOOLEAN MODE);
  ```

- `*` 通配符，表示关键词后面可以跟任意字符

  ```mysql
  -- 返回的记录可以为applexx
  SELECT * FROM articles WHERE MATCH (title,body) AGAINST ('apple*' IN BOOLEAN MODE);
  ```

- 空格 表示OR

  ```mysql
  -- 查找title,body列中包含apple（是apple不是applexx 也不是 xxapple）或者banana的记录，至少包含一个
  SELECT * FROM articles WHERE MATCH (title,body) AGAINST ('apple banana' IN BOOLEAN MODE);  
  ```

- `""` 双引号，效果类似`like '%some words%'`

  ```mysql
  -- 模糊匹配 “apple banana goog”会被匹配到，而“apple good banana”就不会被匹配
  SELECT * FROM articles WHERE MATCH (title,body) AGAINST ('"apple banana"' IN BOOLEAN MODE);  
  ```

  

## 9.索引失效的大多数场景

建立表结构:

```mysql
 create table tb1(
     nid int auto_increment primary key,
     name varchar(100) not null,
     email varchar(100) not null,
     num int,
     no_index char(10),
     index(name),
     index(email),
     index(num)
)engine=innodb;
```

我这里写一个小笔记:

```mysql
type:
	ALL:全表扫描,不走索引,直接从硬盘一行一行扫描
	range:对索引列进行范围查找,
Extra:
	Using index condition:会先条件过滤索引，过滤完索引后找到所有符合索引条件的数据行，随后用 WHERE 子句中的其他条件去过滤这些数据行；
	Using where:通常来说，意味着全表扫描或者在查找使用索引的情况下，但是还有查询条件不在索引字段当中。 如果需要回表也是用这个。
	Using filesort:可理解为排序字段使用了索引
```

注意:索引字段:nid是主键索引、name和email和num是普通索引，no_index是普通字段

1. ```mysql
   like+%xx模糊查询使用索引字段,以%开头会使索引失效
   ```

   ![image-20210820104601953](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210820104601953.png)

2. ```
   对索引字段进行函数或表达式运算,那么索引将会失效
   ```

   ![image-20210820110643355](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210820110643355.png)

3. ```mysql
   or语句中前后字段没有同时都为索引
   ```

   ![image-20210820112156480](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210820112156480.png)

   说明:第一个和第二个都是采用or两边索引字段,索引依然生效,但是第三个因为no_index不是索引字段,所以导致索引失效

   注意:如果有一侧字段字段类型不一致,那么就会直接导致索引失效的

4. ```mysql
   复合索引中没有遵循最佳左前缀原则,最佳左前缀原则即要使复合索引生效，必须要先有左边的字段，再使用右边的字段时才会生效，直接使用右边的字段索引不会生效
   ```

   增加复合索引:

   ![在这里插入图片描述](https://gitee.com/miawei/pic-go-img/raw/master/imgs/20200224214350724.png)

   

   正确情况1：只使用左边字段:

   ![在这里插入图片描述](https://gitee.com/miawei/pic-go-img/raw/master/imgs/20200224214605852.png)

   正确情况2：左右字段都使用:

   ![在这里插入图片描述](https://gitee.com/miawei/pic-go-img/raw/master/imgs/20200224214425876.png)

   错误情况：只使用了右边字段:

   ![在这里插入图片描述](https://gitee.com/miawei/pic-go-img/raw/master/imgs/20200224214511376.png)

5. ```mysql
   数据类型不一致（隐式类型转换导致的索引失效）
   ```

   如果列是字符串类型，传入条件是必须用引号引起来，不然报错或索引失效。

   ```mysql
   mysql> explain select * from tb1 where name=12;
   +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
   | id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
   +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
   |  1 | SIMPLE      | tb1   | NULL       | ALL  | name          | NULL | NULL    | NULL |    3 |    33.33 | Using where |
   +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
   ```

6. ```mysql
   != 问题
   ```

   普通索引使用 `!=`索引失效，主键索引没影响。
   where语句中索引列使用了负向查询，可能会导致索引失效。
   负向查询包括：NOT、!=、<>、NOT IN、NOT LIKE等。

   ```mysql
   mysql> explain select * from tb1 where name!='Joe';
   +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
   | id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
   +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
   |  1 | SIMPLE      | tb1   | NULL       | ALL  | name          | NULL | NULL    | NULL |    3 |   100.00 | Using where |
   +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
   ```

7. ```mysql
   order by问题
   ```

   order by 对主键索引排序会用到索引，其他的索引失效

   ```mysql
   mysql> explain select * from tb1 order by name;
   +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
   | id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |
   +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
   |  1 | SIMPLE      | tb1   | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    3 |   100.00 | Using filesort |
   +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
   1 row in set, 1 warning (0.00 sec)
   
   mysql> explain select * from tb1 order by nid;
   +----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------+
   | id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra |
   +----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------+
   |  1 | SIMPLE      | tb1   | NULL       | index | NULL          | PRIMARY | 4       | NULL |    3 |   100.00 | NULL  |
   +----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------+
   ```

   

