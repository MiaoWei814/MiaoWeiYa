# 笔记

## 1.NoSQL概述

### 1.1 为什么要用NoSQL

我们现在正在处于一个大数据时代,而所谓的大数据就是指一般的数据库无法进行分析处理了!

从最开始的历史历程:

> 1、单机MySQL的年代!

这是最早的模型,用户从web端通过数据库访问层去跟数据库交互	

![image-20211009192643907](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211009192643907.png)

90年代,一个基本的网站访问量不会太大,单个数据库完全足够了!而在那个年代的时候,更多的去使用静态网页html~,所以服务器根本没有太大的压力!所以造成了我们的单机MySQL足够使用了。

思考一下？这种情况下：整个网站的瓶颈是什么？

1. 数据库数据量如果太大，一台机器放不下！MySQL存储是有限的;
2. 数据库的单表数据如果超过300万条,那么就一定要建立索引,而索引的底层使用B+Tree实现的,如果索引太大,那么也会造成一台机器内存放不下;
3. 数据库的访问量(读写混合)如果很大的话,那么这个性能也会收到影响,一个服务器承受不了;

以上这些都是在单机MySQL年代的弊端~

> 2、Memcached缓存+MySQL+垂直拆分(读写分离)

​	由于一台机器不够用的时候我们就会扩增服务器,但是我们要保证每台服务器的数据库都是一致的,所以这个时候就提出了一台机器是用于写内容的,另外的服务器用于查询,而修改内容后就会同步到另外的服务器上的数据库里去,所以我们来进行读的时候就可以去1和3里面读,写就去2号里写内容,这样的操作就叫读写分离;

​	网站80%的情况都是在读,每次都要去查询数据库的话就十分的麻烦!所以说我们希望减轻数据库的的压力,我们可以使用缓存来保证效率;缓存只要是解决读的问题,让每次用户如果访问的都是同一SQL,那么就把第一次的数据放到缓存里去,然后后面的再次访问那么就从缓存里获取!

![image-20211009194241743](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211009194241743.png)

发展过程:

1. 最早就是通过优化底层的数据结构、算法和索引的一些东西
2. 然后使用文件缓存的方式,由于文件缓存是IO操作的,并且大文件小文件都要使用IO操作也显得很麻烦
3. 推出了Memcached(当时最热门的技术)

> 3、分库分表+水平拆分+MySQL集群

​	首先从一张图可以看出:数据库服务器发生了改变,这里M:主节点 S:从节点,这里组合成了一个作战单元,也就是组合成一个小节点也是一个小集群,然后小集群就会有多个集群,而我们查询的话正常还是会走缓存,我们整个数据架构就会越来越大,而后台越来越安稳了,那么前台运行就会越来越流畅了,

​	集群怎么实现:比如说我查询一个用户信息,首先会去缓存里看看有没有,没有就去集群里查,如何查呢?首先比如这里3个集群,那么每个集群就会放置用户3分之1的用户数据,加起来就是一个完整的用户数据,而我们通过集群的一些机制就能找到数据在哪个地方,就能提高效率

![image-20211009212552436](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211009212552436.png)

本质:数据库(**读**,**写**),我们始终都在解决这个问题!

- 读:
  - 最开始单机MySQL的时候由于读写都在单机,由于并发量增大造成读的压力变大,我们使用缓存的方式来解决读的问题!

- 写:

  - 物理解决:

    - 早些年使用引擎是MyISM,有个缺点是表锁,那什么是表锁呢?比如说我在一个100万条数据的用户表中查一个数据,那么它就会把整个用户表进行锁起来,剩下的进程由于加锁了只能等待整个查询出来,就会十分的影响效率!高并发下就会出现严重的锁问题,那这个时候就开始转战Innodb!而Innodb是行锁,明显要比表锁效率高得多,行锁就是每次查询就只锁这一行而已!

  - 其他方式解决:

    - 慢慢的就开始使用分库分表来解决写的问题,比如用主从复制、集群的方式!比如说我们一个数据库里有很多表,那么我们就会将这些表按照比如订单、用户、支付不同的业务进行不同的数据库进行管理,如果一个User表里有大量的数据那么也会对字段进行拆分,后面做成了微服务!这个时候就用分库分表就来解决写的压力;

MySQL在那个年代推出了表分区,并没有让很多公司用起来!但是确实给那个年代带来了希望。同时推出了MySQL集群,很好满足了那个年代的所有需求!但是也没有解决大部分需求,因为我们现在数据已经没有那么单一了!

> 4、如今最近的年代

2010-2020十年之间，世界已经发生了翻天覆地的变化（定位，也是一种数据，音乐，热榜!)

像热榜这些动态实时刷新的数据用MySQL集群已经做不了,所以MySQL等关系型数据库就不够用了!因为数据量很多,变化很快!

MySQL有的使用它来存储一些比较大的文件:博客、图片等!就会造成数据库表很大,效率变低了!如果有一种数据库来专门处理这种数据那MySQL的压力就变得十分小(研究如何处理这些问题!),比如在大数据的IO压力下,表几乎无法更改(比如表有一亿条数据,现在增加一列,那么就要增加一亿条数据!);

> 目前一个基本的互联网项目!

从图中可知:用户并不是直接访问的数据库,而是首先访问的是企业防火墙,或者走一些路由网关,那么通过这个网关就要做一些事情就是负载均衡,然后通过负载均衡去搭上我们的服务器集群,通过DNS做一些轮询,通过服务器我们就去访问我们数据库的一些实例,还有我们的很多的服务器!   ![image-20211010090417721](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211010090417721.png)
    

> 为什么要用NoSQL!

用户的个人信息、社交网络、地理位置。用户自己产生的数据(每天都是按TB来计算的)比如用户日志等等都是爆发性的增长,都是几千万条！关系型数据库已经无法满足需求了，已经达到瓶颈了！

这个时候我们就要使用NoSQL数据库了,NoSQL可以很好的处理以上的情况! 

### 1.2 什么是NoSQL

> NoSQL=Not Only SQL(不仅仅是SQL),泛指非关系型数据库的!

关系型数据库:就好比是表格,主要以行和列来记录的	

​	随着web2.0互联网的诞生!传统的关系型数据库很难对付web2.0时代!比如web2.0的产物:音乐、视频、个人社交的一些东西这些爆发性的东西，特别麻烦！尤其是超大规模的高并发社区！而社区在那个年代一般是指网站的站长之类的，而通常网站的流量得到增长的时候就会暴露出很多难以克服的问题，那么这个时候NoSQL在当今大数据环境下发展的十分迅速.Redis是发展最快的,并且是我们必须掌握的一个技术!

​	很多的数据类型用户的个人信息、社交网络、地理位置。这些数据类型的存储不需要一个固定的格式（就是行跟列，比如我们的地理位置不应该是一个固定的格式而是一个图谱，是动态发展的！），不需要的多余的操作就以横向扩展的（用多台机器实现比如集群）！

​	NoSQL比较典型的一种表现:Map<String,Object>,其中Obeject是能装万事万物的,这个是要以键值对的形式来控制

> NoSQL特点

1. 方便扩展(数据之间没有关系,因为KV键值对简单,很好扩展!),解耦

2. 大数据量高性能(Redis一秒写8万次,读11万条数据,NoSQL的缓存记录级的,就是一个记录可以实时的被刷新,是一种细粒度的缓存,性能会比较高!)

3. 数据类型是多样型的!(不需要事先设计数据库!就是键值对形式,我们可以随取随用!如果数据量十分大的表,很多话人就无法设计了)

   


传统的RDBMS和NoSQL的区别:

1. 传统的RDBMS
   - 结构化组织(行,列)
   - 基本的结构化查询SQL
   - 数据和关系都存在单独的表中
   - 操作语言,数据定义语言
   - 严格的一致性(ACID原则)
   - 基础的事务
   - ...
2. NoSQL
   - 不仅仅是数据
   - 没有固定的查询语言
   - 存储方式多种:键值对存储、列存储、文档存储、图形数据库（社交关系就可以用）
   - 最终一致性（是有误差的，但是只要最终结果一致性就可以了）
   - CAP定理 和 BASE理论,理论完用以实践的是"异地多活",就是保证整个服务器不会宕机,一个服务器挂了不会影响其他的服务器;
   - 保证三高问题:高性能（每秒写8万次..）、高可用和高可扩展
   - ...

最大的区别:关系型数据库我们需要学习SQL语言,非关系型数据库不是固定的,并且非关系数据库有存储方式有四种,而关系型数据库只有一种都放在单独的表中,表里就只有两个东西:行跟列

**真正在公司中的实践:NoSQL+RDBMS 一起使用才是最强的!**

我们学东西不是说学怎么安装,学习一下方法如何调用,那叫学习吗?问下自己学会这个东西了吗?真正的学习就应该是从头到尾认认真真学习完每一步,学习一个新东西就应该知道这个是什么意思?干什么的,它为什么诞生了,有什么优势..

> 了解:3V+3高

大数据时代的3V:主要是描述问题的

1. 海量Volume  :海量的数据
2. 多样Variety  :每种数据库都是不一样的,有聊天信息,聊天的图片信息,地图信息,位置信息这些都是不一样的
3. 实时Velocity  :实时性!比如直播的弹幕所接收到的一种实时性

大数据时代的3高:主要是对程序的要求

1. 高并发 :用户数量的增加和访问 
2. 高可拓 :可拓展性,随时水平拆分,可以搭建集群,一台机器不够了,可以扩展机器来解决
3. 高性能 :保证咱们用户体验和性能! 

   

### 1.3 阿里巴巴网页分析

首先我们进入阿里巴巴网站上可以看到:

![image-20211010103527312](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211010103527312.png)

思考问题:这么多东西难道都是在一个数据库中的吗?

```bash
# 1. 商品信息
	名称、价格、商家信息
	关系性数据库就可以解决了！MySQL、Oracle（淘宝早些年去IOE了！-王坚，推荐文章：阿里云的这群疯子），淘宝内部的MySQL不是大家用的MySQL,因为MySQL底层是组件化的是可以进行热拔插, 所以人家根据自己的业务需求去进行改变MySQL!
	
# 2.商品的描述、评论（文字比较多）
	一般放在文档型数据库中,比如MongDB
	
# 3.图片
	分布式文件系统: FastDFS
	淘宝用自己的 TFS
	Gooale的 GFS
	Hadoop的 HDFS
	阿里云的 oss
	
# 4.商品的关键字(搜索)
	搜索引擎: solr、elasticsearch
	淘宝用的是 ISerach, -多隆(它一个人开发出来的)

# 5.商品热门的波段信息(秒杀)
	内存数据库: Redis、Tair、Memache...
	
# 6.商品的交易,外部的支付接口
	三方应用,比如支付宝接口、银行支付
```

所以说:一个简单的网页背后的技术一定不是那么的简单!

大型互联网应用问题:

1. 数据类型太多了!如果是一个电商网站那么就有这么多东西就要去处理!
2. 数据源繁多.经常重构!每个用户都可以上传自己的东西,在敏捷开发中我们就会接触实时重构这个东西!
3. 数据要改造,大面积改造! 如果改一个SQL,那么有关这个SQL的所有接口都要去改!

### 1.4 NoSQL的四大分类

**KV键值对**

不同公司的使用实现:

- 新浪:Redis
- 美团:Redis+Tair
- 阿里、百度:Redis+memecache

**文档型数据库(bson格式,和json一样只是传输功能不一样是二进制的json)**

- MongoDB
  - MongoDB是一个基于分布式文件存储的数据库,一般用于存储大量的文档,其本身是由C++编写的,主要用于处理大量的文档!
  - MongoDB是一个介于**关系型数据库**和**非关系型数据库**之间的产品!
  - MongoDB是非关系型数据库中功能**最丰富**,**最像**关系型数据库的!

- ConthDB

**列存储数据库**

- HBase
- 分布式文件系统  

**图关系数据库**

不是拿来存储图形的,是用于存储关系的,比如:朋友圈社交网络,广告推荐!

 ![image-20211010140906981](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211010140906981.png)

- Neo4j
- InfoGrid



> 四者对比!

![image-20211010141235929](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211010141235929.png)

## 2.Redis入门

### 2.1 概述

> Redis是什么?

Redis（**Re**mote **Di**ctionary **S**erver )，即远程字典服务!
	是一个开源的使用ANSI [C语言](https://baike.baidu.com/item/C语言)编写、支持网络、可基于内存亦可持久化的日志型、Key-Value[数据库](https://baike.baidu.com/item/数据库/103728)，并提供多种语言的API。

理解:首先Redis是C语言编写的,它支持网络所以我们可以通过HTTP协议来传输东西,它基于内存和持久化的,并且它还是以KV键值对的数据库,还有它提供了多种语言的API,也就是说除了Java语言以外我们可以用其他语言来调用Redis!
	redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步

**总之**:它是免费和开源的!是当下最热门的NoSQL技术之一,也被人们称之为结构化数据库!

> Redis能干嘛?

1. 内存存储、持久化，内存中是断电即失，所以持久化很重要（这里有两种机制:rdb,aof）
2. 效率高,可以用于高速缓存
3. 发布订阅系统-可以简单的做一些消息队列的功能
4. 地图信息分析
5. 计时器,计数器(浏览量计算!)
6. ...

> Redis特性

1. 开源
2. 支持多种数据类型
3. 支持持久化并提供多种语言API
4. 提供事务的控制 
5. 支持集群
6. ...



这是需要用到的网站:

1. redis官网:https://redis.io/
2. redis中文网:http://www.redis.cn/

下载地址:

![image-20211010144442496](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211010144442496.png)

**注意**:Window在GitHub上下载(停更很久了)

Redis推荐的都是在Linux服务器上搭建的,所以最好是基于Linux来进行学习

### 2.2 安装

> 这是Window下的安装

1. 下载安装包:https://github.com/dmajkic/redis/releases

2. 下载并解压安装包:

   ![image-20211010145305029](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211010145305029.png)

3. 解压后如以下目录:

   ![image-20211010145816869](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211010145816869.png)

   从图中我们看出:

   1. `redis-cli.exe`跟`redis-server.exe`是客户端和服务端
   2. `redis-check-aof.exe`是检查aop持久化文件是不是对的
   3. `redis-benchmark.exe`是测试性能的

4. 开启Rdis,双击`redis-server.exe`即可

   ![image-20211010150200975](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211010150200975.png)

5. 使用redis客户端来连接redis

   ![image-20211010150601350](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211010150601350.png)

   这里我们通过输入命令`ping`返回PONG表示已经连接成功了,然后我们输入set基本值 key-value,然后我们就可以通过key来获取value

> 注意:window下使用很简单,但是Redis官方推荐我们使用Linux去开发使用!

这是官方说明地址:http://www.redis.cn/topics/introduction.html

![image-20211010151343652](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211010151343652.png)

> 这是Linux安装

由于我还没安装Linux进行学习,这里只是作为笔记,未来可回头查阅

1. 下载到本地资源:

![image-20211010152018242](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211010152018242.png)

算了,这里附上链接,学完Linux后再来这里进行安装:

https://www.bilibili.com/video/BV1S54y1R7SB?p=9&spm_id_from=pageDriver

### 2.3 测试性能

在我们的文件夹中找到`redis-benchmark`,这是官方自带的性能测试工具,也是一个压力测试工具!

这是对应的命令参数:

![image-20211010153826476](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211010153826476.png)

我们简单测试一下:

```bash
# 测试:100个并发连接,每个连接都是100000个请求
redis-benchmark -h localhost -p 6379 -c 100 -n 100000
```

![image-20211010171117790](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211010171117790.png)

如何查看这些分析呢？

![image-20211010171633047](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211010171633047.png)

### 2.4 基础的知识

> redis默认有16个数据库!

我们可以打开我们Redis配置文件中的`redis.windows-service.conf`用记事本打开:

![image-20211010172253285](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211010172253285.png)

默认使用的是第0个,我们可以使用`select`进行切换数据库,并且可以使用`DBSIZE`:当前数据库的大小:

```bash
127.0.0.1:6379> ping # 检查当前客户端是否连接上服务器
PONG
127.0.0.1:6379> select 3 # 切换数据库
OK
127.0.0.1:6379[3]> DBSIZE # 这里查看3号数据库大小
(integer) 0
127.0.0.1:6379[3]> set bane Miao # set键值对
OK
127.0.0.1:6379[3]> DBSIZE # 再次查看就可以看到有值
(integer) 1
127.0.0.1:6379[3]> select 7
OK
127.0.0.1:6379[7]> get name
(nil)
127.0.0.1:6379[7]> select 3
OK
127.0.0.1:6379[3]> get bane
"Miao"
127.0.0.1:6379[3]>
```

不同的数据可以存不同的数据库;

> 基础命令:这些命令要记住,后面用Java实现的时候就是用这些命令命名的

1. 查看当前数据库所有的key:**keys *`**

   ```bash
   127.0.0.1:6379[3]> keys *
   1) "bane"
   ```

2. 清除当前数据库:**flushdb **

   ```bash
   127.0.0.1:6379[3]> flushdb 
   OK
   127.0.0.1:6379[3]> keys *
   (empty list or set)
   ```

3. 清除全部数据库:**flushAll**

   ```bash
   127.0.0.1:6379> select 1
   OK
   127.0.0.1:6379[1]> set name MiaoDaWei
   OK
   127.0.0.1:6379[1]> get name
   "MiaoDaWei"
   127.0.0.1:6379[1]> select 2
   OK
   127.0.0.1:6379[2]> set kk HowAreYou
   OK
   127.0.0.1:6379[2]> get kk
   "HowAreYou"
   127.0.0.1:6379[1]> flushAll # 清除全部数据库
   OK
   (0.52s)
   127.0.0.1:6379[1]> get name
   (nil)
   127.0.0.1:6379[1]> select 2
   OK
   127.0.0.1:6379[2]> get kk
   (nil)
   ```

4. 判断key是否存在:**exists**

   ```bash
   127.0.0.1:6379> set name miaowei
   OK
   127.0.0.1:6379> get name
   "miaowei"
   127.0.0.1:6379> exists name # 查询是否存在
   (integer) 1
   127.0.0.1:6379> exists name1 
   (integer) 0
   ```

5. 移动Key:**move**

   ```bash
   127.0.0.1:6379> move name # 移除key 后面没指定数据库表示移除,而如果表明了数据库db,那么这是移动key
   (integer) 1
   127.0.0.1:6379> get name
   (nil)
   ```

6. 给key设置过期时间:**expire**和查看剩余多少秒过期:**ttl**

   ```bash
   127.0.0.1:6379> keys * # 查看所有key
   1) "age"
   2) "name"
   127.0.0.1:6379> expire name 5 # 设置key为name的有效时间为5秒
   (integer) 1
   127.0.0.1:6379> ttl name
   (integer) 3 # 为整数表示剩余多少秒就过期了
   127.0.0.1:6379> ttl name # 查看key的剩余时间
   (integer) -2 # 为-2表示已经不存在了
   127.0.0.1:6379> get name # 获取key
   (nil)
   127.0.0.1:6379> ttl age
   (integer) -1 # 为-1表示永不过期
   ```

   

思考?为什么redis是6379!

这东西,百度就能搜到,似乎是作者为了一舞女还是前女友在九宫格键盘上打出她的名字,就是6379!

> Redis是单线程的!

​	首先我们得知道Redis很快的(这是从官方测试性能得出的),官方表示:Redis是基于内存操作,而CPU不是Redis性能瓶颈,我们知道多线程是跟CPU是挂钩的而Redis是基于内存的,所以说Redis瓶颈是**机器的内存**和**网络带宽**(因为要通过网络接收)决定的!

​	既然可以使用单线程实现就不会用多线程来做!所以就使用了单线程!

> Redis为什么单线程还这么快?

首先我们知道Redis是C语言写的,官方提供的数据为 10000+ 的QPS(每秒查询率),完全不比同样是使用key-value的Memecache差!所以我们就要思考它为什么就那么快?

误区:

1. 高性能的服务器一定是多线程的?不一定
2. 多线程(CPU上下文会切换!!)一定比单线程效率高?不一定
   - 注意:运行速度是:CPU>内存>硬盘

解答:

​	首先明白多线程不一定就会比单线程快!Redis是将所有的数据存放在内存中的,所以说使用单线程操作效率就是最高的!因为多线程之间会造成会产生CPU上下文切换,这个是耗时的操作,因为每次切换都会耗时1500-2000纳秒之间,而一旦多了就会耗时变长了!!!对于内存系统来说,如果没有上下文切换,效率就是最高的!

​	redis利用单个CPU的一块内存的数据的话,针对这块内存进行多次读写的话都是在一个CPU上完成的,多次读写都是在一个CPU上的,在内存情况下,这个就是最佳的方案!

## 3.数据类型

官方文档:

![image-20211010184714617](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211010184714617.png)

全段翻译:

```
Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）。
```

五大数据类型:

1. Redis-Key
2. String
3. List
4. Set
5. Hash
6. Zset

三种特殊数据类型

1. geospatial
2. hyperloglog
3. bitmaps 

### 3.1 Redis-Key

```bash
127.0.0.1:6379> keys * # 查看当前库所有的key
(empty list or set)
127.0.0.1:6379> set name miao # set key
OK
127.0.0.1:6379> keys *
1) "name"
127.0.0.1:6379> set age 1
OK
127.0.0.1:6379> keys *
1) "age"
2) "name"
127.0.0.1:6379> EXISTS name  # 查看key是否存在
(integer) 1 # 存在为1
127.0.0.1:6379> EXISTS name1 
(integer) 0 # 不存在为0
127.0.0.1:6379> move name 1 # 移动key到 1号数据库去,这里如果不写数据库index,那么是移除掉
(integer) 1 # 移动成功
127.0.0.1:6379> keys *
1) "age"
127.0.0.1:6379> set name wei
OK
127.0.0.1:6379> keys *
1) "age"
2) "name"
127.0.0.1:6379> get name
"wei"
127.0.0.1:6379> expire name 10 # 设置key的有效过期时间
(integer) 1
127.0.0.1:6379> ttl name # 查看key的剩余时间,单位是秒
(integer) 7
127.0.0.1:6379> ttl name
(integer) 4 # 整数,表示剩余秒数
127.0.0.1:6379> ttl name
(integer) -2 # 为-2,表示已经不存在了
127.0.0.1:6379> ttl age
(integer) -1 # 为-1,表示不会过期
127.0.0.1:6379> get name
(nil)
127.0.0.1:6379> clear # 用于清除在客户端窗口中使用过的记录
127.0.0.1:6379> type name # 用于查看key的数据类型
string
127.0.0.1:6379> type age
string
```

注意:我们在使用的时候,一般redis都会给出相应的提示,也就是所谓的帮助文档,比如我们写一个set,那么就会相应给出提示剩余该怎么写!

如果我们的命令太多记不住,那么我们可以去官网去查看:

![image-20211010193053218](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211010193053218.png)

### 3.2 五种数据类型

#### 1. String(字符串类型)

基本命令:

```bash
####################################################################################################################
127.0.0.1:6379> set key1 v1 		# 设置值
OK
127.0.0.1:6379> get key1 			# 获得值
"v1"
127.0.0.1:6379> keys * 				# 查看所有key
1) "key1"
127.0.0.1:6379> exists key1			# 判断某个key是否存在
(integer) 1
127.0.0.1:6379> append key1 'hello' # 追加字符串,如果当前key不存在,就相当于set了一个key
(integer) 7
127.0.0.1:6379> get key1
"v1hello"
127.0.0.1:6379> strlen key1  		# 获取字符串的长度!
(integer) 7
127.0.0.1:6379> append key1 ',MiaoDaWei'
(integer) 17
127.0.0.1:6379> strlen key1
(integer) 17
127.0.0.1:6379> get key1
"v1hello,MiaoDaWei"
####################################################################################################################
# 步长,java中的i+=操作,可以用于网页浏览量等等!
127.0.0.1:6379> set views 0  		# 设置初始浏览量为0
OK
127.0.0.1:6379> get views
"0"
127.0.0.1:6379> incr views 			# 自增1
(integer) 1
127.0.0.1:6379> incr views
(integer) 2
127.0.0.1:6379> get views
"2"
127.0.0.1:6379> decr views 			# 自减1
(integer) 1
127.0.0.1:6379> decr views
(integer) 0
127.0.0.1:6379> decr views
(integer) -1
127.0.0.1:6379> decr views
(integer) -2
127.0.0.1:6379> incrby views 12 	# 设置步长,指定增量!在原来基础+12
(integer) 10
127.0.0.1:6379> get views
"10"
127.0.0.1:6379> decrby views 10 	# 设置步长,指定减量!在原来基础上-10
(integer) 0
127.0.0.1:6379> get views
"0"
####################################################################################################################
# 字符串范围操作 range
127.0.0.1:6379> set name "hello,MiaoDaWei" 	# 设置key
OK
127.0.0.1:6379> get name
"hello,MiaoDaWei"
127.0.0.1:6379> getrange name 0 4 			# 截取key的范围,下标从0开始,这是闭区间[0,4]
"hello"
127.0.0.1:6379> get name
"hello,MiaoDaWei"
127.0.0.1:6379> getrange name 0 -1 			# 截取key的范围,结束下标为-1,表示截取整个字符串
"hello,MiaoDaWei"
替换!类似于Java中的subString跟replace:
127.0.0.1:6379> set name2 abcdefg
OK
127.0.0.1:6379> setrange name2 1 xx			# 替换指定位置的开始的字符串!
(integer) 7
127.0.0.1:6379> get name2
"axxdefg"
####################################################################################################################
# setex跟setnx,用于判断当前值是否存在,存在就设值,
# setex(set with expire) :设置过期时间
# setnx(set if not exist):不存在就设值 (在分布式锁中会常常使用!可以保证值的存在)
127.0.0.1:6379> setex key3 30 'hello'		#设置key3的值为hello,并且30秒后过期,注意:key3如果存在就会替换,不存在就会创建,总之只要setex就会有值
OK
127.0.0.1:6379> ttl key3
(integer) 22
127.0.0.1:6379> get key3
"hello"
127.0.0.1:6379> setnx mykey "redis" 		# 如果mykey不存在,就创建mykey
(integer) 1
127.0.0.1:6379> keys *
1) "name"
2) "mykey"
3) "name2"
127.0.0.1:6379> ttl key3
(integer) -2
127.0.0.1:6379> setnx mykey "MongoDB"		# 如果mykey存在,那么创建失败!
(integer) 0
127.0.0.1:6379> get mykey
"redis"
####################################################################################################################
# mset:批量set值
# mget:批量获取值
127.0.0.1:6379>  mset k1 v1 k2 v2 k3 v3		# 批量设置值,以空格隔开,前面是key 后面是value
OK
127.0.0.1:6379> keys *
1) "k1"
2) "k3"
3) "k2"
127.0.0.1:6379> mset k4 v4 k4 v5			# 如果在批量set的时候,key重复了那么就会以后面创建的为准,也就是后面替换前面的
OK
127.0.0.1:6379> get k4
"v5"
127.0.0.1:6379> mget k1 k2 k3 k4 k5			# 批量获取key,都是key并且以空格隔开,有值就获取没值获取不到
1) "v1"
2) "v2"
3) "v3"
4) "v5"
5) (nil)
127.0.0.1:6379>  mset k1 v1 k5 v5
OK
127.0.0.1:6379> msetnx k1 v1 k6 v6			# 批量操作set值,这里是原子性,但凡在批量操作中出现已经存在的key那么就会操作失败返回0,要么同时成功要么同时失败!
(integer) 0

# 对象
set user:1 {name:zhangsan,age:3}  # 设置一个user:1对象 值为json字符来保存一个对象!

# 这里key是一个巧妙的设计:	user:{id}:{filed},如此设计在Redis中是完全是OK的!

127.0.0.1:6379> mset user:1:name zhangsan user:1:age 2
OK
127.0.0.1:6379> mget user:1:name user:1:age
1) "zhangsan"
2) "2"
####################################################################################################################
getset # 先get然后再set
127.0.0.1:6379> getset db redis				# 先获取db在set值,也就是说先获取,不管是否存在都不影响后面的set,如果不存在值就返回null.存在就设置新的值
(nil)
127.0.0.1:6379> get db
"redis"
127.0.0.1:6379> getset db mongodb			# 获取存在的key,然后set值
"redis"
127.0.0.1:6379> get db
"mongodb"
```

其实本身数据结构都是相通的,后面我们就要使用`jedis`中在java中把命令变成一个个的方法!

String类型的使用场景:value除了是我们的字符串还可以是我们的数字!

- 比如计数器
- 统计多单位的数量
- 对象缓存存储!
- 粉丝数!

#### 2. List(列表)

这是一个基本的数据类型->列表

![image-20211010205513293](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20211010205513293.png)

在redis里面,我们可以把list玩成:栈、队列、阻塞队列！

常用命令：

**注意**：所有的list命令都是以`l`开头的,并且不区分大小写命令:

```bash
####################################################################################################################
# 这里list只是key的名称而已
127.0.0.1:6379> lpush list one			# 将一个值或多个值插入到列表头部(左)
(integer) 1
127.0.0.1:6379> lpush list two
(integer) 2
127.0.0.1:6379> lpush list three
(integer) 3
127.0.0.1:6379> lrange list 0 -1
1) "three"
2) "two"
3) "one"
127.0.0.1:6379> lrange list 0 1
1) "three"
2) "two"
127.0.0.1:6379> rpush list righr		# 将一个值或多个值插入到列表尾部(右)
(integer) 4
127.0.0.1:6379> lrange list 0 -1
1) "three"
2) "two"
3) "one"
4) "righr"
# 理解:可以想象成一个平面图,使用lpush就会往左边插入,后面的值插入就会让前一个值往右移一位!,rpush反之亦然
####################################################################################################################
LPOP:# 往左边移除
RPOP:# 往右边移除 ,其实可以理解数据结构中的队列
127.0.0.1:6379> lrange list 0 -1
1) "three"
2) "two"
3) "one"
4) "righr"
127.0.0.1:6379> lpop list				# 移除列表的第一个元素
"three"
127.0.0.1:6379> rpop list				# 移除列表的最后一个元素
"righr"
127.0.0.1:6379> lrange list 0 -1
1) "two"
2) "one"
####################################################################################################################
# 理解为数组的话我们可以通过下标来获取值
lindex :# 获取某一个列表的下标值
127.0.0.1:6379> lrange list 0 -1		# 获取列表全部元素
1) "two"
2) "one"
127.0.0.1:6379> lindex list 0			# 获取下标为0的元素
"two"
127.0.0.1:6379> lindex list 1
"one"
127.0.0.1:6379> lindex list 2			# 因为下标没有元素所以返回null
(nil)
####################################################################################################################
Llen:# 获取列表的长度
127.0.0.1:6379> lpush list one two three # 往列表里插入多个值
(integer) 3
127.0.0.1:6379> llen list				 # 获取列表的长度,也就是有多少个元素
(integer) 3
####################################################################################################################
lrem:# 移除指定的值!
127.0.0.1:6379> lpush list three		# 往列表头部插入一个元素
(integer) 4
127.0.0.1:6379> lrange list 0 -1
1) "three"
2) "three"
3) "two"
4) "one"
127.0.0.1:6379> lrem list 1 one			# 移除列表中指定个数的value,精确匹配!注意:如果指定个数比实际个数多了,也不会影响!
(integer) 1
127.0.0.1:6379> lrange list 0 -1
1) "three"
2) "three"
3) "two"
127.0.0.1:6379> lrem list 2 three
(integer) 2
127.0.0.1:6379> lrange list 0 -1
1) "two"
####################################################################################################################
ltrim: # 截断某一部分的数据
127.0.0.1:6379> rpush list "hello"
(integer) 1
127.0.0.1:6379> rpush list "hello1"
(integer) 2
127.0.0.1:6379> rpush list "hello2"
(integer) 3
127.0.0.1:6379> rpush list "hello3"
(integer) 4
127.0.0.1:6379> lrange list 0 -1
1) "hello"
2) "hello1"
3) "hello2"
4) "hello3"
127.0.0.1:6379> ltrim list 1 2			# 通过下标截取指定的长度!这个list截取后就已经发生了改变,截断后只剩下截取的元素!
OK
127.0.0.1:6379> lrange list 0 -1
1) "hello1"
2) "hello2"
####################################################################################################################
rpoplpush: # 移除列表最后一个元素并将该元素添加到新的列表头部并返回,这是一个组合命令
127.0.0.1:6379> rpush mulist "hello"
(integer) 1
127.0.0.1:6379> rpush mulist "hello1"
(integer) 2
127.0.0.1:6379> rpush mulist "hello2"
(integer) 3
127.0.0.1:6379> lrange mulist 0 -1
1) "hello"
2) "hello1"
3) "hello2"
127.0.0.1:6379> rpoplpush mulist list		# 将当前列表尾部的元素移除,然后将移除的元素push到另一个列表的头部	
"hello2"
127.0.0.1:6379> lrange mulist 0 -1			# 查看原来的列表
1) "hello"
2) "hello1"
127.0.0.1:6379> lrange list 0 -1			# 查看目标列表中,确实存在改值!
1) "hello2"
####################################################################################################################
lset: # 往存在的列表中对指定下标的值进行替换为另外一个值进行更新操作
127.0.0.1:6379> exists list					# 判断这个列表是否存在
(integer) 0
127.0.0.1:6379> lset list 0 miao			# 更新不存在的列表就会报错
(error) ERR no such key
127.0.0.1:6379> lpush list value1
(integer) 1
127.0.0.1:6379> lrange list 0 0
1) "value1"
127.0.0.1:6379> lset list 0 miao			# 如果存在就会更新当前下标的值
OK
127.0.0.1:6379> lrange list 0 0
1) "miao"
127.0.0.1:6379> lset list 1 wei				# 更新不存在的下标就会提示报错!
(error) ERR index out of range
####################################################################################################################
linsert: # 将某个具体的value插入到列表中具体的某个元素的	前面/后面
127.0.0.1:6379> rpush mylist "hello"
(integer) 1
127.0.0.1:6379>  rpush mylist "hello1"
(integer) 2
127.0.0.1:6379> linsert mylist before "world" "other"		# 在列表中指定的元素前面插入value
(integer) -1
127.0.0.1:6379> linsert mylist before "hello1" "other"
(integer) 3
127.0.0.1:6379> lrange mylist 0 -1
1) "hello"
2) "other"
3) "hello1"
127.0.0.1:6379> linsert mylist after "hello1" "after"		# 在列表中指定的元素后面插入value
(integer) 4
127.0.0.1:6379> lrange mylist 0 -1
1) "hello"
2) "other"
3) "hello1"
4) "after"
```

> 小结

1. 它实际上是一个链表的结构,我们可以在指定的节点的前后进行操作 before Node after,left right都可以插入值
2. 在push的时候如果key不存在就会创建新的链表!
3. 如果key存在,就会新增内容
4. 如果移除了所有的值就会变成一个空链表,而一个空链表就代表不存在!
5. 在两边插入或者改动值,效率是最高的!如果改动中间元素效率相对会低!



一般应用场景为消息排队、消息队列;

我们可以把列表当成队列使用:`Lpush Rpop` 先进先出

​			   堆栈使用:`Lpush Lpop` 先进后出	

这是列表最大的**优势**:既可以当成栈也可以当成队列!

#### 3. Set(集合)

这个Set也是一个集合类型可以存储多个值,但是**不能重复**!

基本命令:

**Set数据类型都是以S开头的命令,多以member表示元素**

```bash
####################################################################################################################
sadd:# 添加元素
smembers: # 查看所有元素
sismember: # 判断是否包含指定元素

127.0.0.1:6379> sadd myset "hello"				# set集合中添加元素
(integer) 1
127.0.0.1:6379> sadd myset "hello1"
(integer) 1
127.0.0.1:6379> sadd myset "hello1"				# 重复添加就会失败!
(integer) 0
127.0.0.1:6379> smembers myset					# 查看指定set的所有值
1) "hello"
2) "hello1"
127.0.0.1:6379> sismember myset "hello"			# 判断某个元素是否在set中
(integer) 1
127.0.0.1:6379> sismember myset "world"
(integer) 0
####################################################################################################################
127.0.0.1:6379> scard myset						# 获取set集合中内容元素个数
(integer) 2
127.0.0.1:6379> sadd myset "MiaoDaWei"
(integer) 1
127.0.0.1:6379> scard myset
(integer) 3
####################################################################################################################
srem: # 移除set集合中指定的一个元素

127.0.0.1:6379> scard myset
(integer) 3
127.0.0.1:6379> srem myset hello				# 移除set集合中指定元素
(integer) 1
127.0.0.1:6379> scard myset
(integer) 2
127.0.0.1:6379> smembers myset					# 查看set中全部元素
1) "hello1"
2) "MiaoDaWei"
####################################################################################################################
set 无序不重复集合。抽随机！
srandmember: # 随机抽取元素,可以指定抽取个数-由于数据量少容易出现偶然性

127.0.0.1:6379> smembers myset
1) "hello"
2) "hello1"
3) "MiaoDaWei"
127.0.0.1:6379> srandmember myset				# 随机抽选一个元素
"MiaoDaWei"
127.0.0.1:6379>  srandmember myset
"hello1"
127.0.0.1:6379>  srandmember myset 2			# 随机抽选出指定个数的元素
1) "hello1"
2) "MiaoDaWei"
127.0.0.1:6379>  srandmember myset 2
1) "hello1"
2) "MiaoDaWei"
127.0.0.1:6379>  srandmember myset 2
1) "hello"
2) "MiaoDaWei"
####################################################################################################################
# 删除随机的元素

127.0.0.1:6379> smembers myset
1) "hello"
2) "hello1"
3) "MiaoDaWei"
127.0.0.1:6379> spop myset						# 移除Set集合中随机的一个元素,pop:弹出
"hello"
127.0.0.1:6379> spop myset 2					# 移除Set集合中指定个数的随机元素
1) "hello1"
2) "MiaoDaWei"
127.0.0.1:6379> smembers myset
(empty list or set)
####################################################################################################################
# 将一个指定的值移动到另外一个Set集合中!

127.0.0.1:6379> sadd myset "hello"
(integer) 1
127.0.0.1:6379> sadd myset "hello2"
(integer) 1
127.0.0.1:6379> sadd myset "MiaoDaWei"
(integer) 1
127.0.0.1:6379> sadd myset2 "set2"
(integer) 1
127.0.0.1:6379> smembers myset
1) "hello"
2) "hello2"
3) "MiaoDaWei"
127.0.0.1:6379> smembers myset2
1) "set2"
127.0.0.1:6379> smove myset myset2 "MiaoDaWei"			# 将一个指定的值从当前Set集合移动到另外一个Set集合中去!
(integer) 1
127.0.0.1:6379> smembers myset
1) "hello"
2) "hello2"
127.0.0.1:6379> smembers myset2
1) "set2"
2) "MiaoDaWei"
####################################################################################################################
我们的微博或者哔哩哔哩都会发现有共同关注:
数学集合类:
	-  差集
	-  交集
	-  并集	

127.0.0.1:6379> sadd key1 a
(integer) 1
127.0.0.1:6379> sadd key1 b
(integer) 1
127.0.0.1:6379> sadd key1 c
(integer) 1
127.0.0.1:6379> sadd key2 c
(integer) 1
127.0.0.1:6379> sadd key2 d
(integer) 1
127.0.0.1:6379> sadd key2 e
(integer) 1
127.0.0.1:6379> smembers key1
1) "c"
2) "b"
3) "a"
127.0.0.1:6379> smembers key2
1) "d"
2) "c"
3) "e"
127.0.0.1:6379> sdiff key1 key2						# 差集:以第一个Set集合为参照物,然后跟二个Set集合进行比对,然后获取到第一个Set集合中的差集
1) "a"
2) "b"
127.0.0.1:6379> sinter key1 key2					# 交集:获取第一个Set集合与第二个Set集合共同的元素->共同好友就是这样实现的!
1) "c"
127.0.0.1:6379> sunion key1 key2					# 并集:获取第一个Set集合和第二个Set集合中不重复的元素!
1) "a"
2) "b"
3) "c"
4) "d"
5) "e"
####################################################################################################################
```

这里交集的应用场景:

​	比如微博,对于A用户来说将所有关注的人放在一个Set集合中,将它的粉丝也放在一个集合中!共同关注:A用户和B用户的共同关注就可以实现了,我们把这两个关注的人做一个交集,那么就出来了,类似的也有很多,比如共同爱好之类的,

这里提一个概念:二度好友,推荐好友!-->六度分隔理论!



#### 4. Hash(哈希)

​	可以把这想象成一个Map集合!首先我们在Map集合中存储的数据结构是`Key-Value`,而我们则是将value改成`Key-Map`集合!也就是`Key-<key-value>`结构,存储的话也是键值对,只不过这个时候这个值是一个map集合!

​	本质上跟String类型没有太大区别!还是简单的一个key-value!只不过这个值是有两个值进行组合的!

**所有的Hash都是以H开头的命令**

基本命令:

```bash
####################################################################################################################
127.0.0.1:6379> hset myhash filed1 miaowei				# 设置一个key value为一个map
(integer) 1
127.0.0.1:6379> hget myhash filed1						# 获取一个字段值
"miaowei"
127.0.0.1:6379> hset myhash filed2 wei
(integer) 1
127.0.0.1:6379> hget myhash filed2
"wei"
127.0.0.1:6379> hmset myhash filed3 hello filed2 world	 # set 多个key-value
OK
127.0.0.1:6379> hmget myhash filed1 filed2 filed3		# 获取多个字段值
1) "miaowei"
2) "world"
3) "hello"
127.0.0.1:6379> hgetall myhash							# 获取全部的数据,展示的数据以键跟值进行展示
1) "filed1"
2) "miaowei"
3) "filed2"
4) "world"
5) "filed3"
6) "hello"
127.0.0.1:6379> hdel myhash filed1						# 删除hash指定的key字段!对应的value值也就没有了!这里可以批量删除!
(integer) 1
127.0.0.1:6379> hgetall myhash
1) "filed2"
2) "world"
3) "filed3"
4) "hello"
####################################################################################################################
hlen: # 获取hash中有多少个值

127.0.0.1:6379> hgetall myhash
1) "filed2"
2) "world"
3) "filed3"
4) "hello"
127.0.0.1:6379> hlen myhash								# 获取hash表的字段数量
(integer) 2
####################################################################################################################
hexists: # 判断hash中是否有指定的key

127.0.0.1:6379> hgetall myhash
1) "filed2"
2) "world"
3) "filed3"
4) "hello"
127.0.0.1:6379> hexists myhash filed2					# 判断hash中指定字段是否存在!
(integer) 1
127.0.0.1:6379> hexists myhash filed4
(integer) 0
####################################################################################################################
# 只获得所有所有的filed

127.0.0.1:6379> hkeys myhash							# 获取所有的字段
1) "filed2"
2) "filed3"
127.0.0.1:6379> hvals myhash							# 获取所有的value
1) "world"
2) "hello"
####################################################################################################################
incr decr  # 自增

127.0.0.1:6379> hset myhash field3 5					# 指定初始数量
(integer) 1
127.0.0.1:6379> hincrby myhash field3 1					# 指定增量
(integer) 6
127.0.0.1:6379> hincrby myhash field3 -1				# 指定增量为负,就表示为decrby自减
(integer) 5
127.0.0.1:6379> hsetnx myhash field3 hello				# 如果存在则不能设置
(integer) 0
127.0.0.1:6379> hsetnx myhash field4 hello
(integer) 1

注:可以应用在分布式锁中!
```

应用场景:

​	hash变更的数据,我们可以把一个用户user当成一个键,而User里面有很多name和age,那么我们可以把name和age当成我们的值!我们可以把对象作为键,然后里面存放着就是具体的字段和字段的值,这样我们就能通过一个对象就能获取对应的字段!

​	Hash尤其是可以用一些用户信息的保存!特别是经常变动的信息!hash更适合于**对象的存储**!String更加适合字符串的存储!

类似:

```bash
127.0.0.1:6379> hmset user:1 name miaowei age 21
OK
127.0.0.1:6379> hget user:1 name
"miaowei"
127.0.0.1:6379> hget user:1 age
"21"
```

