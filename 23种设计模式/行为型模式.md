行为性模式：负责对象间的高效沟通和职责委派。

# 责任链（Chain of Responsibility)

> 把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。

责任链模式：就是将多个操作组装成一条链路进行处理。请求在链路上传递，链路上的每一个节点就是一个处理器，每个处理器都可以对请求进行处理，或者传递给链路上的下一个处理器处理。

> 应用场景

1. 操作需要经过一系列的校验，通过校验后才执行某些操作。
2. 工作流。工作流程-需要一级一级的去处理任务。

## 传统代码

*案例*：模拟在618期间业务系统上线审批流程场景

*前提*：为了保障线上系统的稳定性是尽可能的减少上线的，也会相应的增强审批力度。就像一级响应、二级响应一样。而这审批的过程在随着特定时间点会增加不同级别的负责人加入，每个人就像责任链模式中的每一个核心点。对于研发小伙伴并不需要关心具体的审批流程处理细节，只需要知道这个上线更严格，级别也更高，但对于研发人员来说同样是点击相同的提审按钮，等待审核。

*代码*：

1. 定义返回对象信息

   ```java
   public class AuthInfo {
   
       private String code;
       private String info = "";
   
       public AuthInfo(String code, String ...infos) {
           this.code = code;
           for (String str:infos){
               this.info = this.info.concat(str);
           }
       }
       
       // ...get/set
   }
   ```

2. 模拟审核服务

   ```java
   public class AuthService {
   
       private static Map<String, Date> authMap = new ConcurrentHashMap<String, Date>();
       // 查询-get到说明已经审核过了
       public static Date queryAuthInfo(String uId, String orderId) {
           return authMap.get(uId.concat(orderId));
       }
      
       //模拟审核-这里直接审核通过放进缓存中
       public static void auth(String uId, String orderId) {
           authMap.put(uId.concat(orderId), new Date());
       }
   }
   ```

3. 模拟不同的人员审批的流程代码

   ![image-20230103112452434](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/202301031124529.png)

   

4. 模拟每次查询是否审批完成，随着审批的不同节点，之后继续由不同的负责人进行审批操作
   	![image-20230103112506698](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/202301031125746.png)

5. 结果

   ![image-20230103112749125](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/202301031127158.png)

> 结果已知：但看结果以满足，但缺点：很难扩展和调整流程，代码都是固定写死的！

## 模式重构

通过责任链模式让现有的服务模块更加清晰，而每一个模块间的获取都通过`next`来进行获取，而`next`是由继承的统一抽象类实现。

最终所有类的职责可以动态的进行编排是由-而在编排的过程可以做成配置化。

*模型结构*：

![责任链模式模型结构](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/202301031146092.png)

以上就是核心部分，三个不同岗位领导的审批业务然后实现统一抽象类`AuthLink`。再进行责任编排模拟出一条链路。----这个链路就是业务中的责任链。



*代码*：

1. 链路抽象类

   ```java
   public abstract class AuthLink {
   
       protected Logger logger = LoggerFactory.getLogger(AuthLink.class);
   
       protected SimpleDateFormat f = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");// 时间格式化
       protected String levelUserId;                           // 级别人员ID
       protected String levelUserName;                         // 级别人员姓名
       private AuthLink next;                                  // 责任链
   
       public AuthLink(String levelUserId, String levelUserName) {
           this.levelUserId = levelUserId;
           this.levelUserName = levelUserName;
       }
   
       //可以通过next()方式获取下一个链路需要处理的节点
       public AuthLink next() {
           return next;
       }
   
       public AuthLink appendNext(AuthLink next) {
           this.next = next;
           return this;
       }
   	
      //抽象方法，要求实现者必须要实现的类，这样不同的审核级别就能处理不同的业务 
       public abstract AuthInfo doAuth(String uId, String orderId, Date authDate);
   }
   ```

2. 三个审核实现类

   ```java
   public class Level1AuthLink extends AuthLink {
   
       public Level1AuthLink(String levelUserId, String levelUserName) {
           super(levelUserId, levelUserName);
       }
   
       public AuthInfo doAuth(String uId, String orderId, Date authDate) {
           //查询已经审核过了么
           Date date = AuthService.queryAuthInfo(levelUserId, orderId);
           if (null == date) {
               return new AuthInfo("0001", "单号：", orderId, " 状态：待一级审批负责人 ", levelUserName);
           }
           //获取下一个链路。如果没有就表示最终结尾的位置
           AuthLink next = super.next();
           if (null == next) {
               return new AuthInfo("0000", "单号：", orderId, " 状态：一级审批完成负责人", " 时间：", f.format(date), " 审批人：", levelUserName);
           }
   	
           //链路核心，调用抽象类开始审核，就会往下走！
           return next.doAuth(uId, orderId, authDate);
       }
   }
   ```

   ```java
   public class Level2AuthLink extends AuthLink {
   
       private Date beginDate = f.parse("2020-06-11 00:00:00");
       private Date endDate = f.parse("2020-06-20 23:59:59");
   
       public Level2AuthLink(String levelUserId, String levelUserName) throws ParseException {
           super(levelUserId, levelUserName);
       }
   
       public AuthInfo doAuth(String uId, String orderId, Date authDate) {
           Date date = AuthService.queryAuthInfo(levelUserId, orderId);
           if (null == date) {
               return new AuthInfo("0001", "单号：", orderId, " 状态：待二级审批负责人 ", levelUserName);
           }
           AuthLink next = super.next();
           if (null == next) {
               return new AuthInfo("0000", "单号：", orderId, " 状态：二级审批完成负责人", " 时间：", f.format(date), " 审批人：", levelUserName);
           }
   
           if (authDate.before(beginDate) || authDate.after(endDate)) {
               return new AuthInfo("0000", "单号：", orderId, " 状态：二级审批完成负责人", " 时间：", f.format(date), " 审批人：", levelUserName);
           }
   
           return next.doAuth(uId, orderId, authDate);
       }
   }
   ```

   ```java
   public class Level3AuthLink extends AuthLink {
   
       private Date beginDate = f.parse("2020-06-01 00:00:00");
       private Date endDate = f.parse("2020-06-25 23:59:59");
   
       public Level3AuthLink(String levelUserId, String levelUserName) throws ParseException {
           super(levelUserId, levelUserName);
       }
   
       public AuthInfo doAuth(String uId, String orderId, Date authDate) {
           Date date = AuthService.queryAuthInfo(levelUserId, orderId);
           if (null == date) {
               return new AuthInfo("0001", "单号：", orderId, " 状态：待三级审批负责人 ", levelUserName);
           }
           AuthLink next = super.next();
           if (null == next) {
               return new AuthInfo("0000", "单号：", orderId, " 状态：三级审批负责人完成", " 时间：", f.format(date), " 审批人：", levelUserName);
           }
   
           if (authDate.before(beginDate) || authDate.after(endDate)) {
               return new AuthInfo("0000", "单号：", orderId, " 状态：三级审批负责人完成", " 时间：", f.format(date), " 审批人：", levelUserName);
           }
   
           return next.doAuth(uId, orderId, authDate);
       }
   }
   ```

3. 测试类

   ```java
   @Test
   public void test_AuthLink() throws ParseException {
       AuthLink authLink = new Level3AuthLink("1000013", "王工")
               .appendNext(new Level2AuthLink("1000012", "张经理")
                       .appendNext(new Level1AuthLink("1000011", "段总")));
   
       logger.info("测试结果：{}", JSON.toJSONString(authLink.doAuth("小傅哥", "1000998004813441", new Date())));
   
       // 模拟三级负责人审批
       AuthService.auth("1000013", "1000998004813441");
       logger.info("测试结果：{}", "模拟三级负责人审批，王工");
       logger.info("测试结果：{}", JSON.toJSONString(authLink.doAuth("小傅哥", "1000998004813441", new Date())));
   
       // 模拟二级负责人审批
       AuthService.auth("1000012", "1000998004813441");
       logger.info("测试结果：{}", "模拟二级负责人审批，张经理");
       logger.info("测试结果：{}", JSON.toJSONString(authLink.doAuth("小傅哥", "1000998004813441", new Date())));
   
       // 模拟一级负责人审批
       AuthService.auth("1000011", "1000998004813441");
       logger.info("测试结果：{}", "模拟一级负责人审批，段总");
       logger.info("测试结果：{}", JSON.toJSONString(authLink.doAuth("小傅哥", "1000998004813441", new Date())));
   }
   ```

核心代码：

```java
AuthLink authLink = new Level3AuthLink("1000013", "王工") .appendNext(new Level2AuthLink("1000012", "张经理") .appendNext(new Level1AuthLink("1000011", "段总")));
```

通过把不同的责任节点进行组装，构成了一条完整业务的责任链。在具体的审核实现类里最后`authLink.doAuth(...)`通过返回结果的组装对数据3、2、1级负责人审核直到审核完成！

## 小结

一般在使用责任链时候如果是场景比较固定，可以通过写死到代码中进行初始化。但如果业务场景经常变化可以做成xml配置的方式进行处理，也可以落到库里进行初始化操作。

**优点**：

1. 代码结构变得清晰干净了，解决了大量if语句的使用
2. 很好处理了单一职责和开闭职责
3. 简单了耦合也使对象关系更加清晰
4. 让外部的调用方并不需要关心责任链是如何进行处理的。





# 命令模式（Command Pattern)

> 将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分隔开。

![命令模式，图片来自 refactoringguru.cn](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/202301031402179.png)

这是将**逻辑实现**与**操作请求**进行分离，降低耦合方便扩展。

角色：

1. 抽象命令类：声明执行命令的接口和方法
2. 具体的命令实现类：接口类的具体实现，可以是一组相似的行为逻辑
3. 实现者：为命令做实现的具体实现类
4. 调用者：处理命令、实现的具体操作者，负责对外提供命令服务。

## 传统代码

案例：模拟在餐厅中点餐交给厨师烹饪的场景。

​	命令场景的核心的逻辑是调用方与不需要去关心具体的逻辑实现，在这个场景中也就是点餐人员只需要把需要点的各种菜系交个`小二`就可以，小二再把各项菜品交给各个厨师进行烹饪。也就是点餐人员不需要跟各个厨师交流，只需要在统一的环境里下达命令就可以。

**代码**：

1. 定义小二的类，通过这样的类实现整个不同菜品的点单逻辑

   ```java
   public class XiaoEr {
   
       private Logger logger = LoggerFactory.getLogger(XiaoEr.class);
   
       private Map<Integer, String> cuisineMap = new ConcurrentHashMap<Integer, String>();
   
       // 点单添加菜品
       public void order(int cuisine) {
           // 广东（粤菜）
           if (1 == cuisine) {
               cuisineMap.put(1, "广东厨师，烹饪鲁菜，宫廷最大菜系，以孔府风味为龙头");
           }
   
           // 江苏（苏菜）
           if (2 == cuisine) {
               cuisineMap.put(2, "江苏厨师，烹饪苏菜，宫廷第二大菜系，古今国宴上最受人欢迎的菜系。");
           }
   
           // 山东（鲁菜）
           if (3 == cuisine) {
               cuisineMap.put(3, "山东厨师，烹饪鲁菜，宫廷最大菜系，以孔府风味为龙头.");
           }
   
           // 四川（川菜）
           if (4 == cuisine) {
               cuisineMap.put(4, "四川厨师，烹饪川菜，中国最有特色的菜系，也是民间最大菜系。");
           }
   
       }
   
       //展示菜品信息
       public void placeOrder() {
           logger.info("菜单：{}", JSON.toJSONString(cuisineMap));
       }
   }
   ```

## 模式重构

   ![image-20230103144836749](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/202301031448793.png)



1. 抽象命令定义（菜品接口）

   ```java
   public interface ICuisine {
       void cook(); // 烹调、制作
   }
   ```

2. 具体命令实现（四种菜品）

   ```java
   // 广东-粤菜
   public class GuangDoneCuisine implements ICuisine {
       private ICook cook;
       public GuangDoneCuisine(ICook cook) { this.cook = cook;}
       public void cook() {cook.doCooking(); }
   }
   
   //江苏-苏菜
   public class JiangSuCuisine implements ICuisine {
       private ICook cook;
       //构造函数传一个厨师进来
       public JiangSuCuisine(ICook cook) {this.cook = cook;}
       //烹饪菜品
       public void cook() {cook.doCooking(); }
   }
   
   //山东-鲁菜
   public class ShanDongCuisine implements ICuisine {
       private ICook cook;
       public ShanDongCuisine(ICook cook) {this.cook = cook;}
       public void cook() { cook.doCooking();}
   }
   
   //四川-川菜
   public class SiChuanCuisine implements ICuisine {
       private ICook cook;
       public SiChuanCuisine(ICook cook) {this.cook = cook;}
       public void cook() {cook.doCooking();}
   }
   ```

3. 抽象类实现者定义（厨师接口）

   ```java
   public interface ICook {
       // 菜品对应的厨师烹饪的指令实现
       void doCooking();
   }
   ```

4. 实现者具体实现（四类厨师）

   ```java
   // 粤菜-厨师
   public class GuangDongCook implements ICook {
       private Logger logger = LoggerFactory.getLogger(ICook.class);
       public void doCooking() { logger.info("广东厨师，烹饪鲁菜，宫廷最大菜系，以孔府风味为龙头"); }
   }
   
   //苏菜-厨师
   public class JiangSuCook implements ICook {
       private Logger logger = LoggerFactory.getLogger(ICook.class);
       public void doCooking() {logger.info("江苏厨师，烹饪苏菜，宫廷第二大菜系，古今国宴上最受人欢迎的菜系。"); }
   }
   
   //鲁菜-厨师
   public class ShanDongCook implements ICook {
       private Logger logger = LoggerFactory.getLogger(ICook.class);
       public void doCooking() {ogger.info("山东厨师，烹饪鲁菜，宫廷最大菜系，以孔府风味为龙头"); }
   }
   
   //苏菜-厨师
   public class SiChuanCook implements ICook {
       private Logger logger = LoggerFactory.getLogger(ICook.class);
       public void doCooking() {logger.info("四川厨师，烹饪川菜，中国最有特色的菜系，也是民间最大菜系。");}
   }
   ```

5. 调用者（小二）

   ```java
   //在调用者的具体实现中，提供了菜品的添加和菜单执行烹饪。这个过程是命令模式的具体调用，通过外部将菜品和厨师传递进来而进行具体的调用。
   public class XiaoEr {
       private Logger logger = LoggerFactory.getLogger(XiaoEr.class);
       //菜单列表
       private List<ICuisine> cuisineList = new ArrayList<ICuisine>();
       //点菜
       public void order(ICuisine cuisine) {cuisineList.add(cuisine);}
      //开始执行烹饪	
       public synchronized void placeOrder() {
           for (ICuisine cuisine : cuisineList) {cuisine.cook();}
           cuisineList.clear();
       }
   }
   ```

6. 测试:

   ```java
   @Test
   public void test(){
       // 菜系 + 厨师；广东（粤菜）、江苏（苏菜）、山东（鲁菜）、四川（川菜）
       ICuisine guangDoneCuisine = new GuangDoneCuisine(new GuangDongCook());
       JiangSuCuisine jiangSuCuisine = new JiangSuCuisine(new JiangSuCook());
       ShanDongCuisine shanDongCuisine = new ShanDongCuisine(new ShanDongCook());
       SiChuanCuisine siChuanCuisine = new SiChuanCuisine(new SiChuanCook());
   
       // 点单
       XiaoEr xiaoEr = new XiaoEr();
       xiaoEr.order(guangDoneCuisine);
       xiaoEr.order(jiangSuCuisine);
       xiaoEr.order(shanDongCuisine);
       xiaoEr.order(siChuanCuisine);
   
       // 下单
       xiaoEr.placeOrder();
   }
   ```

7. ![image-20230103152140471](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/202301031521502.png)

> 我们现在只需要交给调用者(小二)的点单，由不同的厨师具体实现（烹饪）
>

当我们需要不同的菜品时候或者修改时候都可以非常方便的添加和修改，在具备单一职责的类下，都可以非常方便的扩展

## 小结

命令模式的使用场景分为三个很大的块：**命令(菜品或厨师)**、**实现(具体菜品或具体厨师)**、**调用者(小二)**，而这三块内容的拆分也是选择适合场景的关键因素，经过这样的拆分可以让逻辑具备单一职责的性质，便于扩展。

# 迭代器模式（Iterator Pattern)

> 提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示--用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。

![迭代器模式，图片来自 refactoringguru.cn](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/202301031535523.png)

在日常代码中常见的是`iterator`遍历！

**特点**：实现*Iterator*接口，通过*Next*的方式获取集合元素，同时具备对元素的删除等操作。

**优点**：

1. 它支持以不同的方式遍历一个聚合对象
2. 迭代器简化了聚合类
3. 在同一个聚合上可以有多个遍历
4. 在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。

以相同的方式，遍历不同的数据结构元素，这些数据结构包括；`数组`、`链表`、`树`等，而用户在使用遍历的时候并不需要去关心每一种数据结构的遍历处理逻辑，从让使用变得统一易用

## 代码引进

​	一般我们常用的遍历就是jdk默认提供的方法，对list集合遍历。但是对于一些偏业务特性较大的树形结构，如果需要使用到遍历，那么就可以自己来实现。接下来我们会把这个组织层次关系通过树形数据结构来实现，并完成迭代器功能。



构成：

1. *Collection*，集合方法部分用于对自定义的数据结构添加通用方法；`add`、`remove`、`iterator`等核心方法。
2. *Iterable*，提供获取迭代器，这个接口类会被`Collection`继承。
3. *Iterator*，提供了两个方法的定义；`hasNext`、`next`，会在具体的数据结构中写实现方式。

```java
public interface Iterator {
    boolean hasNext();

    Object next();
}
```

```java
public interface Container {
    Iterator getIterator();
}
```

核心：

```java
public class NameRepository implements Container {
    public String[] names = {"a", "b", "c", "d"};

    @Override
    public Iterator getIterator() {
        return new NameIterator();
    }

    private class NameIterator implements Iterator {
        int index;
        @Override
        public boolean hasNext() {
            if (this.index < NameRepository.this.names.length) {return true;}
            return false;
        }

        @Override
        public Object next() {
            if (this.hasNext()) {return NameRepository.this.names[this.index++]; }
            return null;
        }
    }
}
```

测试：

```java
@Test
    public void test() throws Exception {
        NameRepository namesRepository = new NameRepository();
        for (Iterator iter = namesRepository.getIterator(); iter.hasNext(); ) {
            String name = (String) iter.next();
            System.out.println("Name : " + name);
        }
    }
```

![image-20230103155554726](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/202301031555763.png)

## 小结

- 迭代器的设计模式从以上的功能实现可以看到，满足了单一职责和开闭原则，外界的调用方也不需要知道任何一个不同的数据结构在使用上的遍历差异。可以非常方便的扩展，也让整个遍历变得更加干净整洁。
- 但从结构的实现上可以看到，迭代器模式的实现过程相对来说是比较复杂的，类的实现上也扩增了需要外部定义的类，使得遍历与原数据结构分开。虽然这是比较麻烦的，但可以看到在使用java的jdk时候，迭代器的模式还是很好用的，可以非常方便扩展和升级。



# 中介者模式(mediator Pattern)

> 定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。

![中介者模式，图片来自 refactoringguru.cn](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/202301041021382.png)

​	中介者模式要解决的就是**复杂功能应用之间的重复调用**，在这之间添加一层中介者包装服务，对外提供简单、通用、易扩展的服务能力。

比如:

![image-20230104105934447](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/202301041059529.png)

## 传统代码

案例：模仿Mybatis手写ORM框架

![场景模拟；模仿Mybatis手写ORM框架](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/202301041105167.png)

```java
public class JDBCUtil {

    private static Logger logger = LoggerFactory.getLogger(JDBCUtil.class);

    public static final String URL = "jdbc:mysql://127.0.0.1:3306/itstack-demo-design";
    public static final String USER = "root";
    public static final String PASSWORD = "123456";

    public static void main(String[] args) throws Exception {
        //1. 加载驱动程序
        Class.forName("com.mysql.jdbc.Driver");
        //2. 获得数据库连接
        Connection conn = DriverManager.getConnection(URL, USER, PASSWORD);
        //3. 操作数据库
        Statement stmt = conn.createStatement();
        ResultSet resultSet = stmt.executeQuery("SELECT id, name, age, createTime, updateTime FROM user");
        //4. 如果有数据 resultSet.next() 返回true
        while (resultSet.next()) {
            logger.info("测试结果 姓名：{} 年龄：{}", resultSet.getString("name"),resultSet.getInt("age"));
        }
    }
}
```

> 这种就是使用JDBC的方式进行直接操作数据库！

## 模式引进

案例：租房为例，中介机构充当租房者与房屋所有者之间的中介者

1. 抽象中介者

   ```java
   public abstract class Mediator {
       //申明一个联络方法
       public abstract void constact(String message,Person person);
   }
   ```

2. 抽象人类

   ```java
   public abstract class Person {
   
   protected String name;
   protected Mediator mediator;
   
   public Person(String name, Mediator mediator) {
   this.mediator = mediator;
   this.name = name;
   }
   public abstract void getMessage(String message);
   
   public abstract void constact(String message);
   }
   ```

3. 抽象同事

   ```java
   public class HouseOwner extends Person{
       HouseOwner(String name, Mediator mediator) {
           super(name, mediator);
       }
       
       /**
        * @desc 与中介者联系
        * @param message
        * @return void
        */
       public void constact(String message){
           mediator.constact(message, this);
       }
    
       /**
        * @desc 获取信息
        * @param message
        * @return void
        */
       public void getMessage(String message){
           System.out.println("房主:" + name +",获得信息：" + message);
       }
   }
   ```

   ```java
   public class Tenant extends Person{
       
       Tenant(String name, Mediator mediator) {
           super(name, mediator);
       }
       
       /**
        * @desc 与中介者联系
        * @param message
        * @return void
        */
       public void constact(String message){
           mediator.constact(message, this);
       }
    
       /**
        * @desc 获取信息
        * @param message
        * @return void
        */
       public void getMessage(String message){
           System.out.println("租房者:" + name +",获得信息：" + message);
       }
   }
   ```

4. 具体中介者对象：中介结构

   ```java
   public class MediatorStructure extends Mediator{
       //首先中介结构必须知道所有房主和租房者的信息
       private HouseOwner houseOwner;
       private Tenant tenant;
    
       public HouseOwner getHouseOwner() {
           return houseOwner;
       }
    
       public void setHouseOwner(HouseOwner houseOwner) {
           this.houseOwner = houseOwner;
       }
    
       public Tenant getTenant() {
           return tenant;
       }
    
       public void setTenant(Tenant tenant) {
           this.tenant = tenant;
       }
    
       public void constact(String message, Person person) {
           if(person == houseOwner){          //如果是房主，则租房者获得信息
               tenant.getMessage(message);
           }
           else{       //反之则是获得房主信息
               houseOwner.getMessage(message);
           }
       }
   }
   ```

5. 客户端

   ```java
   public class Client {
       public static void main(String[] args) {
           //一个房主、一个租房者、一个中介机构
           MediatorStructure mediator = new MediatorStructure();
           
           //房主和租房者只需要知道中介机构即可
           HouseOwner houseOwner = new HouseOwner("张三", mediator);
           Tenant tenant = new Tenant("李四", mediator);
           
           //中介结构要知道房主和租房者
           mediator.setHouseOwner(houseOwner);
           mediator.setTenant(tenant);
           
           tenant.constact("听说你那里有三室的房主出租.....");
           houseOwner.constact("是的!请问你需要租吗?");
       }
   }
   ```

6. 运行结果

   ```
   房主:张三,获得信息：听说你那里有三室的房主出租..... 
   租房者:李四,获得信息：是的!请问你需要租吗?
   ```

## 小结

适用环境：

1. 系统中对象之间存在复杂的引用关系，产生的相互依赖关系结构混乱且难以理解。
2. 一个对象由于引用了其他很多对象并且直接和这些对象通信，导致难以复用该对象
3. 想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。可以通过引入中介者类来实现，在中介者中定义对象。
4. 交互的公共行为，如果需要改变行为则可以增加新的中介者类。



# 备忘录模式（Memento Pattern)

> 在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。

![备忘录模式，图片来自 refactoringguru.cn](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/202301041135840.png)

​	备忘录模式是以可以恢复或者说回滚，配置、版本、悔棋为核心功能的设计模式，而这种设计模式属于行为模式。在功能实现上是以**不破坏原对象为基础增加备忘录操作类**，**记录原对象的行为**从而实现备忘录模式。

## 代码引进

案例：模拟在发布上线的过程中记录线上配置文件用于紧急回滚

结构：

![备忘录模式模型结构](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/202301041137783.png)

1. 配置信息类

   ```java
   public class ConfigFile {
   
       private String versionNo; // 版本号
       private String content;   // 内容
       private Date dateTime;    // 时间
       private String operator;  // 操作人   
       // ...get/set
   }
   ```

2. 备忘录类

   ```java
   //备忘录是对原有配置类的扩展，可以设置和获取配置信息
   public class ConfigMemento {
   
       private ConfigFile configFile;
   
       public ConfigMemento(ConfigFile configFile) {
           this.configFile = configFile;
       }
   
       public ConfigFile getConfigFile() {
           return configFile;
       }
   
       public void setConfigFile(ConfigFile configFile) {
           this.configFile = configFile;
       }   
   }
   ```

3. 记录者类

   ```java
   public class ConfigOriginator {
   
       private ConfigFile configFile;
   
       public ConfigFile getConfigFile() {
           return configFile;
       }
   
       public void setConfigFile(ConfigFile configFile) {
           this.configFile = configFile;
       }
   
       //创建一个备忘录信息，并返回回去，交给管理者处理-保存
       public ConfigMemento saveMemento(){
           return new ConfigMemento(configFile);
       }
   
       //获取的之后并不是直接返回，而是把备忘录的信息交给现在的配置文件this.configFile-回滚
       public void getMemento(ConfigMemento memento){
           this.configFile = memento.getConfigFile();
       }
   }
   ```

4. 管理员类

   ```java
   //实现的核心功能就是记录配置文件信息，也就是备忘录的效果，之后提供可以回滚和获取的方法，拿到备忘录的具体内容
   public class Admin {
   
       private int cursorIdx = 0;
       private List<ConfigMemento> mementoList = new ArrayList<ConfigMemento>();
       private Map<String, ConfigMemento> mementoMap = new ConcurrentHashMap<String, ConfigMemento>();
   
       //存放
       public void append(ConfigMemento memento) {
           mementoList.add(memento);
           mementoMap.put(memento.getConfigFile().getVersionNo(), memento);
           cursorIdx++;
       }
   
       //回滚
       public ConfigMemento undo() {
           if (--cursorIdx <= 0) return mementoList.get(0);
           return mementoList.get(cursorIdx);
       }
   
       //返回
       public ConfigMemento redo() {
           if (++cursorIdx > mementoList.size()) return mementoList.get(mementoList.size() - 1);
           return mementoList.get(cursorIdx);
       }
   
       //定向获取
       public ConfigMemento get(String versionNo){
           return mementoMap.get(versionNo);
       }
   }
   ```

5. 测试类

   ```java
   //滚1次、再回滚1次，之后向前进1次，最后是获取指定的版本配置
   @Test
   public void test() {
       Admin admin = new Admin();
       ConfigOriginator configOriginator = new ConfigOriginator();
       configOriginator.setConfigFile(new ConfigFile("1000001", "配置内容A=哈哈", new Date(), "小傅哥"));
       admin.append(configOriginator.saveMemento()); // 保存配置
       configOriginator.setConfigFile(new ConfigFile("1000002", "配置内容A=嘻嘻", new Date(), "小傅哥"));
       admin.append(configOriginator.saveMemento()); // 保存配置
       configOriginator.setConfigFile(new ConfigFile("1000003", "配置内容A=么么", new Date(), "小傅哥"));
       admin.append(configOriginator.saveMemento()); // 保存配置
       configOriginator.setConfigFile(new ConfigFile("1000004", "配置内容A=嘿嘿", new Date(), "小傅哥"));
       admin.append(configOriginator.saveMemento()); // 保存配置  
   
       // 历史配置(回滚)
       configOriginator.getMemento(admin.undo());
       logger.info("历史配置(回滚)undo：{}", JSON.toJSONString(configOriginator.getConfigFile()));  
   
       // 历史配置(回滚)
       configOriginator.getMemento(admin.undo());
       logger.info("历史配置(回滚)undo：{}", JSON.toJSONString(configOriginator.getConfigFile()));  
   
       // 历史配置(前进)
       configOriginator.getMemento(admin.redo());
       logger.info("历史配置(前进)redo：{}", JSON.toJSONString(configOriginator.getConfigFile()));   
   
       // 历史配置(获取)
       configOriginator.getMemento(admin.get("1000002"));
       logger.info("历史配置(获取)get：{}", JSON.toJSONString(configOriginator.getConfigFile()));
   }

6. 结果：

   ```java
   23:12:09.512 [main] INFO  org.itstack.demo.design.test.ApiTest - 历史配置(回滚)undo：{"content":"配置内容A=嘿嘿","dateTime":159209829432,"operator":"小傅哥","versionNo":"1000004"}
   23:12:09.514 [main] INFO  org.itstack.demo.design.test.ApiTest - 历史配置(回滚)undo：{"content":"配置内容A=么么","dateTime":159209829432,"operator":"小傅哥","versionNo":"1000003"}
   23:12:09.514 [main] INFO  org.itstack.demo.design.test.ApiTest - 历史配置(前进)redo：{"content":"配置内容A=嘿嘿","dateTime":159209829432,"operator":"小傅哥","versionNo":"1000004"}
   23:12:09.514 [main] INFO  org.itstack.demo.design.test.ApiTest - 历史配置(获取)get：{"content":"配置内容A=嘻嘻","dateTime":159320989432,"operator":"小傅哥","versionNo":"1000002"}
   
   Process finished with exit code 0
   ```

## 小结

1. 此种设计模式的方式可以满足在不破坏原有属性类的基础上，扩充了备忘录的功能。虽然和我们平时使用的思路是一样的，但在具体实现上还可以细细品味，这样的方式在一些源码中也有所体现。
2. 在以上的实现中我们是将配置模拟存放到内存中，如果关机了会导致配置信息丢失，因为在一些真实的场景里还是需要存放到数据库中。那么此种存放到内存中进行回复的场景也不是没有，比如；Photoshop、运营人员操作ERP配置活动，那么也就是即时性的一般不需要存放到库中进行恢复。另外如果是使用内存方式存放备忘录，需要考虑存储问题，避免造成内存大量消耗。

# 观察者模式（Observer Pattern)

> 多个对象间存在一对多的关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。

![观察者模式，图片来自 refactoringguru.cn](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/202301041338987.png)

**简而言之**：就是当一个行为发生时传递信息给另外一个用户接收做出相应的处理，两者之间没有直接的耦合关联。

**目的**：让主线服务与其他辅线业务服务分离，为了使系统降低耦合和增强扩展性--可以应用观察者模式



## 传统代码

案例：模拟在车管所摇号后，触发行为通知MQ和发送短信给用户

1. 模拟摇号

   ```java
   public class MinibusTargetService {
   
       /**
        * 模拟摇号，但不是摇号算法
        *
        * @param uId 用户编号
        * @return 结果
        */
       public String lottery(String uId) {
           return Math.abs(uId.hashCode()) % 2 == 0 ? "恭喜你，编码".concat(uId).concat("在本次摇号中签") : "很遗憾，编码".concat(uId).concat("在本次摇号未中签或摇号资格已过期");
       }
   }
   ```

2. 具体实现

   ```java
   public class LotteryServiceImpl implements LotteryService {
       private Logger logger = LoggerFactory.getLogger(LotteryServiceImpl.class);
       private MinibusTargetService minibusTargetService = new MinibusTargetService();
   
       public LotteryResult doDraw(String uId) {
           // 摇号
           String lottery = minibusTargetService.lottery(uId);
           // 发短信
           logger.info("给用户 {} 发送短信通知(短信)：{}", uId, lottery);
           // 发MQ消息
           logger.info("记录用户 {} 摇号结果(MQ)：{}", uId, lottery);
           // 结果
           return new LotteryResult(uId, lottery, new Date());
       }
   }
   ```

3. 测试

   ```java
   @Test
   public void test() {
       LotteryService lotteryService = new LotteryServiceImpl();
       LotteryResult result = lotteryService.doDraw("2765789109876");
       logger.info("测试结果：{}", JSON.toJSONString(result));
   }
   ```

​	首先按照需求来说在原有的摇号接口中添加MQ消息发送以及短消息通知功能，按照顺序依次调用！但会发现除了`摇号`接口调用外，后面的两部分都是非核心主链路功能，而且会随着后续的业务需求发展而不断的调整和扩展，在这样的开发方式下就非常不利于维护。



## 代码引进

整体结构：

![观察者模式模型结构](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/202301041452134.png)

1. 事件监听接口定义

   ```java
   //接口中定义了基本的事件类，这里如果方法的入参信息类型是变化的可以使用泛型<T>
   public interface EventListener {
       void doEvent(LotteryResult result);
   }
   ```

2. 两个监听事件的实现

   ```java
   public class MessageEventListener implements EventListener {
       private Logger logger = LoggerFactory.getLogger(MessageEventListener.class);
   
       @Override
       public void doEvent(LotteryResult result) {
           logger.info("给用户 {} 发送短信通知(短信)：{}", result.getuId(), result.getMsg());
       }
   }
   ```

   ```java
   public class MQEventListener implements EventListener {
       private Logger logger = LoggerFactory.getLogger(MQEventListener.class);
   
       @Override
       public void doEvent(LotteryResult result) {
           logger.info("记录用户 {} 摇号结果(MQ)：{}", result.getuId(), result.getMsg());
       }
   }
   ```

3. 事件处理类

   ```java
   public class EventManager {
       Map<Enum<EventType>, List<EventListener>> listeners = new HashMap<>();
   
       public EventManager(Enum<EventType>... operations) {
           for (Enum<EventType> operation : operations) {
               this.listeners.put(operation, new ArrayList<>());
           }
       }
   
       public enum EventType {
           MQ, Message
       }
   
       /**
        * 订阅
        * @param eventType 事件类型
        * @param listener  监听
        */
       public void subscribe(Enum<EventType> eventType, EventListener listener) {
           List<EventListener> users = listeners.get(eventType);
           users.add(listener);
       }
   
       /**
        * 取消订阅
        * @param eventType 事件类型
        * @param listener  监听
        */
       public void unsubscribe(Enum<EventType> eventType, EventListener listener) {
           List<EventListener> users = listeners.get(eventType);
           users.remove(listener);
       }
   
       /**
        * 通知
        * @param eventType 事件类型
        * @param result    结果
        */
       public void notify(Enum<EventType> eventType, LotteryResult result) {
           List<EventListener> users = listeners.get(eventType);
           for (EventListener listener : users) {
               listener.doEvent(result);
           }
       }
   }
   ```

4. 业务抽象类接口

   ```java
   public abstract class LotteryService {
       private EventManager eventManager;
   
       public LotteryService() {
           eventManager = new EventManager(EventManager.EventType.MQ, EventManager.EventType.Message);
           eventManager.subscribe(EventManager.EventType.MQ, new MQEventListener());
           eventManager.subscribe(EventManager.EventType.Message, new MessageEventListener());
       }
   
       public LotteryResult draw(String uId) {
           LotteryResult lotteryResult = doDraw(uId);
           // 需要什么通知就给调用什么方法
           eventManager.notify(EventManager.EventType.MQ, lotteryResult);
           eventManager.notify(EventManager.EventType.Message, lotteryResult);
           return lotteryResult;
       }
   
       protected abstract LotteryResult doDraw(String uId);
   }
   ```

   - 这种使用抽象类的方式定义实现方法，可以在方法中扩展需要的额外调用。并提供抽象类`abstract LotteryResult doDraw(String uId)`，让类的继承者实现。
   - 同时方法的定义使用的是`protected`，也就是保证将来外部的调用方不会调用到此方法，只有调用到`draw(String uId)`，才能让我们完成事件通知。
   - 此种方式的实现就是在抽象类中写好一个基本的方法，在方法中完成新增逻辑的同时，再增加抽象类的使用。而这个抽象类的定义会有继承者实现。
   - 另外在构造函数中提供了对事件的定义；`eventManager.subscribe(EventManager.EventType.MQ, new MQEventListener())`。
   - 在使用的时候也是使用枚举的方式进行通知使用，传了什么类型`EventManager.EventType.MQ`，就会执行什么事件通知，按需添加

5. 业务接口实现类

   ```java
   public class LotteryServiceImpl extends LotteryService {
       private MinibusTargetService minibusTargetService = new MinibusTargetService();
   
       @Override
       protected LotteryResult doDraw(String uId) {
           // 摇号
           String lottery = minibusTargetService.lottery(uId);
           // 结果
           return new LotteryResult(uId, lottery, new Date());
       }
   }
   ```

6. 测试

   ```java
   @Test
   public void test() {
       LotteryService lotteryService = new LotteryServiceImpl();
       LotteryResult result = lotteryService.draw("2765789109876");
       logger.info("测试结果：{}", JSON.toJSONString(result));
   }
   ```

## 小结

1. 模式改造拆分出了核心流程与辅助流程的代码，一般代码中的核心流程不会经常变化。但辅助流程会随着业务的各种变化而变化，包括；`营销`、`裂变`、`促活`等等，因此使用设计模式架设代码就显得非常有必要。



# 状态模式（State Pattern)

> 允许一个对象在其内部状态发生改变时改变其行为能力。

![状态模式，图片来自 refactoringguru.cn](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/202301041508414.png)

​	状态模式描述的是一个行为下的多种状态变更，比如我们最常见的一个网站的页面，在你登录与不登录下展示的内容是略有差异的(`不登录不能展示个人信息`)，而这种`登录`与`不登录`就是我们通过改变**状态**，而让整个行为发生了变化。



## 传统代码

案例：模拟一个营销活动中审核状态的流转

![场景模拟；营销活动审核状态流转](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/202301041605230.png)

图中可以看出流程节点中包括了各个状态到下一个状态扭转的关联条件，比如：审核通过才能到活动中，而不能从编辑中直接到活动中，这些状态的转变就是我们要完成的场景处理。

1. 基本活动信息

   ```java
   public class ActivityInfo {
   
       private String activityId;    // 活动ID
       private String activityName;  // 活动名称
       private Enum<Status> status;  // 活动状态
       private Date beginTime;       // 开始时间
       private Date endTime;         // 结束时间
      
       // ...get/set
   }  
   ```

2. 活动枚举状态

   ```java
   public enum Status {
   
       // 、2、3、4、5、6、7
       Editing, //创建编辑
       Check,  //待审核
       Pass,  //审核通过(任务扫描成活动中)
       Refuse,  //审核拒绝(可以撤审到编辑状态)
       Doing,  //活动中
       Close,  //活动关闭
       Open //活动开启(任务扫描成活动中)
   }
   ```

3. 活动服务接口

   ```java
   public class ActivityService {
   
       private static Map<String, Enum<Status>> statusMap = new ConcurrentHashMap<String, Enum<Status>>();
   
       public static void init(String activityId, Enum<Status> status) {
           // 模拟查询活动信息
           ActivityInfo activityInfo = new ActivityInfo();
           activityInfo.setActivityId(activityId);
           activityInfo.setActivityName("早起学习打卡领奖活动");
           activityInfo.setStatus(status);
           activityInfo.setBeginTime(new Date());
           activityInfo.setEndTime(new Date());
           statusMap.put(activityId, status);
       }
   
       /**
        * 查询活动信息
        *
        * @param activityId 活动ID
        * @return 查询结果
        */
       public static ActivityInfo queryActivityInfo(String activityId) {
           // 模拟查询活动信息
           ActivityInfo activityInfo = new ActivityInfo();
           activityInfo.setActivityId(activityId);
           activityInfo.setActivityName("早起学习打卡领奖活动");
           activityInfo.setStatus(statusMap.get(activityId));
           activityInfo.setBeginTime(new Date());
           activityInfo.setEndTime(new Date());
           return activityInfo;
       }
   
       /**
        * 查询活动状态
        *
        * @param activityId 活动ID
        * @return 查询结果
        */
       public static Enum<Status> queryActivityStatus(String activityId) {
           return statusMap.get(activityId);
       }
   
       /**
        * 执行状态变更
        *
        * @param activityId   活动ID
        * @param beforeStatus 变更前状态
        * @param afterStatus  变更后状态 b
        */
       public static synchronized void execStatus(String activityId, Enum<Status> beforeStatus, Enum<Status> afterStatus) {
           // 如果变更前的状态跟现有的状态不匹配则变更失败！防止并发出现意外情况
           if (!beforeStatus.equals(statusMap.get(activityId))) return;
           statusMap.put(activityId, afterStatus);
       }
   }
   ```

   这里使用Map的结构来记录活动ID和状态变化信息，另外还有init方法来初始化活动数据。实际的开发中这类信息基本都是从`数据库`或者`Redis`中获取

4. 状态变更，判断每一个状态可以流转到下一个什么状态。

   ```java
   public class ActivityExecStatusController {
   
       /**
        * 活动状态变更
        * 1. 编辑中 -> 提审、关闭
        * 2. 审核通过 -> 拒绝、关闭、活动中
        * 3. 审核拒绝 -> 撤审、关闭
        * 4. 活动中 -> 关闭
        * 5. 活动关闭 -> 开启
        * 6. 活动开启 -> 关闭
        *
        * @param activityId   活动ID
        * @param beforeStatus 变更前状态
        * @param afterStatus  变更后状态
        * @return 返回结果
        */
       public Result execStatus(String activityId, Enum<Status> beforeStatus, Enum<Status> afterStatus) {
   
           // 1. 编辑中 -> 提审、关闭
           if (Status.Editing.equals(beforeStatus)) {
               if (Status.Check.equals(afterStatus) || Status.Close.equals(afterStatus)) {
                   ActivityService.execStatus(activityId, beforeStatus, afterStatus);
                   return new Result("0000", "变更状态成功");
               } else {
                   return new Result("0001", "变更状态拒绝");
               }
           }
   
           // 2. 审核通过 -> 拒绝、关闭、活动中
           if (Status.Pass.equals(beforeStatus)) {
               if (Status.Refuse.equals(afterStatus) || Status.Doing.equals(afterStatus) || Status.Close.equals(afterStatus)) {
                   ActivityService.execStatus(activityId, beforeStatus, afterStatus);
                   return new Result("0000", "变更状态成功");
               } else {
                   return new Result("0001", "变更状态拒绝");
               }
           }
   
           // 3. 审核拒绝 -> 撤审、关闭
           if (Status.Refuse.equals(beforeStatus)) {
               if (Status.Editing.equals(afterStatus) || Status.Close.equals(afterStatus)) {
                   ActivityService.execStatus(activityId, beforeStatus, afterStatus);
                   return new Result("0000", "变更状态成功");
               } else {
                   return new Result("0001", "变更状态拒绝");
               }
           }
   
           // 4. 活动中 -> 关闭
           if (Status.Doing.equals(beforeStatus)) {
               if (Status.Close.equals(afterStatus)) {
                   ActivityService.execStatus(activityId, beforeStatus, afterStatus);
                   return new Result("0000", "变更状态成功");
               } else {
                   return new Result("0001", "变更状态拒绝");
               }
           }
   
           // 5. 活动关闭 -> 开启
           if (Status.Close.equals(beforeStatus)) {
               if (Status.Open.equals(afterStatus)) {
                   ActivityService.execStatus(activityId, beforeStatus, afterStatus);
                   return new Result("0000", "变更状态成功");
               } else {
                   return new Result("0001", "变更状态拒绝");
               }
           }
   
           // 6. 活动开启 -> 关闭
           if (Status.Open.equals(beforeStatus)) {
               if (Status.Close.equals(afterStatus)) {
                   ActivityService.execStatus(activityId, beforeStatus, afterStatus);
                   return new Result("0000", "变更状态成功");
               } else {
                   return new Result("0001", "变更状态拒绝");
               }
           }
   
           return new Result("0001", "非可处理的活动状态变更");
   
       }
   }
   ```

5. 测试类

   ```java
   @Test
   public void test() {
       // 初始化数据
       String activityId = "100001";
       ActivityService.init(activityId, Status.Editing);  
   
       ActivityExecStatusController activityExecStatusController = new ActivityExecStatusController();
       
       //是从编辑中到审核拒绝
       Result resultRefuse = activityExecStatusController.execStatus(activityId, Status.Editing, Status.Refuse); 
       logger.info("测试结果(编辑中To审核拒绝)：{}", JSON.toJSONString(resultRefuse));                           
      //是从编辑中到提交审核
       Result resultCheck = activityExecStatusController.execStatus(activityId, Status.Editing, Status.Check);
       logger.info("测试结果(编辑中To提交审核)：{}", JSON.toJSONString(resultCheck));
   }
   ```

6. 测试结果：

   ```java
   23:24:30.774 [main] INFO  org.itstack.demo.design.test.ApiTest - 测试结果(编辑中To审核拒绝)：{"code":"0001","info":"变更状态拒绝"}
   23:24:30.778 [main] INFO  org.itstack.demo.design.test.ApiTest - 测试结果(编辑中To提交审核)：{"code":"0000","info":"变更状态成功"}
   
   Process finished with exit code 0
   ```

> 使用传统方式去写代码虽然好看懂，但对于后续迭代随着需求变化那么就会难以维护起来！

## 模式引进

结构模型：

![状态模式模型结构](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/202301041637359.png)

实现的核心就是要去掉`if-else`的方式！

1. 状态抽象类

   ```java
   public abstract class State {
   
       /**
        * 活动提审
        *
        * @param activityId    活动ID
        * @param currentStatus 当前状态
        * @return 执行结果
        */
       public abstract Result arraignment(String activityId, Enum<Status> currentStatus);
   
       /**
        * 审核通过
        *
        * @param activityId    活动ID
        * @param currentStatus 当前状态
        * @return 执行结果
        */
       public abstract Result checkPass(String activityId, Enum<Status> currentStatus);
   
       /**
        * 审核拒绝
        *
        * @param activityId    活动ID
        * @param currentStatus 当前状态
        * @return 执行结果
        */
       public abstract Result checkRefuse(String activityId, Enum<Status> currentStatus);
   
       /**
        * 撤审撤销
        *
        * @param activityId    活动ID
        * @param currentStatus 当前状态
        * @return 执行结果
        */
       public abstract Result checkRevoke(String activityId, Enum<Status> currentStatus);
   
       /**
        * 活动关闭
        *
        * @param activityId    活动ID
        * @param currentStatus 当前状态
        * @return 执行结果
        */
       public abstract Result close(String activityId, Enum<Status> currentStatus);
   
       /**
        * 活动开启
        *
        * @param activityId    活动ID
        * @param currentStatus 当前状态
        * @return 执行结果
        */
       public abstract Result open(String activityId, Enum<Status> currentStatus);
   
       /**
        * 活动执行
        *
        * @param activityId    活动ID
        * @param currentStatus 当前状态
        * @return 执行结果
        */
       public abstract Result doing(String activityId, Enum<Status> currentStatus);
   }
   ```

2. 部分状态流转实现

   ```java
   // 这是编辑状态下，对每个可能存在的状态的执行返回结果
   public class EditingState extends State {
   
       public Result arraignment(String activityId, Enum<Status> currentStatus) {
           ActivityService.execStatus(activityId, currentStatus, Status.Check);
           return new Result("0000", "活动提审成功");
       }
   
       public Result checkPass(String activityId, Enum<Status> currentStatus) {
           return new Result("0001", "编辑中不可审核通过");
       }
   
       public Result checkRefuse(String activityId, Enum<Status> currentStatus) {
           return new Result("0001", "编辑中不可审核拒绝");
       }
   
       @Override
       public Result checkRevoke(String activityId, Enum<Status> currentStatus) {
           return new Result("0001", "编辑中不可撤销审核");
       }
   
       public Result close(String activityId, Enum<Status> currentStatus) {
           ActivityService.execStatus(activityId, currentStatus, Status.Close);
           return new Result("0000", "活动关闭成功");
       }
   
       public Result open(String activityId, Enum<Status> currentStatus) {
           return new Result("0001", "非关闭活动不可开启");
       }
   
       public Result doing(String activityId, Enum<Status> currentStatus) {
           return new Result("0001", "编辑中活动不可执行活动中变更");
       }
   
   }
   ```

3. 状态处理服务

   ```java
   //对状态服务的统一控制中心
   public class StateHandler {
   private Map<Enum<Status>, State> stateMap = new ConcurrentHashMap<Enum<Status>, State>();
   
       //构造函数传递状态与具体实现的关联
       public StateHandler() {
           stateMap.put(Status.Check, new CheckState());     // 待审核
           stateMap.put(Status.Close, new CloseState());     // 已关闭
           stateMap.put(Status.Doing, new DoingState());     // 活动中
           stateMap.put(Status.Editing, new EditingState()); // 编辑中
           stateMap.put(Status.Open, new OpenState());       // 已开启
           stateMap.put(Status.Pass, new PassState());       // 审核通过
           stateMap.put(Status.Refuse, new RefuseState());   // 审核拒绝
       }
   
       //审核-通过传递进来的状态去获取对应具体实现类，
       public Result arraignment(String activityId, Enum<Status> currentStatus) {
           return stateMap.get(currentStatus).arraignment(activityId, currentStatus);
       }
   
       public Result checkPass(String activityId, Enum<Status> currentStatus) {
           return stateMap.get(currentStatus).checkPass(activityId, currentStatus);
       }
   
       public Result checkRefuse(String activityId, Enum<Status> currentStatus) {
           return stateMap.get(currentStatus).checkRefuse(activityId, currentStatus);
       }
   
       public Result checkRevoke(String activityId, Enum<Status> currentStatus) {
           return stateMap.get(currentStatus).checkRevoke(activityId, currentStatus);
       }
   
       public Result close(String activityId, Enum<Status> currentStatus) {
           return stateMap.get(currentStatus).close(activityId, currentStatus);
       }
   
       public Result open(String activityId, Enum<Status> currentStatus) {
           return stateMap.get(currentStatus).open(activityId, currentStatus);
       }
   
       public Result doing(String activityId, Enum<Status> currentStatus) {
           return stateMap.get(currentStatus).doing(activityId, currentStatus);
       }
      
   }
   ```

4. 测试类

   ```java
   @Test
   public void test_Editing2Arraignment() {
       String activityId = "100001";
       //初始化当前的状态
       ActivityService.init(activityId, Status.Editing);
       // 状态处理初始化
       StateHandler stateHandler = new StateHandler();
       //调用审核服务，当前处于编辑状态
       Result result = stateHandler.arraignment(activityId, Status.Editing);
       logger.info("测试结果(编辑中To提审活动)：{}", JSON.toJSONString(result));
       logger.info("活动信息：{} 状态：{}", JSON.toJSONString(ActivityService.queryActivityInfo(activityId)), JSON.toJSONString(ActivityService.queryActivityInfo(activityId).getStatus()));
   }
   ```

5. 测试结果

   ```java
   23:59:20.883 [main] INFO  org.itstack.demo.design.test.ApiTest - 测试结果(编辑中To提审活动)：{"code":"0000","info":"活动提审成功"}
   23:59:20.907 [main] INFO  org.itstack.demo.design.test.ApiTest - 活动信息：{"activityId":"100001","activityName":"早起学习打卡领奖活动","beginTime":1593694760892,"endTime":1593694760892,"status":"Check"} 状态："Check"
   
   Process finished with exit code 0
   ```

## 小结

1. 对比后发现重构了if-else。代码的结构变得清晰易扩展，对后续维护和扩展变得更容易一些。
2. 我们要面向对象编程而不是面向过程。并且满足了`单一职责`和`开闭原则`，再这样的结构下扩展变得很容易，增加和修改也不会影响整体的变化。



# 策略模式（Strategy Pattern)

> 定义一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。

![策略模式，图片来自 refactoringguru.cn](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/202301051025699.png)

策略模式也可以代替大量if-else的利器。



**解决场景**：一般是具有同类可替代的行为逻辑算法场景

1. 不同类型的交易方式（信用卡、支付宝、微信）
2. 生成唯一ID策略（UUID、DB自增、DB+Redis、雪花算法、Leaf算法）

*总之都可以使用策略模式来进行行为包装，供给外部使用*



**角色：**

1. 抽象策略类（Strategy）：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。
2. 具体策略类（Concrete Strategy）：实现抽象策略定义的接口，提供具体的算法实现或行为。
3. 环境类（Context）：持有一个策略类的引用，最终给客户端调用。

## 传统代码

实现不同类型的优惠卷计算折扣得到最终的金额

```java
/**
* 优惠券类型；
 * 1. 直减券
 * 2. 满减券
 * 3. 折扣券
 * 4. n元购
*/
public class CouponDiscountService {
	
    // 优惠券类型、优惠券金额、商品金额，满减多少
    public double discountAmount(int type, double typeContent, double skuPrice, double typeExt) {
        // 1. 直减券
        if (1 == type) {
            return skuPrice - typeContent;
        }
        // 2. 满减券
        if (2 == type) {
            if (skuPrice < typeExt) return skuPrice;
            return skuPrice - typeContent;
        }
        // 3. 折扣券
        if (3 == type) {
            return skuPrice * typeContent;
        }
        // 4. n元购
        if (4 == type) {
            return typeContent;
        }
        return 0D;
    }
}
```

可能一开始是一个比较简单的优惠劵但随着产品功能的增加，不断的扩展if语句，那么实际的代码可能都要比这个多。

## 模式引进

模式结构：

![策略模式模型结构](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/202301051101059.png)

- 整体的结构模式并不复杂，主要体现的不同类型的优惠券在计算优惠券方式的不同计算策略。
- 这里包括一个接口类(`ICouponDiscount`)以及四种优惠券类型的实现方式。
- 最后提供了策略模式的上下控制类处理，整体的策略服务。

1. 优惠券接口

   ```java
   public interface ICouponDiscount<T> {
   
       /**
        * 优惠券金额计算
        * @param couponInfo 券折扣信息；直减、满减、折扣、N元购
        * @param skuPrice   sku金额
        * @return           优惠后金额
        */
       BigDecimal discountAmount(T couponInfo, BigDecimal skuPrice);
   }
   ```

2. 优惠券接口的具体实现（不同类型的优惠券计算折扣金额的策略方式不同）

   ```java
   //满减
   public class MJCouponDiscount implements ICouponDiscount<Map<String,String>>  {
   
       /**
        * 满减计算
        * 1. 判断满足x元后-n元，否则不减
        * 2. 最低支付金额1元
        */
       public BigDecimal discountAmount(Map<String,String> couponInfo, BigDecimal skuPrice) {
           String x = couponInfo.get("x");
           String o = couponInfo.get("n");
   
           // 小于商品金额条件的，直接返回商品原价
           if (skuPrice.compareTo(new BigDecimal(x)) < 0) return skuPrice;
           // 减去优惠金额判断
           BigDecimal discountAmount = skuPrice.subtract(new BigDecimal(o));
           if (discountAmount.compareTo(BigDecimal.ZERO) < 1) return BigDecimal.ONE;
   
           return discountAmount;
       }
   }    
   
   //直减
   public class ZJCouponDiscount implements ICouponDiscount<Double>  {
       /**
        * 直减计算
        * 1. 使用商品价格减去优惠价格
        * 2. 最低支付金额1元
        */
       public BigDecimal discountAmount(Double couponInfo, BigDecimal skuPrice) {
           BigDecimal discountAmount = skuPrice.subtract(new BigDecimal(couponInfo));
           if (discountAmount.compareTo(BigDecimal.ZERO) < 1) return BigDecimal.ONE;
           return discountAmount;
       }
   }
   
   //折扣
   public class ZKCouponDiscount implements ICouponDiscount<Double> {
       /**
        * 折扣计算
        * 1. 使用商品价格乘以折扣比例，为最后支付金额
        * 2. 保留两位小数
        * 3. 最低支付金额1元
        */
       public BigDecimal discountAmount(Double couponInfo, BigDecimal skuPrice) {
           BigDecimal discountAmount = skuPrice.multiply(new BigDecimal(couponInfo)).setScale(2, BigDecimal.ROUND_HALF_UP);
           if (discountAmount.compareTo(BigDecimal.ZERO) < 1) return BigDecimal.ONE;
           return discountAmount;
       }
   }
   
   //N元购
   public class NYGCouponDiscount implements ICouponDiscount<Double> {
       /**
        * n元购购买
        * 1. 无论原价多少钱都固定金额购买
        */
       public BigDecimal discountAmount(Double couponInfo, BigDecimal skuPrice) {
           return new BigDecimal(couponInfo);
       }
   }
   ```

3. 策略控制类

   ```java
   public class Context<T> {
   
       private ICouponDiscount<T> couponDiscount;
   
       //构造参数传入具体的策略实现类
       public Context(ICouponDiscount<T> couponDiscount) {
           this.couponDiscount = couponDiscount;
       }
   
       //开始计算最终计算后的金额-统一的优惠策略计算
       public BigDecimal discountAmount(T couponInfo, BigDecimal skuPrice) {
           return couponDiscount.discountAmount(couponInfo, skuPrice);
       }
   }
   ```

4. 测试验证（直减优惠）

   ```java
   @Test
   public void test_zj() {
       // 直减；100-10，商品100元
       Context<Double> context = new Context<Double>(new ZJCouponDiscount());
       BigDecimal discountAmount = context.discountAmount(10D, new BigDecimal(100));
       logger.info("测试结果：直减优惠后金额 {}", discountAmount);
   }
   ```

   ![image-20230105111223247](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/202301051112359.png)

5. 测试验证（满减优惠）

   ```java
   @Test
   public void test_mj() {
       // 满100减10，商品100元
       Context<Map<String,String>> context = new Context<Map<String,String>>(new MJCouponDiscount());
       Map<String,String> mapReq = new HashMap<String, String>();
       mapReq.put("x","100");
       mapReq.put("n","10");
       BigDecimal discountAmount = context.discountAmount(mapReq, new BigDecimal(100));
       logger.info("测试结果：满减优惠后金额 {}", discountAmount);
   }
   ```

   ![image-20230105111300314](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/202301051113383.png)





## 小结

1. 上例的逻辑主要体现在关于不同种类优惠券的计算折扣策略上，结构相对来说比较简单。



# 模板模式（Tenmplate Pattern)

> 即在一个抽象类中公开定义了执行某一方法的模板，然后子类可以按需重写方法实现自己特有的逻辑...

![模版模式，图片来自 refactoringguru.cn](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/202301051120843.png)

定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。

**优点：**

1. 封装不变部分，扩展可变部分
2. 提取公共代码，便于维护
3. 行为由父类控制，子类实现

**使用场景**：

1. 有多个子类共有的方法，且逻辑相同
2. 重要的、复杂的方法，可以考虑作为模板方法

> 模板模式的核心设计思路是通过在，在抽象类中定义抽象方法的执行顺序，并将抽象方法设定为只有子类实现，但设计`独立访问`的方法。简单来说就是把你安排的、明明白白的！



模板模式的核心：在于抽象类定义抽象方法执行策略，也就是说父类规定了好一系列的执行标准，这些标准的串联成一整套业务流程。

## 代码引进

案例：模拟一个爬虫业务去爬各种网站然后生成一个营销海报场景。

步骤：*模拟登录*、*爬取信息*、*生成海报*。另外：

1. 因为有些商品只有登录后才可以爬取，并且登录可以看到一些特定的价格这与未登录用户看到的价格不同。
2. 不同的电商网站爬取方式不同，解析方式也不同，因此可以作为每一个实现类中的特定实现。
3. 生成海报的步骤基本一样，但会有特定的商品来源标识。所以这样三个步骤可以使用模版模式来设定，并有具体的场景做子类实现。

**模型结构**：

![模版模式模型结构](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/202301051335770.png)

代码：

1. 定义执行顺序的抽象类

   ```java
   /**
    * 基础电商推广服务
    * 1. 生成最优价商品海报
    * 2. 海报含带推广邀请码
    */
   public abstract class NetMall {
       protected Logger logger = LoggerFactory.getLogger(NetMall.class);
   
       String uId;   // 用户ID
       String uPwd;  // 用户密码
   
       public NetMall(String uId, String uPwd) {
           this.uId = uId;
           this.uPwd = uPwd;
       }
   
       /**
        * 生成商品推广海报
        *
        * @param skuUrl 商品地址(京东、淘宝、当当)
        * @return 海报图片base64位信息
        */
       public String generateGoodsPoster(String skuUrl) {
           if (!login(uId, uPwd)) return null;             // 1. 验证登录
           Map<String, String> reptile = reptile(skuUrl);  // 2. 爬虫商品
           return createBase64(reptile);                   // 3. 组装海报
       }
   
       // 模拟登录
       protected abstract Boolean login(String uId, String uPwd);
   
       // 爬虫提取商品信息(登录后的优惠价格)
       protected abstract Map<String, String> reptile(String skuUrl);
   
       // 生成商品海报信息
       protected abstract String createBase64(Map<String, String> goodsInfo);
   }
   ```

   这个类是比较核心的，*generateGoodsPoster*方法用于生成海报，并且在其中定义抽象方法的执行顺序1 2 3步。

2. 模拟爬取网站

   **京东**

   ```java
   public class JDNetMall extends NetMall {
       public JDNetMall(String uId, String uPwd) {
           super(uId, uPwd);
       }
   
       public Boolean login(String uId, String uPwd) {
           logger.info("模拟京东用户登录 uId：{} uPwd：{}", uId, uPwd);
           return true;
       }
   
       public Map<String, String> reptile(String skuUrl) {
           String str = HttpClient.doGet(skuUrl);
           Pattern p9 = Pattern.compile("(?<=title\\>).*(?=</title)");
           Matcher m9 = p9.matcher(str);
           Map<String, String> map = new ConcurrentHashMap<String, String>();
           if (m9.find()) {
               map.put("name", m9.group());
           }
           map.put("price", "5999.00");
           logger.info("模拟京东商品爬虫解析：{} | {} 元 {}", map.get("name"), map.get("price"), skuUrl);
           return map;
       }
   
       public String createBase64(Map<String, String> goodsInfo) {
           BASE64Encoder encoder = new BASE64Encoder();
           logger.info("模拟生成京东商品base64海报");
           return encoder.encode(JSON.toJSONString(goodsInfo).getBytes());
       }
   }
   ```

   **淘宝**

   ```java
   public class TaoBaoNetMall extends NetMall {
       public TaoBaoNetMall(String uId, String uPwd) {
           super(uId, uPwd);
       }
   
       @Override
       public Boolean login(String uId, String uPwd) {
           logger.info("模拟淘宝用户登录 uId：{} uPwd：{}", uId, uPwd);
           return true;
       }
   
       @Override
       public Map<String, String> reptile(String skuUrl) {
           String str = HttpClient.doGet(skuUrl);
           Pattern p9 = Pattern.compile("(?<=title\\>).*(?=</title)");
           Matcher m9 = p9.matcher(str);
           Map<String, String> map = new ConcurrentHashMap<String, String>();
           if (m9.find()) {
               map.put("name", m9.group());
           }
           map.put("price", "4799.00");
           logger.info("模拟淘宝商品爬虫解析：{} | {} 元 {}", map.get("name"), map.get("price"), skuUrl);
           return map;
       }
   
       @Override
       public String createBase64(Map<String, String> goodsInfo) {
           BASE64Encoder encoder = new BASE64Encoder();
           logger.info("模拟生成淘宝商品base64海报");
           return encoder.encode(JSON.toJSONString(goodsInfo).getBytes());
       }
   }
   ```

   **当当网**

   ```java
   public class DangDangNetMall extends NetMall {
       public DangDangNetMall(String uId, String uPwd) {
           super(uId, uPwd);
       }
   
       @Override
       public Boolean login(String uId, String uPwd) {
           logger.info("模拟当当用户登录 uId：{} uPwd：{}", uId, uPwd);
           return true;
       }
   
       @Override
       public Map<String, String> reptile(String skuUrl) {
           String str = HttpClient.doGet(skuUrl);
           Pattern p9 = Pattern.compile("(?<=title\\>).*(?=</title)");
           Matcher m9 = p9.matcher(str);
           Map<String, String> map = new ConcurrentHashMap<String, String>();
           if (m9.find()) {
               map.put("name", m9.group());
           }
           map.put("price", "4548.00");
           logger.info("模拟当当商品爬虫解析：{} | {} 元 {}", map.get("name"), map.get("price"), skuUrl);
           return map;
       }
   
       @Override
       public String createBase64(Map<String, String> goodsInfo) {
           BASE64Encoder encoder = new BASE64Encoder();
           logger.info("模拟生成当当商品base64海报");
           return encoder.encode(JSON.toJSONString(goodsInfo).getBytes());
       }
   }
   ```

3. 测试

   ```java
   /**
    * 测试链接
    * 京东；https://item.jd.com/100008348542.html
    * 淘宝；https://detail.tmall.com/item.htm
    * 当当；http://product.dangdang.com/1509704171.html
    */
   @Test
   public void test_NetMall() {
       NetMall netMall = new JDNetMall("1000001","*******");
       String base64 = netMall.generateGoodsPoster("https://item.jd.com/100008348542.html");
       logger.info("测试结果：{}", base64);
   }
   ```

   

## 小结

- 通过上面的实现可以看到`模版模式`在定义统一结构也就是执行标准上非常方便，也就很好的控制了后续的实现者不用关心调用逻辑，按照统一方式执行。那么类的继承者只需要关心具体的业务逻辑实现即可。
- 另外模版模式也是为了解决子类通用方法，放到父类中设计的优化。让每一个子类只做子类需要完成的内容，而不需要关心其他逻辑。这样提取公用代码，行为由父类管理，扩展可变部分，也就非常有利于开发拓展和迭代。

# 访问者模式（Visitor Pattern)

> 在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。

![访问者模式，图片来自 refactoringguru.cn](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/202301051408834.png)

访问者要解决的核心事项是，在一个稳定的数据结构下，例如用户信息、雇员信息等，增加易变的业务访问逻辑。为了增强扩展性，将这两部分的业务解耦的一种设计模式。

**说白了访问者模式的核心就在于同一个事务不同视角下的访问信息不同。**

## 代码引进

**案例**：

​	模拟校园中有学生和老师两种身份的用户，那么对于家长和校长关心的角度来看，他们的视角是不同的。家长更关心孩子的成绩和老师的能力，校长更关心老师所在班级学生的人数和升学率。

​	那么这样`学生`和`老师`就是一个固定信息的内容，而想让不同视角的用户获取关心的信息，就比较适合使用观察者模式来实现，从而让实体与业务解耦，增强扩展性

**模型结构：**

![访问者模式模型结构](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/202301051416033.png)

主要是不同视角下的不同用户访问模型。

核心点就在于*visitor.visit(this)*。存在于每一个用户的实现类中。

1. 定义用户抽象类

   ```java
   // 基础用户信息
   public abstract class User {
   
       public String name;      // 姓名
       public String identity;  // 身份；重点班、普通班 | 特级教师、普通教师、实习教师
       public String clazz;     // 班级
   
       public User(String name, String identity, String clazz) {
           this.name = name;
           this.identity = identity;
           this.clazz = clazz;
       }
   
       // 核心访问方法。让后续的用户具体实现者都能提供出一个访问方法，共外部使用
       public abstract void accept(Visitor visitor);
   }
   ```

2. 实现用户实现类中

   ```java
   //老师类
   public class Teacher extends User {
       public Teacher(String name, String identity, String clazz) {super(name, identity, clazz); }
       //核心，传进具体的访问者，然后将当前作为访问视角参数传入去访问
       public void accept(Visitor visitor) {
           visitor.visit(this);
       }
       // 升本率
       public double entranceRatio() {
           return BigDecimal.valueOf(Math.random() * 100).setScale(2, BigDecimal.ROUND_HALF_UP).doubleValue();
       }
   }
   
   
   //学生类
   public class Student extends User {
       public Student(String name, String identity, String clazz) {super(name, identity, clazz);}
       public void accept(Visitor visitor) {
           visitor.visit(this);
       }
       //排名
       public int ranking() {return (int) (Math.random() * 100);}
   }
   ```

3. 定义访问数据接口

   ```java
   public interface Visitor {
       // 访问学生信息
       void visit(Student student);
       // 访问老师信息
       void visit(Teacher teacher);
   }
   ```

4. 具体的访问类型（校长和家长）

   ```java
   //校长
   public class Principal implements Visitor {
       private Logger logger = LoggerFactory.getLogger(Principal.class);
   
       public void visit(Student student) {
           logger.info("学生信息 姓名：{} 班级：{}", student.name, student.clazz);
       }
   
       public void visit(Teacher teacher) {
           logger.info("学生信息 姓名：{} 班级：{} 升学率：{}", teacher.name, teacher.clazz, teacher.entranceRatio());
       }
   }
   
   //家长
   public class Parent implements Visitor {
       private Logger logger = LoggerFactory.getLogger(Parent.class);
       public void visit(Student student) {
           logger.info("学生信息 姓名：{} 班级：{} 排名：{}", student.name, student.clazz, student.ranking());
       }
   
       public void visit(Teacher teacher) {
           logger.info("老师信息 姓名：{} 班级：{} 级别：{}", teacher.name, teacher.clazz, teacher.identity);
       }
   }
   
   ```

   - 以上是两个具体的访问者实现类，他们都有自己的视角需求。
   - 校长关注；学生的名称和班级，老师对这个班级的升学率
   - 家长关注；自己家孩子的排名，老师的班级和教学水平

5. 数据看版

   ```java
   public class DataView {
       List<User> userList = new ArrayList<User>();
   	
       //初始化了基本的数据，学生和老师的信息
       public DataView() {
           userList.add(new Student("谢飞机", "重点班", "一年一班"));
           userList.add(new Student("windy", "重点班", "一年一班"));
           userList.add(new Student("大毛", "普通班", "二年三班"));
           userList.add(new Student("Shing", "普通班", "三年四班"));
           userList.add(new Teacher("BK", "特级教师", "一年一班"));
           userList.add(new Teacher("娜娜Goddess", "特级教师", "一年一班"));
           userList.add(new Teacher("dangdang", "普通教师", "二年三班"));
           userList.add(new Teacher("泽东", "实习教师", "三年四班"));
       }
   
       // 展示，传入不同的观察者(校长、家长)的差异化的打印信息
       public void show(Visitor visitor) {
           for (User user : userList) {
               user.accept(visitor);
           }
       }
   }
   ```

6. 测试类

   ```java
   @Test
   public void test(){
       DataView dataView = new DataView();      
   
       logger.info("\r\n家长视角访问：");
       dataView.show(new Parent());     // 家长
   
       logger.info("\r\n校长视角访问：");
       dataView.show(new Principal());  // 校长
   }
   ```

7. 测试结果

   ![image-20230105143627071](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/202301051436195.png)

## 小结

1. 在嵌入访问者模式后，可以让整个工程结构变得容易添加和修改。也就做到了系统服务之间的解耦，不至于为了不同类型信息的访问而增加很多多余的`if`判断或者类的强制转换。也就是通过这样的设计模式而让代码结构更加清晰。
2. 定义抽象类的时候还需要等待访问者接口的定义，这样的设计首先从实现上会让代码的组织变得有些难度。另外从设计模式原则的角度来看，违背了迪米特原则，也就是最少知道原则。因此在使用上一定要符合场景的运用，以及提取这部分设计思想的精髓。



# 解释器模式（interpreter Pattern)

> 提供如何定义语言的文法，以及对语言句子的解释方法，即解释器

给定一个语言，定义它的文法的一种表示并定义一个解释器，这个解释器使用该表示来解释语言中的句子。

*简单理解*：例如给定一个表达式：a+b，让后设置a为1，b为2，计算a+b的值。可以定义一个值解释器，它用来解释变量a和变量b的值。定义一个加法解释器，他用来解释a+b,即先通过值表达式解释变量a和变量b的值，然后将它们相加。



**优点:**

1. 扩展性强，如果增加新的语法，只需要增加对应的解释器。
2. 可以轻松的解释简单语法

**缺点：**

1. 不适用复杂的文法，对于复杂的文法，文法的类层次将变得庞大且无法管理。这时，使用语法分析程序生成器这样的工具比较好。
2. **不常使用**。解释器模式的适用场景比较少，是不常用的模式之一。

## 代码引进

​	实现一个计算器，当你输入例如 a + b + c 这样的加减法表达式并指定每个参数的值，计算这个表达式的结果。定义数值解析器用来解析变量(根据变量名来获取其值)，定义加法解释器来解释加法(利用数值解析器解析两个变量的值，将它们的数值相加)，定义减法解释器来解释减法(和加法解释器类似)。



1. Expression抽象类

   ```java
   package interpreterPattern;
   
   import java.util.HashMap;
   
   /**
    * 表达式类，是一个抽象类
    * @author jxd
    * @since 2021-06-12
    */
   public abstract class Expression {
       
       //解析公式和数值，key是公式中的参数，value是具体的数值
       public abstract int interpreter(HashMap<String, Integer> var);
   }
   ```

2. VarExpression类

   ```java
   /**
    * 变量解释器，根据变量名获取变量的值
    * @author jxd
    * @since 2021-06-12
    */
   public class VarExpression extends Expression {
       /**
        * 变量名，在 变量名-值 的键值对中就是键
        */
       private String key;
   
       public VarExpression(String key) { this.key = key;}
   
       /**
        * 解释变量
        */
       @Override
       public int interpreter(HashMap<String, Integer> var) {return var.get(this.key); }
   }
   ```

3. SymbolExpression类

   ```java
   /**
    * 符号解释器类，是所有运算(+ - * /)解释器的父类
    * 符号解析只与符号的左表达式和右表达式有关
    * @author jxd
    * @since 2021-06-12
    */
   public class SymbolExpression extends Expression {
       /**
        * 符号表达式的左表达式
        */
       protected Expression left;
       
       /**
        * 符号表达式的右表达式
        */
       protected Expression right;
   
       public SymbolExpression(Expression left, Expression right) {
           this.left = left;
           this.right = right;
       }
   
       /**
        * 解释方法，默认实现，需要子类覆盖
        */
       @Override
       public int interpreter(HashMap<String, Integer> var) {return 0; }
   }
   ```

4. SubExpression类

   ```java
   /**
    * 减法解释器，继承自符号解释器，覆盖了父类中的interpreter(解释)方法
    * @author jxd
    * @since 2021-06-12
    */
   public class SubExpression extends SymbolExpression {
   
       public SubExpression(Expression left, Expression right) {
           super(left, right);
       }
   
       /**
        * 减法解释器中的解释方法
        */
       public int interpreter(HashMap<String, Integer> var) {
           // 例如：a - b == a-> 1 b->2 == 1 - 2 == -1
           return super.left.interpreter(var) - super.right.interpreter(var);
       }
   }
   ```

5. AddExpression类

   ```java
   /**
    * 加法解释器类
    * @author jxd
    * @since 2021-06-12
    */
   public class AddExpression extends SymbolExpression {
   
       public AddExpression(Expression left, Expression right) {
           super(left, right);
       }
   
       /**
        * 重写了interpreter方法
        */
       public int interpreter(HashMap<String, Integer> var) {
           return super.left.interpreter(var) + super.right.interpreter(var);
       }
   }
   ```

6. Calculator类

   ```java
   /**
    * 计算器类-利用解释器来计算表达式的结果
    * @author jxd
    * @since 2021-06-12
    */
   public class Calculator {
   
       //定义表达式
       private Expression expression;
   
       //构造函数传参，并解析
       public Calculator(String expStr) {
           //安排运算先后顺序
           Stack<Expression> stack = new Stack<>();
           //表达式拆分为字符数组
           char[] charArray = expStr.toCharArray();
   
           Expression left = null;
           Expression right = null;
           for(int i=0; i<charArray.length; i++) {
               switch (charArray[i]) {
               case '+':    //加法
                   left = stack.pop();
                   right = new VarExpression(String.valueOf(charArray[++i]));
                   stack.push(new AddExpression(left, right));
                   break;
               case '-':    //减法
                   left = stack.pop();
                   right = new VarExpression(String.valueOf(charArray[++i]));
                   stack.push(new SubExpression(left, right));
                   break;
               default:    //公式中的变量
                   stack.push(new VarExpression(String.valueOf(charArray[i])));
                   break;
               }
           }
           
           //栈中最后只会有一个表达式对象
           this.expression = stack.pop();
       }
   
       //计算表达式
       public int run(HashMap<String, Integer> var) {
           return this.expression.interpreter(var);
       }
   }
   ```

7. Clinet类

   ```java
   /**
    * 客户端，接收用户输入的表达式和变量的值，然后利用计算器来运算表达式的结果
    * @author jxd
    * @since 2021-06-12
    */
   public class Client {
   
       public static void main(String[] args) throws IOException {
           String expStr = getExpStr();
           HashMap<String, Integer> var = getValue(expStr);
           Calculator calculator = new Calculator(expStr);
           System.out.println("运算结果：" + expStr + "=" + calculator.run(var));
       }
   
       /**
        * 获得表达式
        * @return 用户输入的表达式
        * @throws IOException
        */
       public static String getExpStr() throws IOException {
           System.out.print("请输入表达式：");
           return (new BufferedReader(new InputStreamReader(System.in))).readLine();
       }
   
       /**
        * 获得值映射
        * @param expStr
        * @return 每一个变量对应的值，是一个Map
        * @throws IOException
        */
       public static HashMap<String, Integer> getValue(String expStr) throws IOException {
           HashMap<String, Integer> map = new HashMap<>();
   
           for(char ch : expStr.toCharArray()) {
               if(ch != '+' && ch != '-' ) {
                   if(! map.containsKey(String.valueOf(ch))) {
                       System.out.print("请输入" + String.valueOf(ch) + "的值：");
                       String in = (new BufferedReader(new InputStreamReader(System.in))).readLine();
                       map.put(String.valueOf(ch), Integer.valueOf(in));
                   }
               }
           }
   
           return map;
       }
   }
   ```

8. 测试结果

   ![image-20230105150304057](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/202301051503158.png)

## 小结

**解释器模式就是为不同的语法设置不同的解释器，让后利用解释器来计算表达式的值或解释表达式的含义，关键在于如何实现解释器**
