**创建型模式**：提供创建对象的机制， 能够提升已有代码的灵活性和可复用性。

**结构性模式**:将对象和类按某种布局组成更大的结构，并同时保持结构的灵活和⾼效。

**行为型模式**：负责对象间的高效沟通和职责委派。

> 面向对象设计的六大原则

1. 里式替换原则
   - 多态，子类可扩展父类
2. 开闭原则
   - 抽象架构，扩展实现（对_修改_关闭，对_扩展_开放）继承父类扩展需要的方法，同时保留原有的方法，新增自己需要的方法。
3. 依赖倒置原则
   - 实现开闭原则的重要途径之一，它降低了客户与实现模块之间的耦合
   - 细节依赖抽象，下层依赖上层。
4. 迪米特法则原则
   - 最少知道，降低耦合
5. 接口隔离原则
   - 建立单一接口，尽量将庞大的接口拆分成更小&更具体的接口
6. 单一职责原则
   - 一个类和方法只做一件事

> 小结

![image-20230105165334054](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/202301051653250.png)

> 自我理解

**创建型模式**

1. *工厂方法*：

   1. 简单工厂：封装一个类，然后由传递进来的参数进行if-else来判断创建对应的类返回其父类
   2. 普通工厂：创建一个抽象工厂，然后在抽象工厂里存放产品父类的引用，然后在具体的抽象工厂实现类里实现具体产品的创建，封装了单个对象本身复杂的创建过程，并将复杂的创建过程封装在工厂类中。

2. *抽象工厂*：说白了就是含有多个产品系列，然后在抽象工厂中引用，然后具体的工厂实现类里进行重写使用。

3. *建造者模式*：在类中每个方法的执行返回都是当前类的引用。

4. *原型模式*：实现接口Cloneable并重写clone方法，然后需要克隆复制就行，但需要注意的是成员变量是引用类型则共享同一个地址引用，基础类型则只是copy值。

5. *单例模式*：

   1. 饿汉式：一开始就加载引用，采用static静态变量或者静态代码块一开始加载！--缺点内存浪费
   2. 懒汉式：调用方法才开始进行实例化！--缺点 线程不安全
      1. 双重检查：本身属于懒汉式，方法本身加锁然后在内部先执行判断，然后在加锁，锁内部再判断一次。
      2. 静态内部类：本身属于懒汉式，方法本身加锁，然后调用静态内部类，类内部进行静态static初始化，这种的话调用方法加载类的时候才会进行初始化并唯一所以保证了安全-初始化时只能一个线程进入。
   3. 枚举：没什么好说的 天生自带单例！

---

**结构型模式**

1. *适配器模式*：
   1. 类适配器：
