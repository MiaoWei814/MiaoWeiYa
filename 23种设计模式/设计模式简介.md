**创建型模式**：提供创建对象的机制， 能够提升已有代码的灵活性和可复用性。

**结构性模式**:将对象和类按某种布局组成更大的结构，并同时保持结构的灵活和⾼效。

**行为型模式**：负责对象间的高效沟通和职责委派。

> 面向对象设计的六大原则

1. 里式替换原则
   - 多态，子类可扩展父类
2. 开闭原则
   - 抽象架构，扩展实现（对_修改_关闭，对_扩展_开放）继承父类扩展需要的方法，同时保留原有的方法，新增自己需要的方法。
3. 依赖倒置原则
   - 实现开闭原则的重要途径之一，它降低了客户与实现模块之间的耦合
   - 细节依赖抽象，下层依赖上层。
4. 迪米特法则原则
   - 最少知道，降低耦合
5. 接口隔离原则
   - 建立单一接口，尽量将庞大的接口拆分成更小&更具体的接口
6. 单一职责原则
   - 一个类和方法只做一件事

> 小结

![image-20230105165334054](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/202301051653250.png)

> 自我理解

**创建型模式**

1. *工厂方法*：

   1. 简单工厂：封装一个类，然后由传递进来的参数进行if-else来判断创建对应的类返回其父类
   2. 普通工厂：创建一个抽象工厂，然后在抽象工厂里存放产品父类的引用，然后在具体的抽象工厂实现类里实现具体产品的创建，封装了单个对象本身复杂的创建过程，并将复杂的创建过程封装在工厂类中。

2. *抽象工厂*：说白了就是含有多个产品系列，然后在抽象工厂中引用，然后具体的工厂实现类里进行重写使用。

3. *建造者模式*：在类中每个方法的执行返回都是当前类的引用。

4. *原型模式*：实现接口Cloneable并重写clone方法，然后需要克隆复制就行，但需要注意的是成员变量是引用类型则共享同一个地址引用，基础类型则只是copy值。

5. *单例模式*：

   1. 饿汉式：一开始就加载引用，采用static静态变量或者静态代码块一开始加载！--缺点内存浪费
   2. 懒汉式：调用方法才开始进行实例化！--缺点 线程不安全
      1. 双重检查：本身属于懒汉式，方法本身加锁然后在内部先执行判断，然后在加锁，锁内部再判断一次。
      2. 静态内部类：本身属于懒汉式，方法本身加锁，然后调用静态内部类，类内部进行静态static初始化，这种的话调用方法加载类的时候才会进行初始化并唯一所以保证了安全-初始化时只能一个线程进入。
   3. 枚举：没什么好说的 天生自带单例！

---

**结构型模式**

1. *适配器模式*：

   1. 类适配器：单继承，一次只能适配一个适配者类。整体就是适配器类去继承被适配的class然后实现适配的接口并重写方法，在方法里super.父类然后进行适配
   2. 对象适配器：在适配器类里采用不继承而是持有被适配器类的实例的引用，实现适配接口并重写方法。
   3. 接口适配模式：不需要全部实现接口中所有方法时，设计一个抽象类实现接口然后全部默认实现方法，然后再将抽象类的实现类可选择性的重写方法。

2. *桥接模式*：抽象与实现分离，多种可匹配选项进行组合，核心就是A类中持有B类接口，通过构造函数传递B类的使用。

3. *组合模式*：应用于树形结构，在其内部实体类中构建集合然后类型是当前类。

4. *装饰器模式*：无声息中扩展新的功能。核心就是建立一个装饰角色抽象类来实现处理接口，然后在类中存储处理接口的引用(构造函数传递引用)，然后在装饰角色具体类中进行具体功能的重写。---在测试调用的时候只需要new现在具体的实现类，然后将想要继承谁作为构造参数进行传递即可

   ![](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/202301061019979.png)

5. *外观模式*：建立一个外观类，在其内部存放各个类的引用。然后构建几个方法其中存放并简化其中类的访问内部子系统的方法。
6. *享元模式*：代码方式多种多样，可内存可缓存总之要每次访问对象都是处于共享的！
7. *代理模式*: 
   1. 静态代理：构建一个类来实现目标接口，然后在其内部存放接口的引用，然后重写方法时根据自己需要进行对代理接口的增强或编辑操作。--固定代码存在不解耦性
   2. 动态代理：
      - JDK：构建一个类采用JDK的反射特性来进行对目标接口的增强操作。
      - CGLIB：对目标类生成一个子类并通过回调的方式来实现增强，但因为采用的是继承，所以不能对 final 修饰的类进行代理。

----

**行为型模式**

1. *责任链模式*：说白了这个就是抽象类中定义一个成员变量为自身，然后在具体的实现类中获取父类中的成员变量然后去调用自身，有点类似于递归调用。在测试类中添加对象为一条链路调用。

2. *命令模式*：请求发出命令与具体的逻辑实现进行分开。准备两个抽象类，一个是命令的抽象类，一个是实现的抽象类，然后在命令的抽象类实现者里存放实现的抽象类的引用并调用，然后就OK了，在测试时，我们只需要将调用中间处理类，传入命令类，然后自然就会调用实现的具体抽象类了。

   ![image-20230106112532296](https://springcloud-hrm-miao.oss-cn-beijing.aliyuncs.com/markdown/202301061125351.png)

3. *迭代器模式*：定义一个能遍历集合元素的工具，这个集合元素可以是任意数据结构。

4. *中介者模式*：顾名思义就是定义一个中介者类，然后让两个对象不直接访问，只需要访问中介者类就能处理并返回，但是这个中介者类里得知道相关通过它才能访问的信息-也就是说类里得提前定义好。

5. *备忘录模式*：代码不固定，核心思想是建立一个备忘录类(数据库或缓存)存放，然后在其记录者类里提供接口，然后用于保存备份。

6. *观察者模式*：定义一个监听者类，然后实现具体的监听执行方法，然后在其抽象类中构造方法将其订阅通知，然后描述执行步骤，然后业务代码由抽象方法由子类进行重写。

7. *状态模式*：适用于多种状态变化，然后每种状态建立一个类，在其中对每种可能会出现的情况进行构建方法体，然后创建一个方法处理类在其中通过枚举去获取对应的状态实体类去执行。

8. *策略模式*：定义一个抽象策略类-也就是说此类中提供所有的具体策略所需的接口，然后在构建一个具体策略类用于提供具体的算法实现或行为。然后再定义一个环境类用于持有策略类的引用给客户端使用。

9. *模板模式*：构建抽象类然后将其不同行为的方法设置为抽象方法供具体的实现类进行实现，然后将其这些抽象方法集中在一个方法里调整好顺序，供外部调用。而子类只需要重新特定的方法----这就是模板，不用去管上层的如何使用子类只需要重写即可。

10. *访问者模式*：同一个事务不同视角下访问信息不同，核心通过`this`来处理。

11. *解释器模式*：很少使用。

​	
